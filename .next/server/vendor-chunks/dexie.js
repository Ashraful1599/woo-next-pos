/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dexie";
exports.ids = ["vendor-chunks/dexie"];
exports.modules = {

/***/ "(ssr)/./node_modules/dexie/dist/dexie.js":
/*!******************************************!*\
  !*** ./node_modules/dexie/dist/dexie.js ***!
  \******************************************/
/***/ (function(module) {

eval("/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 4.0.7, Sun May 26 2024\n *\n * https://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\n \n(function (global, factory) {\n     true ? module.exports = factory() :\n    0;\n})(this, (function () { 'use strict';\n\n    /*! *****************************************************************************\n    Copyright (c) Microsoft Corporation.\n    Permission to use, copy, modify, and/or distribute this software for any\n    purpose with or without fee is hereby granted.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n    PERFORMANCE OF THIS SOFTWARE.\n    ***************************************************************************** */\n    var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    function __extends(d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    }\n    var __assign = function() {\n        __assign = Object.assign || function __assign(t) {\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\n                s = arguments[i];\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n            return t;\n        };\n        return __assign.apply(this, arguments);\n    };\n    function __spreadArray(to, from, pack) {\n        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n            if (ar || !(i in from)) {\n                if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n                ar[i] = from[i];\n            }\n        }\n        return to.concat(ar || Array.prototype.slice.call(from));\n    }\n\n    var _global = typeof globalThis !== 'undefined' ? globalThis :\n        typeof self !== 'undefined' ? self :\n            typeof window !== 'undefined' ? window :\n                global;\n\n    var keys = Object.keys;\n    var isArray = Array.isArray;\n    if (typeof Promise !== 'undefined' && !_global.Promise) {\n        _global.Promise = Promise;\n    }\n    function extend(obj, extension) {\n        if (typeof extension !== 'object')\n            return obj;\n        keys(extension).forEach(function (key) {\n            obj[key] = extension[key];\n        });\n        return obj;\n    }\n    var getProto = Object.getPrototypeOf;\n    var _hasOwn = {}.hasOwnProperty;\n    function hasOwn(obj, prop) {\n        return _hasOwn.call(obj, prop);\n    }\n    function props(proto, extension) {\n        if (typeof extension === 'function')\n            extension = extension(getProto(proto));\n        (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(function (key) {\n            setProp(proto, key, extension[key]);\n        });\n    }\n    var defineProperty = Object.defineProperty;\n    function setProp(obj, prop, functionOrGetSet, options) {\n        defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ?\n            { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :\n            { value: functionOrGetSet, configurable: true, writable: true }, options));\n    }\n    function derive(Child) {\n        return {\n            from: function (Parent) {\n                Child.prototype = Object.create(Parent.prototype);\n                setProp(Child.prototype, \"constructor\", Child);\n                return {\n                    extend: props.bind(null, Child.prototype)\n                };\n            }\n        };\n    }\n    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n    function getPropertyDescriptor(obj, prop) {\n        var pd = getOwnPropertyDescriptor(obj, prop);\n        var proto;\n        return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n    }\n    var _slice = [].slice;\n    function slice(args, start, end) {\n        return _slice.call(args, start, end);\n    }\n    function override(origFunc, overridedFactory) {\n        return overridedFactory(origFunc);\n    }\n    function assert(b) {\n        if (!b)\n            throw new Error(\"Assertion Failed\");\n    }\n    function asap$1(fn) {\n        if (_global.setImmediate)\n            setImmediate(fn);\n        else\n            setTimeout(fn, 0);\n    }\n    function arrayToObject(array, extractor) {\n        return array.reduce(function (result, item, i) {\n            var nameAndValue = extractor(item, i);\n            if (nameAndValue)\n                result[nameAndValue[0]] = nameAndValue[1];\n            return result;\n        }, {});\n    }\n    function getByKeyPath(obj, keyPath) {\n        if (typeof keyPath === 'string' && hasOwn(obj, keyPath))\n            return obj[keyPath];\n        if (!keyPath)\n            return obj;\n        if (typeof keyPath !== 'string') {\n            var rv = [];\n            for (var i = 0, l = keyPath.length; i < l; ++i) {\n                var val = getByKeyPath(obj, keyPath[i]);\n                rv.push(val);\n            }\n            return rv;\n        }\n        var period = keyPath.indexOf('.');\n        if (period !== -1) {\n            var innerObj = obj[keyPath.substr(0, period)];\n            return innerObj == null ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n        }\n        return undefined;\n    }\n    function setByKeyPath(obj, keyPath, value) {\n        if (!obj || keyPath === undefined)\n            return;\n        if ('isFrozen' in Object && Object.isFrozen(obj))\n            return;\n        if (typeof keyPath !== 'string' && 'length' in keyPath) {\n            assert(typeof value !== 'string' && 'length' in value);\n            for (var i = 0, l = keyPath.length; i < l; ++i) {\n                setByKeyPath(obj, keyPath[i], value[i]);\n            }\n        }\n        else {\n            var period = keyPath.indexOf('.');\n            if (period !== -1) {\n                var currentKeyPath = keyPath.substr(0, period);\n                var remainingKeyPath = keyPath.substr(period + 1);\n                if (remainingKeyPath === \"\")\n                    if (value === undefined) {\n                        if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))\n                            obj.splice(currentKeyPath, 1);\n                        else\n                            delete obj[currentKeyPath];\n                    }\n                    else\n                        obj[currentKeyPath] = value;\n                else {\n                    var innerObj = obj[currentKeyPath];\n                    if (!innerObj || !hasOwn(obj, currentKeyPath))\n                        innerObj = (obj[currentKeyPath] = {});\n                    setByKeyPath(innerObj, remainingKeyPath, value);\n                }\n            }\n            else {\n                if (value === undefined) {\n                    if (isArray(obj) && !isNaN(parseInt(keyPath)))\n                        obj.splice(keyPath, 1);\n                    else\n                        delete obj[keyPath];\n                }\n                else\n                    obj[keyPath] = value;\n            }\n        }\n    }\n    function delByKeyPath(obj, keyPath) {\n        if (typeof keyPath === 'string')\n            setByKeyPath(obj, keyPath, undefined);\n        else if ('length' in keyPath)\n            [].map.call(keyPath, function (kp) {\n                setByKeyPath(obj, kp, undefined);\n            });\n    }\n    function shallowClone(obj) {\n        var rv = {};\n        for (var m in obj) {\n            if (hasOwn(obj, m))\n                rv[m] = obj[m];\n        }\n        return rv;\n    }\n    var concat = [].concat;\n    function flatten(a) {\n        return concat.apply([], a);\n    }\n    var intrinsicTypeNames = \"BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\"\n        .split(',').concat(flatten([8, 16, 32, 64].map(function (num) { return [\"Int\", \"Uint\", \"Float\"].map(function (t) { return t + num + \"Array\"; }); }))).filter(function (t) { return _global[t]; });\n    var intrinsicTypes = new Set(intrinsicTypeNames.map(function (t) { return _global[t]; }));\n    function cloneSimpleObjectTree(o) {\n        var rv = {};\n        for (var k in o)\n            if (hasOwn(o, k)) {\n                var v = o[k];\n                rv[k] = !v || typeof v !== 'object' || intrinsicTypes.has(v.constructor) ? v : cloneSimpleObjectTree(v);\n            }\n        return rv;\n    }\n    function objectIsEmpty(o) {\n        for (var k in o)\n            if (hasOwn(o, k))\n                return false;\n        return true;\n    }\n    var circularRefs = null;\n    function deepClone(any) {\n        circularRefs = new WeakMap();\n        var rv = innerDeepClone(any);\n        circularRefs = null;\n        return rv;\n    }\n    function innerDeepClone(x) {\n        if (!x || typeof x !== 'object')\n            return x;\n        var rv = circularRefs.get(x);\n        if (rv)\n            return rv;\n        if (isArray(x)) {\n            rv = [];\n            circularRefs.set(x, rv);\n            for (var i = 0, l = x.length; i < l; ++i) {\n                rv.push(innerDeepClone(x[i]));\n            }\n        }\n        else if (intrinsicTypes.has(x.constructor)) {\n            rv = x;\n        }\n        else {\n            var proto = getProto(x);\n            rv = proto === Object.prototype ? {} : Object.create(proto);\n            circularRefs.set(x, rv);\n            for (var prop in x) {\n                if (hasOwn(x, prop)) {\n                    rv[prop] = innerDeepClone(x[prop]);\n                }\n            }\n        }\n        return rv;\n    }\n    var toString = {}.toString;\n    function toStringTag(o) {\n        return toString.call(o).slice(8, -1);\n    }\n    var iteratorSymbol = typeof Symbol !== 'undefined' ?\n        Symbol.iterator :\n        '@@iterator';\n    var getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n        var i;\n        return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n    } : function () { return null; };\n    function delArrayItem(a, x) {\n        var i = a.indexOf(x);\n        if (i >= 0)\n            a.splice(i, 1);\n        return i >= 0;\n    }\n    var NO_CHAR_ARRAY = {};\n    function getArrayOf(arrayLike) {\n        var i, a, x, it;\n        if (arguments.length === 1) {\n            if (isArray(arrayLike))\n                return arrayLike.slice();\n            if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')\n                return [arrayLike];\n            if ((it = getIteratorOf(arrayLike))) {\n                a = [];\n                while ((x = it.next()), !x.done)\n                    a.push(x.value);\n                return a;\n            }\n            if (arrayLike == null)\n                return [arrayLike];\n            i = arrayLike.length;\n            if (typeof i === 'number') {\n                a = new Array(i);\n                while (i--)\n                    a[i] = arrayLike[i];\n                return a;\n            }\n            return [arrayLike];\n        }\n        i = arguments.length;\n        a = new Array(i);\n        while (i--)\n            a[i] = arguments[i];\n        return a;\n    }\n    var isAsyncFunction = typeof Symbol !== 'undefined'\n        ? function (fn) { return fn[Symbol.toStringTag] === 'AsyncFunction'; }\n        : function () { return false; };\n\n    var dexieErrorNames = [\n        'Modify',\n        'Bulk',\n        'OpenFailed',\n        'VersionChange',\n        'Schema',\n        'Upgrade',\n        'InvalidTable',\n        'MissingAPI',\n        'NoSuchDatabase',\n        'InvalidArgument',\n        'SubTransaction',\n        'Unsupported',\n        'Internal',\n        'DatabaseClosed',\n        'PrematureCommit',\n        'ForeignAwait'\n    ];\n    var idbDomErrorNames = [\n        'Unknown',\n        'Constraint',\n        'Data',\n        'TransactionInactive',\n        'ReadOnly',\n        'Version',\n        'NotFound',\n        'InvalidState',\n        'InvalidAccess',\n        'Abort',\n        'Timeout',\n        'QuotaExceeded',\n        'Syntax',\n        'DataClone'\n    ];\n    var errorList = dexieErrorNames.concat(idbDomErrorNames);\n    var defaultTexts = {\n        VersionChanged: \"Database version changed by other database connection\",\n        DatabaseClosed: \"Database has been closed\",\n        Abort: \"Transaction aborted\",\n        TransactionInactive: \"Transaction has already completed or failed\",\n        MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n    };\n    function DexieError(name, msg) {\n        this.name = name;\n        this.message = msg;\n    }\n    derive(DexieError).from(Error).extend({\n        toString: function () { return this.name + \": \" + this.message; }\n    });\n    function getMultiErrorMessage(msg, failures) {\n        return msg + \". Errors: \" + Object.keys(failures)\n            .map(function (key) { return failures[key].toString(); })\n            .filter(function (v, i, s) { return s.indexOf(v) === i; })\n            .join('\\n');\n    }\n    function ModifyError(msg, failures, successCount, failedKeys) {\n        this.failures = failures;\n        this.failedKeys = failedKeys;\n        this.successCount = successCount;\n        this.message = getMultiErrorMessage(msg, failures);\n    }\n    derive(ModifyError).from(DexieError);\n    function BulkError(msg, failures) {\n        this.name = \"BulkError\";\n        this.failures = Object.keys(failures).map(function (pos) { return failures[pos]; });\n        this.failuresByPos = failures;\n        this.message = getMultiErrorMessage(msg, this.failures);\n    }\n    derive(BulkError).from(DexieError);\n    var errnames = errorList.reduce(function (obj, name) { return (obj[name] = name + \"Error\", obj); }, {});\n    var BaseException = DexieError;\n    var exceptions = errorList.reduce(function (obj, name) {\n        var fullName = name + \"Error\";\n        function DexieError(msgOrInner, inner) {\n            this.name = fullName;\n            if (!msgOrInner) {\n                this.message = defaultTexts[name] || fullName;\n                this.inner = null;\n            }\n            else if (typeof msgOrInner === 'string') {\n                this.message = \"\".concat(msgOrInner).concat(!inner ? '' : '\\n ' + inner);\n                this.inner = inner || null;\n            }\n            else if (typeof msgOrInner === 'object') {\n                this.message = \"\".concat(msgOrInner.name, \" \").concat(msgOrInner.message);\n                this.inner = msgOrInner;\n            }\n        }\n        derive(DexieError).from(BaseException);\n        obj[name] = DexieError;\n        return obj;\n    }, {});\n    exceptions.Syntax = SyntaxError;\n    exceptions.Type = TypeError;\n    exceptions.Range = RangeError;\n    var exceptionMap = idbDomErrorNames.reduce(function (obj, name) {\n        obj[name + \"Error\"] = exceptions[name];\n        return obj;\n    }, {});\n    function mapError(domError, message) {\n        if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])\n            return domError;\n        var rv = new exceptionMap[domError.name](message || domError.message, domError);\n        if (\"stack\" in domError) {\n            setProp(rv, \"stack\", { get: function () {\n                    return this.inner.stack;\n                } });\n        }\n        return rv;\n    }\n    var fullNameExceptions = errorList.reduce(function (obj, name) {\n        if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1)\n            obj[name + \"Error\"] = exceptions[name];\n        return obj;\n    }, {});\n    fullNameExceptions.ModifyError = ModifyError;\n    fullNameExceptions.DexieError = DexieError;\n    fullNameExceptions.BulkError = BulkError;\n\n    function nop() { }\n    function mirror(val) { return val; }\n    function pureFunctionChain(f1, f2) {\n        if (f1 == null || f1 === mirror)\n            return f2;\n        return function (val) {\n            return f2(f1(val));\n        };\n    }\n    function callBoth(on1, on2) {\n        return function () {\n            on1.apply(this, arguments);\n            on2.apply(this, arguments);\n        };\n    }\n    function hookCreatingChain(f1, f2) {\n        if (f1 === nop)\n            return f2;\n        return function () {\n            var res = f1.apply(this, arguments);\n            if (res !== undefined)\n                arguments[0] = res;\n            var onsuccess = this.onsuccess,\n            onerror = this.onerror;\n            this.onsuccess = null;\n            this.onerror = null;\n            var res2 = f2.apply(this, arguments);\n            if (onsuccess)\n                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n            if (onerror)\n                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n            return res2 !== undefined ? res2 : res;\n        };\n    }\n    function hookDeletingChain(f1, f2) {\n        if (f1 === nop)\n            return f2;\n        return function () {\n            f1.apply(this, arguments);\n            var onsuccess = this.onsuccess,\n            onerror = this.onerror;\n            this.onsuccess = this.onerror = null;\n            f2.apply(this, arguments);\n            if (onsuccess)\n                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n            if (onerror)\n                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        };\n    }\n    function hookUpdatingChain(f1, f2) {\n        if (f1 === nop)\n            return f2;\n        return function (modifications) {\n            var res = f1.apply(this, arguments);\n            extend(modifications, res);\n            var onsuccess = this.onsuccess,\n            onerror = this.onerror;\n            this.onsuccess = null;\n            this.onerror = null;\n            var res2 = f2.apply(this, arguments);\n            if (onsuccess)\n                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n            if (onerror)\n                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n            return res === undefined ?\n                (res2 === undefined ? undefined : res2) :\n                (extend(res, res2));\n        };\n    }\n    function reverseStoppableEventChain(f1, f2) {\n        if (f1 === nop)\n            return f2;\n        return function () {\n            if (f2.apply(this, arguments) === false)\n                return false;\n            return f1.apply(this, arguments);\n        };\n    }\n    function promisableChain(f1, f2) {\n        if (f1 === nop)\n            return f2;\n        return function () {\n            var res = f1.apply(this, arguments);\n            if (res && typeof res.then === 'function') {\n                var thiz = this, i = arguments.length, args = new Array(i);\n                while (i--)\n                    args[i] = arguments[i];\n                return res.then(function () {\n                    return f2.apply(thiz, args);\n                });\n            }\n            return f2.apply(this, arguments);\n        };\n    }\n\n    var debug = typeof location !== 'undefined' &&\n        /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\n    function setDebug(value, filter) {\n        debug = value;\n    }\n\n    var INTERNAL = {};\n    var ZONE_ECHO_LIMIT = 100, _a$1 = typeof Promise === 'undefined' ?\n        [] :\n        (function () {\n            var globalP = Promise.resolve();\n            if (typeof crypto === 'undefined' || !crypto.subtle)\n                return [globalP, getProto(globalP), globalP];\n            var nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n            return [\n                nativeP,\n                getProto(nativeP),\n                globalP\n            ];\n        })(), resolvedNativePromise = _a$1[0], nativePromiseProto = _a$1[1], resolvedGlobalPromise = _a$1[2], nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\n    var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\n    var patchGlobalPromise = !!resolvedGlobalPromise;\n    function schedulePhysicalTick() {\n        queueMicrotask(physicalTick);\n    }\n    var asap = function (callback, args) {\n        microtickQueue.push([callback, args]);\n        if (needsNewPhysicalTick) {\n            schedulePhysicalTick();\n            needsNewPhysicalTick = false;\n        }\n    };\n    var isOutsideMicroTick = true,\n    needsNewPhysicalTick = true,\n    unhandledErrors = [],\n    rejectingErrors = [],\n    rejectionMapper = mirror;\n    var globalPSD = {\n        id: 'global',\n        global: true,\n        ref: 0,\n        unhandleds: [],\n        onunhandled: nop,\n        pgp: false,\n        env: {},\n        finalize: nop\n    };\n    var PSD = globalPSD;\n    var microtickQueue = [];\n    var numScheduledCalls = 0;\n    var tickFinalizers = [];\n    function DexiePromise(fn) {\n        if (typeof this !== 'object')\n            throw new TypeError('Promises must be constructed via new');\n        this._listeners = [];\n        this._lib = false;\n        var psd = (this._PSD = PSD);\n        if (typeof fn !== 'function') {\n            if (fn !== INTERNAL)\n                throw new TypeError('Not a function');\n            this._state = arguments[1];\n            this._value = arguments[2];\n            if (this._state === false)\n                handleRejection(this, this._value);\n            return;\n        }\n        this._state = null;\n        this._value = null;\n        ++psd.ref;\n        executePromiseTask(this, fn);\n    }\n    var thenProp = {\n        get: function () {\n            var psd = PSD, microTaskId = totalEchoes;\n            function then(onFulfilled, onRejected) {\n                var _this = this;\n                var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n                var cleanup = possibleAwait && !decrementExpectedAwaits();\n                var rv = new DexiePromise(function (resolve, reject) {\n                    propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n                });\n                if (this._consoleTask)\n                    rv._consoleTask = this._consoleTask;\n                return rv;\n            }\n            then.prototype = INTERNAL;\n            return then;\n        },\n        set: function (value) {\n            setProp(this, 'then', value && value.prototype === INTERNAL ?\n                thenProp :\n                {\n                    get: function () {\n                        return value;\n                    },\n                    set: thenProp.set\n                });\n        }\n    };\n    props(DexiePromise.prototype, {\n        then: thenProp,\n        _then: function (onFulfilled, onRejected) {\n            propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n        },\n        catch: function (onRejected) {\n            if (arguments.length === 1)\n                return this.then(null, onRejected);\n            var type = arguments[0], handler = arguments[1];\n            return typeof type === 'function' ? this.then(null, function (err) {\n                return err instanceof type ? handler(err) : PromiseReject(err);\n            })\n                : this.then(null, function (err) {\n                    return err && err.name === type ? handler(err) : PromiseReject(err);\n                });\n        },\n        finally: function (onFinally) {\n            return this.then(function (value) {\n                return DexiePromise.resolve(onFinally()).then(function () { return value; });\n            }, function (err) {\n                return DexiePromise.resolve(onFinally()).then(function () { return PromiseReject(err); });\n            });\n        },\n        timeout: function (ms, msg) {\n            var _this = this;\n            return ms < Infinity ?\n                new DexiePromise(function (resolve, reject) {\n                    var handle = setTimeout(function () { return reject(new exceptions.Timeout(msg)); }, ms);\n                    _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n                }) : this;\n        }\n    });\n    if (typeof Symbol !== 'undefined' && Symbol.toStringTag)\n        setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\n    globalPSD.env = snapShot();\n    function Listener(onFulfilled, onRejected, resolve, reject, zone) {\n        this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n        this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n        this.resolve = resolve;\n        this.reject = reject;\n        this.psd = zone;\n    }\n    props(DexiePromise, {\n        all: function () {\n            var values = getArrayOf.apply(null, arguments)\n                .map(onPossibleParallellAsync);\n            return new DexiePromise(function (resolve, reject) {\n                if (values.length === 0)\n                    resolve([]);\n                var remaining = values.length;\n                values.forEach(function (a, i) { return DexiePromise.resolve(a).then(function (x) {\n                    values[i] = x;\n                    if (!--remaining)\n                        resolve(values);\n                }, reject); });\n            });\n        },\n        resolve: function (value) {\n            if (value instanceof DexiePromise)\n                return value;\n            if (value && typeof value.then === 'function')\n                return new DexiePromise(function (resolve, reject) {\n                    value.then(resolve, reject);\n                });\n            var rv = new DexiePromise(INTERNAL, true, value);\n            return rv;\n        },\n        reject: PromiseReject,\n        race: function () {\n            var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise(function (resolve, reject) {\n                values.map(function (value) { return DexiePromise.resolve(value).then(resolve, reject); });\n            });\n        },\n        PSD: {\n            get: function () { return PSD; },\n            set: function (value) { return PSD = value; }\n        },\n        totalEchoes: { get: function () { return totalEchoes; } },\n        newPSD: newScope,\n        usePSD: usePSD,\n        scheduler: {\n            get: function () { return asap; },\n            set: function (value) { asap = value; }\n        },\n        rejectionMapper: {\n            get: function () { return rejectionMapper; },\n            set: function (value) { rejectionMapper = value; }\n        },\n        follow: function (fn, zoneProps) {\n            return new DexiePromise(function (resolve, reject) {\n                return newScope(function (resolve, reject) {\n                    var psd = PSD;\n                    psd.unhandleds = [];\n                    psd.onunhandled = reject;\n                    psd.finalize = callBoth(function () {\n                        var _this = this;\n                        run_at_end_of_this_or_next_physical_tick(function () {\n                            _this.unhandleds.length === 0 ? resolve() : reject(_this.unhandleds[0]);\n                        });\n                    }, psd.finalize);\n                    fn();\n                }, zoneProps, resolve, reject);\n            });\n        }\n    });\n    if (NativePromise) {\n        if (NativePromise.allSettled)\n            setProp(DexiePromise, \"allSettled\", function () {\n                var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n                return new DexiePromise(function (resolve) {\n                    if (possiblePromises.length === 0)\n                        resolve([]);\n                    var remaining = possiblePromises.length;\n                    var results = new Array(remaining);\n                    possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return results[i] = { status: \"fulfilled\", value: value }; }, function (reason) { return results[i] = { status: \"rejected\", reason: reason }; })\n                        .then(function () { return --remaining || resolve(results); }); });\n                });\n            });\n        if (NativePromise.any && typeof AggregateError !== 'undefined')\n            setProp(DexiePromise, \"any\", function () {\n                var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n                return new DexiePromise(function (resolve, reject) {\n                    if (possiblePromises.length === 0)\n                        reject(new AggregateError([]));\n                    var remaining = possiblePromises.length;\n                    var failures = new Array(remaining);\n                    possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return resolve(value); }, function (failure) {\n                        failures[i] = failure;\n                        if (!--remaining)\n                            reject(new AggregateError(failures));\n                    }); });\n                });\n            });\n    }\n    function executePromiseTask(promise, fn) {\n        try {\n            fn(function (value) {\n                if (promise._state !== null)\n                    return;\n                if (value === promise)\n                    throw new TypeError('A promise cannot be resolved with itself.');\n                var shouldExecuteTick = promise._lib && beginMicroTickScope();\n                if (value && typeof value.then === 'function') {\n                    executePromiseTask(promise, function (resolve, reject) {\n                        value instanceof DexiePromise ?\n                            value._then(resolve, reject) :\n                            value.then(resolve, reject);\n                    });\n                }\n                else {\n                    promise._state = true;\n                    promise._value = value;\n                    propagateAllListeners(promise);\n                }\n                if (shouldExecuteTick)\n                    endMicroTickScope();\n            }, handleRejection.bind(null, promise));\n        }\n        catch (ex) {\n            handleRejection(promise, ex);\n        }\n    }\n    function handleRejection(promise, reason) {\n        rejectingErrors.push(reason);\n        if (promise._state !== null)\n            return;\n        var shouldExecuteTick = promise._lib && beginMicroTickScope();\n        reason = rejectionMapper(reason);\n        promise._state = false;\n        promise._value = reason;\n        addPossiblyUnhandledError(promise);\n        propagateAllListeners(promise);\n        if (shouldExecuteTick)\n            endMicroTickScope();\n    }\n    function propagateAllListeners(promise) {\n        var listeners = promise._listeners;\n        promise._listeners = [];\n        for (var i = 0, len = listeners.length; i < len; ++i) {\n            propagateToListener(promise, listeners[i]);\n        }\n        var psd = promise._PSD;\n        --psd.ref || psd.finalize();\n        if (numScheduledCalls === 0) {\n            ++numScheduledCalls;\n            asap(function () {\n                if (--numScheduledCalls === 0)\n                    finalizePhysicalTick();\n            }, []);\n        }\n    }\n    function propagateToListener(promise, listener) {\n        if (promise._state === null) {\n            promise._listeners.push(listener);\n            return;\n        }\n        var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n        if (cb === null) {\n            return (promise._state ? listener.resolve : listener.reject)(promise._value);\n        }\n        ++listener.psd.ref;\n        ++numScheduledCalls;\n        asap(callListener, [cb, promise, listener]);\n    }\n    function callListener(cb, promise, listener) {\n        try {\n            var ret, value = promise._value;\n            if (!promise._state && rejectingErrors.length)\n                rejectingErrors = [];\n            ret = debug && promise._consoleTask ? promise._consoleTask.run(function () { return cb(value); }) : cb(value);\n            if (!promise._state && rejectingErrors.indexOf(value) === -1) {\n                markErrorAsHandled(promise);\n            }\n            listener.resolve(ret);\n        }\n        catch (e) {\n            listener.reject(e);\n        }\n        finally {\n            if (--numScheduledCalls === 0)\n                finalizePhysicalTick();\n            --listener.psd.ref || listener.psd.finalize();\n        }\n    }\n    function physicalTick() {\n        usePSD(globalPSD, function () {\n            beginMicroTickScope() && endMicroTickScope();\n        });\n    }\n    function beginMicroTickScope() {\n        var wasRootExec = isOutsideMicroTick;\n        isOutsideMicroTick = false;\n        needsNewPhysicalTick = false;\n        return wasRootExec;\n    }\n    function endMicroTickScope() {\n        var callbacks, i, l;\n        do {\n            while (microtickQueue.length > 0) {\n                callbacks = microtickQueue;\n                microtickQueue = [];\n                l = callbacks.length;\n                for (i = 0; i < l; ++i) {\n                    var item = callbacks[i];\n                    item[0].apply(null, item[1]);\n                }\n            }\n        } while (microtickQueue.length > 0);\n        isOutsideMicroTick = true;\n        needsNewPhysicalTick = true;\n    }\n    function finalizePhysicalTick() {\n        var unhandledErrs = unhandledErrors;\n        unhandledErrors = [];\n        unhandledErrs.forEach(function (p) {\n            p._PSD.onunhandled.call(null, p._value, p);\n        });\n        var finalizers = tickFinalizers.slice(0);\n        var i = finalizers.length;\n        while (i)\n            finalizers[--i]();\n    }\n    function run_at_end_of_this_or_next_physical_tick(fn) {\n        function finalizer() {\n            fn();\n            tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n        }\n        tickFinalizers.push(finalizer);\n        ++numScheduledCalls;\n        asap(function () {\n            if (--numScheduledCalls === 0)\n                finalizePhysicalTick();\n        }, []);\n    }\n    function addPossiblyUnhandledError(promise) {\n        if (!unhandledErrors.some(function (p) { return p._value === promise._value; }))\n            unhandledErrors.push(promise);\n    }\n    function markErrorAsHandled(promise) {\n        var i = unhandledErrors.length;\n        while (i)\n            if (unhandledErrors[--i]._value === promise._value) {\n                unhandledErrors.splice(i, 1);\n                return;\n            }\n    }\n    function PromiseReject(reason) {\n        return new DexiePromise(INTERNAL, false, reason);\n    }\n    function wrap(fn, errorCatcher) {\n        var psd = PSD;\n        return function () {\n            var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n            try {\n                switchToZone(psd, true);\n                return fn.apply(this, arguments);\n            }\n            catch (e) {\n                errorCatcher && errorCatcher(e);\n            }\n            finally {\n                switchToZone(outerScope, false);\n                if (wasRootExec)\n                    endMicroTickScope();\n            }\n        };\n    }\n    var task = { awaits: 0, echoes: 0, id: 0 };\n    var taskCounter = 0;\n    var zoneStack = [];\n    var zoneEchoes = 0;\n    var totalEchoes = 0;\n    var zone_id_counter = 0;\n    function newScope(fn, props, a1, a2) {\n        var parent = PSD, psd = Object.create(parent);\n        psd.parent = parent;\n        psd.ref = 0;\n        psd.global = false;\n        psd.id = ++zone_id_counter;\n        globalPSD.env;\n        psd.env = patchGlobalPromise ? {\n            Promise: DexiePromise,\n            PromiseProp: { value: DexiePromise, configurable: true, writable: true },\n            all: DexiePromise.all,\n            race: DexiePromise.race,\n            allSettled: DexiePromise.allSettled,\n            any: DexiePromise.any,\n            resolve: DexiePromise.resolve,\n            reject: DexiePromise.reject,\n        } : {};\n        if (props)\n            extend(psd, props);\n        ++parent.ref;\n        psd.finalize = function () {\n            --this.parent.ref || this.parent.finalize();\n        };\n        var rv = usePSD(psd, fn, a1, a2);\n        if (psd.ref === 0)\n            psd.finalize();\n        return rv;\n    }\n    function incrementExpectedAwaits() {\n        if (!task.id)\n            task.id = ++taskCounter;\n        ++task.awaits;\n        task.echoes += ZONE_ECHO_LIMIT;\n        return task.id;\n    }\n    function decrementExpectedAwaits() {\n        if (!task.awaits)\n            return false;\n        if (--task.awaits === 0)\n            task.id = 0;\n        task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n        return true;\n    }\n    if (('' + nativePromiseThen).indexOf('[native code]') === -1) {\n        incrementExpectedAwaits = decrementExpectedAwaits = nop;\n    }\n    function onPossibleParallellAsync(possiblePromise) {\n        if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n            incrementExpectedAwaits();\n            return possiblePromise.then(function (x) {\n                decrementExpectedAwaits();\n                return x;\n            }, function (e) {\n                decrementExpectedAwaits();\n                return rejection(e);\n            });\n        }\n        return possiblePromise;\n    }\n    function zoneEnterEcho(targetZone) {\n        ++totalEchoes;\n        if (!task.echoes || --task.echoes === 0) {\n            task.echoes = task.awaits = task.id = 0;\n        }\n        zoneStack.push(PSD);\n        switchToZone(targetZone, true);\n    }\n    function zoneLeaveEcho() {\n        var zone = zoneStack[zoneStack.length - 1];\n        zoneStack.pop();\n        switchToZone(zone, false);\n    }\n    function switchToZone(targetZone, bEnteringZone) {\n        var currentZone = PSD;\n        if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n            queueMicrotask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n        }\n        if (targetZone === PSD)\n            return;\n        PSD = targetZone;\n        if (currentZone === globalPSD)\n            globalPSD.env = snapShot();\n        if (patchGlobalPromise) {\n            var GlobalPromise = globalPSD.env.Promise;\n            var targetEnv = targetZone.env;\n            if (currentZone.global || targetZone.global) {\n                Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n                GlobalPromise.all = targetEnv.all;\n                GlobalPromise.race = targetEnv.race;\n                GlobalPromise.resolve = targetEnv.resolve;\n                GlobalPromise.reject = targetEnv.reject;\n                if (targetEnv.allSettled)\n                    GlobalPromise.allSettled = targetEnv.allSettled;\n                if (targetEnv.any)\n                    GlobalPromise.any = targetEnv.any;\n            }\n        }\n    }\n    function snapShot() {\n        var GlobalPromise = _global.Promise;\n        return patchGlobalPromise ? {\n            Promise: GlobalPromise,\n            PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n            all: GlobalPromise.all,\n            race: GlobalPromise.race,\n            allSettled: GlobalPromise.allSettled,\n            any: GlobalPromise.any,\n            resolve: GlobalPromise.resolve,\n            reject: GlobalPromise.reject,\n        } : {};\n    }\n    function usePSD(psd, fn, a1, a2, a3) {\n        var outerScope = PSD;\n        try {\n            switchToZone(psd, true);\n            return fn(a1, a2, a3);\n        }\n        finally {\n            switchToZone(outerScope, false);\n        }\n    }\n    function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n        return typeof fn !== 'function' ? fn : function () {\n            var outerZone = PSD;\n            if (possibleAwait)\n                incrementExpectedAwaits();\n            switchToZone(zone, true);\n            try {\n                return fn.apply(this, arguments);\n            }\n            finally {\n                switchToZone(outerZone, false);\n                if (cleanup)\n                    queueMicrotask(decrementExpectedAwaits);\n            }\n        };\n    }\n    function execInGlobalContext(cb) {\n        if (Promise === NativePromise && task.echoes === 0) {\n            if (zoneEchoes === 0) {\n                cb();\n            }\n            else {\n                enqueueNativeMicroTask(cb);\n            }\n        }\n        else {\n            setTimeout(cb, 0);\n        }\n    }\n    var rejection = DexiePromise.reject;\n\n    function tempTransaction(db, mode, storeNames, fn) {\n        if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {\n            if (db._state.openComplete) {\n                return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n            }\n            if (!db._state.isBeingOpened) {\n                if (!db._state.autoOpen)\n                    return rejection(new exceptions.DatabaseClosed());\n                db.open().catch(nop);\n            }\n            return db._state.dbReadyPromise.then(function () { return tempTransaction(db, mode, storeNames, fn); });\n        }\n        else {\n            var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n            try {\n                trans.create();\n                db._state.PR1398_maxLoop = 3;\n            }\n            catch (ex) {\n                if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                    console.warn('Dexie: Need to reopen db');\n                    db.close({ disableAutoOpen: false });\n                    return db.open().then(function () { return tempTransaction(db, mode, storeNames, fn); });\n                }\n                return rejection(ex);\n            }\n            return trans._promise(mode, function (resolve, reject) {\n                return newScope(function () {\n                    PSD.trans = trans;\n                    return fn(resolve, reject, trans);\n                });\n            }).then(function (result) {\n                if (mode === 'readwrite')\n                    try {\n                        trans.idbtrans.commit();\n                    }\n                    catch (_a) { }\n                return mode === 'readonly' ? result : trans._completion.then(function () { return result; });\n            });\n        }\n    }\n\n    var DEXIE_VERSION = '4.0.7';\n    var maxString = String.fromCharCode(65535);\n    var minKey = -Infinity;\n    var INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\n    var STRING_EXPECTED = \"String expected.\";\n    var connections = [];\n    var DBNAMES_DB = '__dbnames';\n    var READONLY = 'readonly';\n    var READWRITE = 'readwrite';\n\n    function combine(filter1, filter2) {\n        return filter1 ?\n            filter2 ?\n                function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :\n                filter1 :\n            filter2;\n    }\n\n    var AnyRange = {\n        type: 3 ,\n        lower: -Infinity,\n        lowerOpen: false,\n        upper: [[]],\n        upperOpen: false\n    };\n\n    function workaroundForUndefinedPrimKey(keyPath) {\n        return typeof keyPath === \"string\" && !/\\./.test(keyPath)\n            ? function (obj) {\n                if (obj[keyPath] === undefined && (keyPath in obj)) {\n                    obj = deepClone(obj);\n                    delete obj[keyPath];\n                }\n                return obj;\n            }\n            : function (obj) { return obj; };\n    }\n\n    function Entity() {\n        throw exceptions.Type();\n    }\n\n    function cmp(a, b) {\n        try {\n            var ta = type(a);\n            var tb = type(b);\n            if (ta !== tb) {\n                if (ta === 'Array')\n                    return 1;\n                if (tb === 'Array')\n                    return -1;\n                if (ta === 'binary')\n                    return 1;\n                if (tb === 'binary')\n                    return -1;\n                if (ta === 'string')\n                    return 1;\n                if (tb === 'string')\n                    return -1;\n                if (ta === 'Date')\n                    return 1;\n                if (tb !== 'Date')\n                    return NaN;\n                return -1;\n            }\n            switch (ta) {\n                case 'number':\n                case 'Date':\n                case 'string':\n                    return a > b ? 1 : a < b ? -1 : 0;\n                case 'binary': {\n                    return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n                }\n                case 'Array':\n                    return compareArrays(a, b);\n            }\n        }\n        catch (_a) { }\n        return NaN;\n    }\n    function compareArrays(a, b) {\n        var al = a.length;\n        var bl = b.length;\n        var l = al < bl ? al : bl;\n        for (var i = 0; i < l; ++i) {\n            var res = cmp(a[i], b[i]);\n            if (res !== 0)\n                return res;\n        }\n        return al === bl ? 0 : al < bl ? -1 : 1;\n    }\n    function compareUint8Arrays(a, b) {\n        var al = a.length;\n        var bl = b.length;\n        var l = al < bl ? al : bl;\n        for (var i = 0; i < l; ++i) {\n            if (a[i] !== b[i])\n                return a[i] < b[i] ? -1 : 1;\n        }\n        return al === bl ? 0 : al < bl ? -1 : 1;\n    }\n    function type(x) {\n        var t = typeof x;\n        if (t !== 'object')\n            return t;\n        if (ArrayBuffer.isView(x))\n            return 'binary';\n        var tsTag = toStringTag(x);\n        return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;\n    }\n    function getUint8Array(a) {\n        if (a instanceof Uint8Array)\n            return a;\n        if (ArrayBuffer.isView(a))\n            return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n        return new Uint8Array(a);\n    }\n\n    var Table =  (function () {\n        function Table() {\n        }\n        Table.prototype._trans = function (mode, fn, writeLocked) {\n            var trans = this._tx || PSD.trans;\n            var tableName = this.name;\n            var task = debug && typeof console !== 'undefined' && console.createTask && console.createTask(\"Dexie: \".concat(mode === 'readonly' ? 'read' : 'write', \" \").concat(this.name));\n            function checkTableInTransaction(resolve, reject, trans) {\n                if (!trans.schema[tableName])\n                    throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n                return fn(trans.idbtrans, trans);\n            }\n            var wasRootExec = beginMicroTickScope();\n            try {\n                var p = trans && trans.db._novip === this.db._novip ?\n                    trans === PSD.trans ?\n                        trans._promise(mode, checkTableInTransaction, writeLocked) :\n                        newScope(function () { return trans._promise(mode, checkTableInTransaction, writeLocked); }, { trans: trans, transless: PSD.transless || PSD }) :\n                    tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n                if (task) {\n                    p._consoleTask = task;\n                    p = p.catch(function (err) {\n                        console.trace(err);\n                        return rejection(err);\n                    });\n                }\n                return p;\n            }\n            finally {\n                if (wasRootExec)\n                    endMicroTickScope();\n            }\n        };\n        Table.prototype.get = function (keyOrCrit, cb) {\n            var _this = this;\n            if (keyOrCrit && keyOrCrit.constructor === Object)\n                return this.where(keyOrCrit).first(cb);\n            if (keyOrCrit == null)\n                return rejection(new exceptions.Type(\"Invalid argument to Table.get()\"));\n            return this._trans('readonly', function (trans) {\n                return _this.core.get({ trans: trans, key: keyOrCrit })\n                    .then(function (res) { return _this.hook.reading.fire(res); });\n            }).then(cb);\n        };\n        Table.prototype.where = function (indexOrCrit) {\n            if (typeof indexOrCrit === 'string')\n                return new this.db.WhereClause(this, indexOrCrit);\n            if (isArray(indexOrCrit))\n                return new this.db.WhereClause(this, \"[\".concat(indexOrCrit.join('+'), \"]\"));\n            var keyPaths = keys(indexOrCrit);\n            if (keyPaths.length === 1)\n                return this\n                    .where(keyPaths[0])\n                    .equals(indexOrCrit[keyPaths[0]]);\n            var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function (ix) {\n                if (ix.compound &&\n                    keyPaths.every(function (keyPath) { return ix.keyPath.indexOf(keyPath) >= 0; })) {\n                    for (var i = 0; i < keyPaths.length; ++i) {\n                        if (keyPaths.indexOf(ix.keyPath[i]) === -1)\n                            return false;\n                    }\n                    return true;\n                }\n                return false;\n            }).sort(function (a, b) { return a.keyPath.length - b.keyPath.length; })[0];\n            if (compoundIndex && this.db._maxKey !== maxString) {\n                var keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);\n                return this\n                    .where(keyPathsInValidOrder)\n                    .equals(keyPathsInValidOrder.map(function (kp) { return indexOrCrit[kp]; }));\n            }\n            if (!compoundIndex && debug)\n                console.warn(\"The query \".concat(JSON.stringify(indexOrCrit), \" on \").concat(this.name, \" would benefit from a \") +\n                    \"compound index [\".concat(keyPaths.join('+'), \"]\"));\n            var idxByName = this.schema.idxByName;\n            var idb = this.db._deps.indexedDB;\n            function equals(a, b) {\n                return idb.cmp(a, b) === 0;\n            }\n            var _a = keyPaths.reduce(function (_a, keyPath) {\n                var prevIndex = _a[0], prevFilterFn = _a[1];\n                var index = idxByName[keyPath];\n                var value = indexOrCrit[keyPath];\n                return [\n                    prevIndex || index,\n                    prevIndex || !index ?\n                        combine(prevFilterFn, index && index.multi ?\n                            function (x) {\n                                var prop = getByKeyPath(x, keyPath);\n                                return isArray(prop) && prop.some(function (item) { return equals(value, item); });\n                            } : function (x) { return equals(value, getByKeyPath(x, keyPath)); })\n                        : prevFilterFn\n                ];\n            }, [null, null]), idx = _a[0], filterFunction = _a[1];\n            return idx ?\n                this.where(idx.name).equals(indexOrCrit[idx.keyPath])\n                    .filter(filterFunction) :\n                compoundIndex ?\n                    this.filter(filterFunction) :\n                    this.where(keyPaths).equals('');\n        };\n        Table.prototype.filter = function (filterFunction) {\n            return this.toCollection().and(filterFunction);\n        };\n        Table.prototype.count = function (thenShortcut) {\n            return this.toCollection().count(thenShortcut);\n        };\n        Table.prototype.offset = function (offset) {\n            return this.toCollection().offset(offset);\n        };\n        Table.prototype.limit = function (numRows) {\n            return this.toCollection().limit(numRows);\n        };\n        Table.prototype.each = function (callback) {\n            return this.toCollection().each(callback);\n        };\n        Table.prototype.toArray = function (thenShortcut) {\n            return this.toCollection().toArray(thenShortcut);\n        };\n        Table.prototype.toCollection = function () {\n            return new this.db.Collection(new this.db.WhereClause(this));\n        };\n        Table.prototype.orderBy = function (index) {\n            return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?\n                \"[\".concat(index.join('+'), \"]\") :\n                index));\n        };\n        Table.prototype.reverse = function () {\n            return this.toCollection().reverse();\n        };\n        Table.prototype.mapToClass = function (constructor) {\n            var _a = this, db = _a.db, tableName = _a.name;\n            this.schema.mappedClass = constructor;\n            if (constructor.prototype instanceof Entity) {\n                constructor =  (function (_super) {\n                    __extends(class_1, _super);\n                    function class_1() {\n                        return _super !== null && _super.apply(this, arguments) || this;\n                    }\n                    Object.defineProperty(class_1.prototype, \"db\", {\n                        get: function () { return db; },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    class_1.prototype.table = function () { return tableName; };\n                    return class_1;\n                }(constructor));\n            }\n            var inheritedProps = new Set();\n            for (var proto = constructor.prototype; proto; proto = getProto(proto)) {\n                Object.getOwnPropertyNames(proto).forEach(function (propName) { return inheritedProps.add(propName); });\n            }\n            var readHook = function (obj) {\n                if (!obj)\n                    return obj;\n                var res = Object.create(constructor.prototype);\n                for (var m in obj)\n                    if (!inheritedProps.has(m))\n                        try {\n                            res[m] = obj[m];\n                        }\n                        catch (_) { }\n                return res;\n            };\n            if (this.schema.readHook) {\n                this.hook.reading.unsubscribe(this.schema.readHook);\n            }\n            this.schema.readHook = readHook;\n            this.hook(\"reading\", readHook);\n            return constructor;\n        };\n        Table.prototype.defineClass = function () {\n            function Class(content) {\n                extend(this, content);\n            }\n            return this.mapToClass(Class);\n        };\n        Table.prototype.add = function (obj, key) {\n            var _this = this;\n            var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n            var objToAdd = obj;\n            if (keyPath && auto) {\n                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n            }\n            return this._trans('readwrite', function (trans) {\n                return _this.core.mutate({ trans: trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });\n            }).then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })\n                .then(function (lastResult) {\n                if (keyPath) {\n                    try {\n                        setByKeyPath(obj, keyPath, lastResult);\n                    }\n                    catch (_) { }\n                }\n                return lastResult;\n            });\n        };\n        Table.prototype.update = function (keyOrObject, modifications) {\n            if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n                var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n                if (key === undefined)\n                    return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n                return this.where(\":id\").equals(key).modify(modifications);\n            }\n            else {\n                return this.where(\":id\").equals(keyOrObject).modify(modifications);\n            }\n        };\n        Table.prototype.put = function (obj, key) {\n            var _this = this;\n            var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n            var objToAdd = obj;\n            if (keyPath && auto) {\n                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n            }\n            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }); })\n                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })\n                .then(function (lastResult) {\n                if (keyPath) {\n                    try {\n                        setByKeyPath(obj, keyPath, lastResult);\n                    }\n                    catch (_) { }\n                }\n                return lastResult;\n            });\n        };\n        Table.prototype.delete = function (key) {\n            var _this = this;\n            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'delete', keys: [key] }); })\n                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });\n        };\n        Table.prototype.clear = function () {\n            var _this = this;\n            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'deleteRange', range: AnyRange }); })\n                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });\n        };\n        Table.prototype.bulkGet = function (keys) {\n            var _this = this;\n            return this._trans('readonly', function (trans) {\n                return _this.core.getMany({\n                    keys: keys,\n                    trans: trans\n                }).then(function (result) { return result.map(function (res) { return _this.hook.reading.fire(res); }); });\n            });\n        };\n        Table.prototype.bulkAdd = function (objects, keysOrOptions, options) {\n            var _this = this;\n            var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n            options = options || (keys ? undefined : keysOrOptions);\n            var wantResults = options ? options.allKeys : undefined;\n            return this._trans('readwrite', function (trans) {\n                var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n                if (keyPath && keys)\n                    throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n                if (keys && keys.length !== objects.length)\n                    throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n                var numObjects = objects.length;\n                var objectsToAdd = keyPath && auto ?\n                    objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                    objects;\n                return _this.core.mutate({ trans: trans, type: 'add', keys: keys, values: objectsToAdd, wantResults: wantResults })\n                    .then(function (_a) {\n                    var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;\n                    var result = wantResults ? results : lastResult;\n                    if (numFailures === 0)\n                        return result;\n                    throw new BulkError(\"\".concat(_this.name, \".bulkAdd(): \").concat(numFailures, \" of \").concat(numObjects, \" operations failed\"), failures);\n                });\n            });\n        };\n        Table.prototype.bulkPut = function (objects, keysOrOptions, options) {\n            var _this = this;\n            var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n            options = options || (keys ? undefined : keysOrOptions);\n            var wantResults = options ? options.allKeys : undefined;\n            return this._trans('readwrite', function (trans) {\n                var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n                if (keyPath && keys)\n                    throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n                if (keys && keys.length !== objects.length)\n                    throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n                var numObjects = objects.length;\n                var objectsToPut = keyPath && auto ?\n                    objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                    objects;\n                return _this.core.mutate({ trans: trans, type: 'put', keys: keys, values: objectsToPut, wantResults: wantResults })\n                    .then(function (_a) {\n                    var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;\n                    var result = wantResults ? results : lastResult;\n                    if (numFailures === 0)\n                        return result;\n                    throw new BulkError(\"\".concat(_this.name, \".bulkPut(): \").concat(numFailures, \" of \").concat(numObjects, \" operations failed\"), failures);\n                });\n            });\n        };\n        Table.prototype.bulkUpdate = function (keysAndChanges) {\n            var _this = this;\n            var coreTable = this.core;\n            var keys = keysAndChanges.map(function (entry) { return entry.key; });\n            var changeSpecs = keysAndChanges.map(function (entry) { return entry.changes; });\n            var offsetMap = [];\n            return this._trans('readwrite', function (trans) {\n                return coreTable.getMany({ trans: trans, keys: keys, cache: 'clone' }).then(function (objs) {\n                    var resultKeys = [];\n                    var resultObjs = [];\n                    keysAndChanges.forEach(function (_a, idx) {\n                        var key = _a.key, changes = _a.changes;\n                        var obj = objs[idx];\n                        if (obj) {\n                            for (var _i = 0, _b = Object.keys(changes); _i < _b.length; _i++) {\n                                var keyPath = _b[_i];\n                                var value = changes[keyPath];\n                                if (keyPath === _this.schema.primKey.keyPath) {\n                                    if (cmp(value, key) !== 0) {\n                                        throw new exceptions.Constraint(\"Cannot update primary key in bulkUpdate()\");\n                                    }\n                                }\n                                else {\n                                    setByKeyPath(obj, keyPath, value);\n                                }\n                            }\n                            offsetMap.push(idx);\n                            resultKeys.push(key);\n                            resultObjs.push(obj);\n                        }\n                    });\n                    var numEntries = resultKeys.length;\n                    return coreTable\n                        .mutate({\n                        trans: trans,\n                        type: 'put',\n                        keys: resultKeys,\n                        values: resultObjs,\n                        updates: {\n                            keys: keys,\n                            changeSpecs: changeSpecs\n                        }\n                    })\n                        .then(function (_a) {\n                        var numFailures = _a.numFailures, failures = _a.failures;\n                        if (numFailures === 0)\n                            return numEntries;\n                        for (var _i = 0, _b = Object.keys(failures); _i < _b.length; _i++) {\n                            var offset = _b[_i];\n                            var mappedOffset = offsetMap[Number(offset)];\n                            if (mappedOffset != null) {\n                                var failure = failures[offset];\n                                delete failures[offset];\n                                failures[mappedOffset] = failure;\n                            }\n                        }\n                        throw new BulkError(\"\".concat(_this.name, \".bulkUpdate(): \").concat(numFailures, \" of \").concat(numEntries, \" operations failed\"), failures);\n                    });\n                });\n            });\n        };\n        Table.prototype.bulkDelete = function (keys) {\n            var _this = this;\n            var numKeys = keys.length;\n            return this._trans('readwrite', function (trans) {\n                return _this.core.mutate({ trans: trans, type: 'delete', keys: keys });\n            }).then(function (_a) {\n                var numFailures = _a.numFailures, lastResult = _a.lastResult, failures = _a.failures;\n                if (numFailures === 0)\n                    return lastResult;\n                throw new BulkError(\"\".concat(_this.name, \".bulkDelete(): \").concat(numFailures, \" of \").concat(numKeys, \" operations failed\"), failures);\n            });\n        };\n        return Table;\n    }());\n\n    function Events(ctx) {\n        var evs = {};\n        var rv = function (eventName, subscriber) {\n            if (subscriber) {\n                var i = arguments.length, args = new Array(i - 1);\n                while (--i)\n                    args[i - 1] = arguments[i];\n                evs[eventName].subscribe.apply(null, args);\n                return ctx;\n            }\n            else if (typeof (eventName) === 'string') {\n                return evs[eventName];\n            }\n        };\n        rv.addEventType = add;\n        for (var i = 1, l = arguments.length; i < l; ++i) {\n            add(arguments[i]);\n        }\n        return rv;\n        function add(eventName, chainFunction, defaultFunction) {\n            if (typeof eventName === 'object')\n                return addConfiguredEvents(eventName);\n            if (!chainFunction)\n                chainFunction = reverseStoppableEventChain;\n            if (!defaultFunction)\n                defaultFunction = nop;\n            var context = {\n                subscribers: [],\n                fire: defaultFunction,\n                subscribe: function (cb) {\n                    if (context.subscribers.indexOf(cb) === -1) {\n                        context.subscribers.push(cb);\n                        context.fire = chainFunction(context.fire, cb);\n                    }\n                },\n                unsubscribe: function (cb) {\n                    context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });\n                    context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n                }\n            };\n            evs[eventName] = rv[eventName] = context;\n            return context;\n        }\n        function addConfiguredEvents(cfg) {\n            keys(cfg).forEach(function (eventName) {\n                var args = cfg[eventName];\n                if (isArray(args)) {\n                    add(eventName, cfg[eventName][0], cfg[eventName][1]);\n                }\n                else if (args === 'asap') {\n                    var context = add(eventName, mirror, function fire() {\n                        var i = arguments.length, args = new Array(i);\n                        while (i--)\n                            args[i] = arguments[i];\n                        context.subscribers.forEach(function (fn) {\n                            asap$1(function fireEvent() {\n                                fn.apply(null, args);\n                            });\n                        });\n                    });\n                }\n                else\n                    throw new exceptions.InvalidArgument(\"Invalid event config\");\n            });\n        }\n    }\n\n    function makeClassConstructor(prototype, constructor) {\n        derive(constructor).from({ prototype: prototype });\n        return constructor;\n    }\n\n    function createTableConstructor(db) {\n        return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n            this.db = db;\n            this._tx = trans;\n            this.name = name;\n            this.schema = tableSchema;\n            this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n                \"creating\": [hookCreatingChain, nop],\n                \"reading\": [pureFunctionChain, mirror],\n                \"updating\": [hookUpdatingChain, nop],\n                \"deleting\": [hookDeletingChain, nop]\n            });\n        });\n    }\n\n    function isPlainKeyRange(ctx, ignoreLimitFilter) {\n        return !(ctx.filter || ctx.algorithm || ctx.or) &&\n            (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n    }\n    function addFilter(ctx, fn) {\n        ctx.filter = combine(ctx.filter, fn);\n    }\n    function addReplayFilter(ctx, factory, isLimitFilter) {\n        var curr = ctx.replayFilter;\n        ctx.replayFilter = curr ? function () { return combine(curr(), factory()); } : factory;\n        ctx.justLimit = isLimitFilter && !curr;\n    }\n    function addMatchFilter(ctx, fn) {\n        ctx.isMatch = combine(ctx.isMatch, fn);\n    }\n    function getIndexOrStore(ctx, coreSchema) {\n        if (ctx.isPrimKey)\n            return coreSchema.primaryKey;\n        var index = coreSchema.getIndexByKeyPath(ctx.index);\n        if (!index)\n            throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n        return index;\n    }\n    function openCursor(ctx, coreTable, trans) {\n        var index = getIndexOrStore(ctx, coreTable.schema);\n        return coreTable.openCursor({\n            trans: trans,\n            values: !ctx.keysOnly,\n            reverse: ctx.dir === 'prev',\n            unique: !!ctx.unique,\n            query: {\n                index: index,\n                range: ctx.range\n            }\n        });\n    }\n    function iter(ctx, fn, coreTrans, coreTable) {\n        var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n        if (!ctx.or) {\n            return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n        }\n        else {\n            var set_1 = {};\n            var union = function (item, cursor, advance) {\n                if (!filter || filter(cursor, advance, function (result) { return cursor.stop(result); }, function (err) { return cursor.fail(err); })) {\n                    var primaryKey = cursor.primaryKey;\n                    var key = '' + primaryKey;\n                    if (key === '[object ArrayBuffer]')\n                        key = '' + new Uint8Array(primaryKey);\n                    if (!hasOwn(set_1, key)) {\n                        set_1[key] = true;\n                        fn(item, cursor, advance);\n                    }\n                }\n            };\n            return Promise.all([\n                ctx.or._iterate(union, coreTrans),\n                iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n            ]);\n        }\n    }\n    function iterate(cursorPromise, filter, fn, valueMapper) {\n        var mappedFn = valueMapper ? function (x, c, a) { return fn(valueMapper(x), c, a); } : fn;\n        var wrappedFn = wrap(mappedFn);\n        return cursorPromise.then(function (cursor) {\n            if (cursor) {\n                return cursor.start(function () {\n                    var c = function () { return cursor.continue(); };\n                    if (!filter || filter(cursor, function (advancer) { return c = advancer; }, function (val) { cursor.stop(val); c = nop; }, function (e) { cursor.fail(e); c = nop; }))\n                        wrappedFn(cursor.value, cursor, function (advancer) { return c = advancer; });\n                    c();\n                });\n            }\n        });\n    }\n\n    var PropModSymbol = Symbol();\n    var PropModification =  (function () {\n        function PropModification(spec) {\n            Object.assign(this, spec);\n        }\n        PropModification.prototype.execute = function (value) {\n            var _a;\n            if (this.add !== undefined) {\n                var term = this.add;\n                if (isArray(term)) {\n                    return __spreadArray(__spreadArray([], (isArray(value) ? value : []), true), term, true).sort();\n                }\n                if (typeof term === 'number')\n                    return (Number(value) || 0) + term;\n                if (typeof term === 'bigint') {\n                    try {\n                        return BigInt(value) + term;\n                    }\n                    catch (_b) {\n                        return BigInt(0) + term;\n                    }\n                }\n                throw new TypeError(\"Invalid term \".concat(term));\n            }\n            if (this.remove !== undefined) {\n                var subtrahend_1 = this.remove;\n                if (isArray(subtrahend_1)) {\n                    return isArray(value) ? value.filter(function (item) { return !subtrahend_1.includes(item); }).sort() : [];\n                }\n                if (typeof subtrahend_1 === 'number')\n                    return Number(value) - subtrahend_1;\n                if (typeof subtrahend_1 === 'bigint') {\n                    try {\n                        return BigInt(value) - subtrahend_1;\n                    }\n                    catch (_c) {\n                        return BigInt(0) - subtrahend_1;\n                    }\n                }\n                throw new TypeError(\"Invalid subtrahend \".concat(subtrahend_1));\n            }\n            var prefixToReplace = (_a = this.replacePrefix) === null || _a === void 0 ? void 0 : _a[0];\n            if (prefixToReplace && typeof value === 'string' && value.startsWith(prefixToReplace)) {\n                return this.replacePrefix[1] + value.substring(prefixToReplace.length);\n            }\n            return value;\n        };\n        return PropModification;\n    }());\n\n    var Collection =  (function () {\n        function Collection() {\n        }\n        Collection.prototype._read = function (fn, cb) {\n            var ctx = this._ctx;\n            return ctx.error ?\n                ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n                ctx.table._trans('readonly', fn).then(cb);\n        };\n        Collection.prototype._write = function (fn) {\n            var ctx = this._ctx;\n            return ctx.error ?\n                ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n                ctx.table._trans('readwrite', fn, \"locked\");\n        };\n        Collection.prototype._addAlgorithm = function (fn) {\n            var ctx = this._ctx;\n            ctx.algorithm = combine(ctx.algorithm, fn);\n        };\n        Collection.prototype._iterate = function (fn, coreTrans) {\n            return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n        };\n        Collection.prototype.clone = function (props) {\n            var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n            if (props)\n                extend(ctx, props);\n            rv._ctx = ctx;\n            return rv;\n        };\n        Collection.prototype.raw = function () {\n            this._ctx.valueMapper = null;\n            return this;\n        };\n        Collection.prototype.each = function (fn) {\n            var ctx = this._ctx;\n            return this._read(function (trans) { return iter(ctx, fn, trans, ctx.table.core); });\n        };\n        Collection.prototype.count = function (cb) {\n            var _this = this;\n            return this._read(function (trans) {\n                var ctx = _this._ctx;\n                var coreTable = ctx.table.core;\n                if (isPlainKeyRange(ctx, true)) {\n                    return coreTable.count({\n                        trans: trans,\n                        query: {\n                            index: getIndexOrStore(ctx, coreTable.schema),\n                            range: ctx.range\n                        }\n                    }).then(function (count) { return Math.min(count, ctx.limit); });\n                }\n                else {\n                    var count = 0;\n                    return iter(ctx, function () { ++count; return false; }, trans, coreTable)\n                        .then(function () { return count; });\n                }\n            }).then(cb);\n        };\n        Collection.prototype.sortBy = function (keyPath, cb) {\n            var parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n            function getval(obj, i) {\n                if (i)\n                    return getval(obj[parts[i]], i - 1);\n                return obj[lastPart];\n            }\n            var order = this._ctx.dir === \"next\" ? 1 : -1;\n            function sorter(a, b) {\n                var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n                return aVal < bVal ? -order : aVal > bVal ? order : 0;\n            }\n            return this.toArray(function (a) {\n                return a.sort(sorter);\n            }).then(cb);\n        };\n        Collection.prototype.toArray = function (cb) {\n            var _this = this;\n            return this._read(function (trans) {\n                var ctx = _this._ctx;\n                if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                    var valueMapper_1 = ctx.valueMapper;\n                    var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                    return ctx.table.core.query({\n                        trans: trans,\n                        limit: ctx.limit,\n                        values: true,\n                        query: {\n                            index: index,\n                            range: ctx.range\n                        }\n                    }).then(function (_a) {\n                        var result = _a.result;\n                        return valueMapper_1 ? result.map(valueMapper_1) : result;\n                    });\n                }\n                else {\n                    var a_1 = [];\n                    return iter(ctx, function (item) { return a_1.push(item); }, trans, ctx.table.core).then(function () { return a_1; });\n                }\n            }, cb);\n        };\n        Collection.prototype.offset = function (offset) {\n            var ctx = this._ctx;\n            if (offset <= 0)\n                return this;\n            ctx.offset += offset;\n            if (isPlainKeyRange(ctx)) {\n                addReplayFilter(ctx, function () {\n                    var offsetLeft = offset;\n                    return function (cursor, advance) {\n                        if (offsetLeft === 0)\n                            return true;\n                        if (offsetLeft === 1) {\n                            --offsetLeft;\n                            return false;\n                        }\n                        advance(function () {\n                            cursor.advance(offsetLeft);\n                            offsetLeft = 0;\n                        });\n                        return false;\n                    };\n                });\n            }\n            else {\n                addReplayFilter(ctx, function () {\n                    var offsetLeft = offset;\n                    return function () { return (--offsetLeft < 0); };\n                });\n            }\n            return this;\n        };\n        Collection.prototype.limit = function (numRows) {\n            this._ctx.limit = Math.min(this._ctx.limit, numRows);\n            addReplayFilter(this._ctx, function () {\n                var rowsLeft = numRows;\n                return function (cursor, advance, resolve) {\n                    if (--rowsLeft <= 0)\n                        advance(resolve);\n                    return rowsLeft >= 0;\n                };\n            }, true);\n            return this;\n        };\n        Collection.prototype.until = function (filterFunction, bIncludeStopEntry) {\n            addFilter(this._ctx, function (cursor, advance, resolve) {\n                if (filterFunction(cursor.value)) {\n                    advance(resolve);\n                    return bIncludeStopEntry;\n                }\n                else {\n                    return true;\n                }\n            });\n            return this;\n        };\n        Collection.prototype.first = function (cb) {\n            return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);\n        };\n        Collection.prototype.last = function (cb) {\n            return this.reverse().first(cb);\n        };\n        Collection.prototype.filter = function (filterFunction) {\n            addFilter(this._ctx, function (cursor) {\n                return filterFunction(cursor.value);\n            });\n            addMatchFilter(this._ctx, filterFunction);\n            return this;\n        };\n        Collection.prototype.and = function (filter) {\n            return this.filter(filter);\n        };\n        Collection.prototype.or = function (indexName) {\n            return new this.db.WhereClause(this._ctx.table, indexName, this);\n        };\n        Collection.prototype.reverse = function () {\n            this._ctx.dir = (this._ctx.dir === \"prev\" ? \"next\" : \"prev\");\n            if (this._ondirectionchange)\n                this._ondirectionchange(this._ctx.dir);\n            return this;\n        };\n        Collection.prototype.desc = function () {\n            return this.reverse();\n        };\n        Collection.prototype.eachKey = function (cb) {\n            var ctx = this._ctx;\n            ctx.keysOnly = !ctx.isMatch;\n            return this.each(function (val, cursor) { cb(cursor.key, cursor); });\n        };\n        Collection.prototype.eachUniqueKey = function (cb) {\n            this._ctx.unique = \"unique\";\n            return this.eachKey(cb);\n        };\n        Collection.prototype.eachPrimaryKey = function (cb) {\n            var ctx = this._ctx;\n            ctx.keysOnly = !ctx.isMatch;\n            return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });\n        };\n        Collection.prototype.keys = function (cb) {\n            var ctx = this._ctx;\n            ctx.keysOnly = !ctx.isMatch;\n            var a = [];\n            return this.each(function (item, cursor) {\n                a.push(cursor.key);\n            }).then(function () {\n                return a;\n            }).then(cb);\n        };\n        Collection.prototype.primaryKeys = function (cb) {\n            var ctx = this._ctx;\n            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                return this._read(function (trans) {\n                    var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                    return ctx.table.core.query({\n                        trans: trans,\n                        values: false,\n                        limit: ctx.limit,\n                        query: {\n                            index: index,\n                            range: ctx.range\n                        }\n                    });\n                }).then(function (_a) {\n                    var result = _a.result;\n                    return result;\n                }).then(cb);\n            }\n            ctx.keysOnly = !ctx.isMatch;\n            var a = [];\n            return this.each(function (item, cursor) {\n                a.push(cursor.primaryKey);\n            }).then(function () {\n                return a;\n            }).then(cb);\n        };\n        Collection.prototype.uniqueKeys = function (cb) {\n            this._ctx.unique = \"unique\";\n            return this.keys(cb);\n        };\n        Collection.prototype.firstKey = function (cb) {\n            return this.limit(1).keys(function (a) { return a[0]; }).then(cb);\n        };\n        Collection.prototype.lastKey = function (cb) {\n            return this.reverse().firstKey(cb);\n        };\n        Collection.prototype.distinct = function () {\n            var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n            if (!idx || !idx.multi)\n                return this;\n            var set = {};\n            addFilter(this._ctx, function (cursor) {\n                var strKey = cursor.primaryKey.toString();\n                var found = hasOwn(set, strKey);\n                set[strKey] = true;\n                return !found;\n            });\n            return this;\n        };\n        Collection.prototype.modify = function (changes) {\n            var _this = this;\n            var ctx = this._ctx;\n            return this._write(function (trans) {\n                var modifyer;\n                if (typeof changes === 'function') {\n                    modifyer = changes;\n                }\n                else {\n                    var keyPaths = keys(changes);\n                    var numKeys = keyPaths.length;\n                    modifyer = function (item) {\n                        var anythingModified = false;\n                        for (var i = 0; i < numKeys; ++i) {\n                            var keyPath = keyPaths[i];\n                            var val = changes[keyPath];\n                            var origVal = getByKeyPath(item, keyPath);\n                            if (val instanceof PropModification) {\n                                setByKeyPath(item, keyPath, val.execute(origVal));\n                                anythingModified = true;\n                            }\n                            else if (origVal !== val) {\n                                setByKeyPath(item, keyPath, val);\n                                anythingModified = true;\n                            }\n                        }\n                        return anythingModified;\n                    };\n                }\n                var coreTable = ctx.table.core;\n                var _a = coreTable.schema.primaryKey, outbound = _a.outbound, extractKey = _a.extractKey;\n                var limit = _this.db._options.modifyChunkSize || 200;\n                var totalFailures = [];\n                var successCount = 0;\n                var failedKeys = [];\n                var applyMutateResult = function (expectedCount, res) {\n                    var failures = res.failures, numFailures = res.numFailures;\n                    successCount += expectedCount - numFailures;\n                    for (var _i = 0, _a = keys(failures); _i < _a.length; _i++) {\n                        var pos = _a[_i];\n                        totalFailures.push(failures[pos]);\n                    }\n                };\n                return _this.clone().primaryKeys().then(function (keys) {\n                    var criteria = isPlainKeyRange(ctx) &&\n                        ctx.limit === Infinity &&\n                        (typeof changes !== 'function' || changes === deleteCallback) && {\n                        index: ctx.index,\n                        range: ctx.range\n                    };\n                    var nextChunk = function (offset) {\n                        var count = Math.min(limit, keys.length - offset);\n                        return coreTable.getMany({\n                            trans: trans,\n                            keys: keys.slice(offset, offset + count),\n                            cache: \"immutable\"\n                        }).then(function (values) {\n                            var addValues = [];\n                            var putValues = [];\n                            var putKeys = outbound ? [] : null;\n                            var deleteKeys = [];\n                            for (var i = 0; i < count; ++i) {\n                                var origValue = values[i];\n                                var ctx_1 = {\n                                    value: deepClone(origValue),\n                                    primKey: keys[offset + i]\n                                };\n                                if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {\n                                    if (ctx_1.value == null) {\n                                        deleteKeys.push(keys[offset + i]);\n                                    }\n                                    else if (!outbound && cmp(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {\n                                        deleteKeys.push(keys[offset + i]);\n                                        addValues.push(ctx_1.value);\n                                    }\n                                    else {\n                                        putValues.push(ctx_1.value);\n                                        if (outbound)\n                                            putKeys.push(keys[offset + i]);\n                                    }\n                                }\n                            }\n                            return Promise.resolve(addValues.length > 0 &&\n                                coreTable.mutate({ trans: trans, type: 'add', values: addValues })\n                                    .then(function (res) {\n                                    for (var pos in res.failures) {\n                                        deleteKeys.splice(parseInt(pos), 1);\n                                    }\n                                    applyMutateResult(addValues.length, res);\n                                })).then(function () { return (putValues.length > 0 || (criteria && typeof changes === 'object')) &&\n                                coreTable.mutate({\n                                    trans: trans,\n                                    type: 'put',\n                                    keys: putKeys,\n                                    values: putValues,\n                                    criteria: criteria,\n                                    changeSpec: typeof changes !== 'function'\n                                        && changes,\n                                    isAdditionalChunk: offset > 0\n                                }).then(function (res) { return applyMutateResult(putValues.length, res); }); }).then(function () { return (deleteKeys.length > 0 || (criteria && changes === deleteCallback)) &&\n                                coreTable.mutate({\n                                    trans: trans,\n                                    type: 'delete',\n                                    keys: deleteKeys,\n                                    criteria: criteria,\n                                    isAdditionalChunk: offset > 0\n                                }).then(function (res) { return applyMutateResult(deleteKeys.length, res); }); }).then(function () {\n                                return keys.length > offset + count && nextChunk(offset + limit);\n                            });\n                        });\n                    };\n                    return nextChunk(0).then(function () {\n                        if (totalFailures.length > 0)\n                            throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n                        return keys.length;\n                    });\n                });\n            });\n        };\n        Collection.prototype.delete = function () {\n            var ctx = this._ctx, range = ctx.range;\n            if (isPlainKeyRange(ctx) &&\n                (ctx.isPrimKey || range.type === 3 ))\n             {\n                return this._write(function (trans) {\n                    var primaryKey = ctx.table.core.schema.primaryKey;\n                    var coreRange = range;\n                    return ctx.table.core.count({ trans: trans, query: { index: primaryKey, range: coreRange } }).then(function (count) {\n                        return ctx.table.core.mutate({ trans: trans, type: 'deleteRange', range: coreRange })\n                            .then(function (_a) {\n                            var failures = _a.failures; _a.lastResult; _a.results; var numFailures = _a.numFailures;\n                            if (numFailures)\n                                throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(function (pos) { return failures[pos]; }), count - numFailures);\n                            return count - numFailures;\n                        });\n                    });\n                });\n            }\n            return this.modify(deleteCallback);\n        };\n        return Collection;\n    }());\n    var deleteCallback = function (value, ctx) { return ctx.value = null; };\n\n    function createCollectionConstructor(db) {\n        return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n            this.db = db;\n            var keyRange = AnyRange, error = null;\n            if (keyRangeGenerator)\n                try {\n                    keyRange = keyRangeGenerator();\n                }\n                catch (ex) {\n                    error = ex;\n                }\n            var whereCtx = whereClause._ctx;\n            var table = whereCtx.table;\n            var readingHook = table.hook.reading.fire;\n            this._ctx = {\n                table: table,\n                index: whereCtx.index,\n                isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),\n                range: keyRange,\n                keysOnly: false,\n                dir: \"next\",\n                unique: \"\",\n                algorithm: null,\n                filter: null,\n                replayFilter: null,\n                justLimit: true,\n                isMatch: null,\n                offset: 0,\n                limit: Infinity,\n                error: error,\n                or: whereCtx.or,\n                valueMapper: readingHook !== mirror ? readingHook : null\n            };\n        });\n    }\n\n    function simpleCompare(a, b) {\n        return a < b ? -1 : a === b ? 0 : 1;\n    }\n    function simpleCompareReverse(a, b) {\n        return a > b ? -1 : a === b ? 0 : 1;\n    }\n\n    function fail(collectionOrWhereClause, err, T) {\n        var collection = collectionOrWhereClause instanceof WhereClause ?\n            new collectionOrWhereClause.Collection(collectionOrWhereClause) :\n            collectionOrWhereClause;\n        collection._ctx.error = T ? new T(err) : new TypeError(err);\n        return collection;\n    }\n    function emptyCollection(whereClause) {\n        return new whereClause.Collection(whereClause, function () { return rangeEqual(\"\"); }).limit(0);\n    }\n    function upperFactory(dir) {\n        return dir === \"next\" ?\n            function (s) { return s.toUpperCase(); } :\n            function (s) { return s.toLowerCase(); };\n    }\n    function lowerFactory(dir) {\n        return dir === \"next\" ?\n            function (s) { return s.toLowerCase(); } :\n            function (s) { return s.toUpperCase(); };\n    }\n    function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n        var length = Math.min(key.length, lowerNeedle.length);\n        var llp = -1;\n        for (var i = 0; i < length; ++i) {\n            var lwrKeyChar = lowerKey[i];\n            if (lwrKeyChar !== lowerNeedle[i]) {\n                if (cmp(key[i], upperNeedle[i]) < 0)\n                    return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n                if (cmp(key[i], lowerNeedle[i]) < 0)\n                    return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n                if (llp >= 0)\n                    return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n                return null;\n            }\n            if (cmp(key[i], lwrKeyChar) < 0)\n                llp = i;\n        }\n        if (length < lowerNeedle.length && dir === \"next\")\n            return key + upperNeedle.substr(key.length);\n        if (length < key.length && dir === \"prev\")\n            return key.substr(0, upperNeedle.length);\n        return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));\n    }\n    function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n        var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n        if (!needles.every(function (s) { return typeof s === 'string'; })) {\n            return fail(whereClause, STRING_EXPECTED);\n        }\n        function initDirection(dir) {\n            upper = upperFactory(dir);\n            lower = lowerFactory(dir);\n            compare = (dir === \"next\" ? simpleCompare : simpleCompareReverse);\n            var needleBounds = needles.map(function (needle) {\n                return { lower: lower(needle), upper: upper(needle) };\n            }).sort(function (a, b) {\n                return compare(a.lower, b.lower);\n            });\n            upperNeedles = needleBounds.map(function (nb) { return nb.upper; });\n            lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });\n            direction = dir;\n            nextKeySuffix = (dir === \"next\" ? \"\" : suffix);\n        }\n        initDirection(\"next\");\n        var c = new whereClause.Collection(whereClause, function () { return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix); });\n        c._ondirectionchange = function (direction) {\n            initDirection(direction);\n        };\n        var firstPossibleNeedle = 0;\n        c._addAlgorithm(function (cursor, advance, resolve) {\n            var key = cursor.key;\n            if (typeof key !== 'string')\n                return false;\n            var lowerKey = lower(key);\n            if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n                return true;\n            }\n            else {\n                var lowestPossibleCasing = null;\n                for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n                    var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n                    if (casing === null && lowestPossibleCasing === null)\n                        firstPossibleNeedle = i + 1;\n                    else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n                        lowestPossibleCasing = casing;\n                    }\n                }\n                if (lowestPossibleCasing !== null) {\n                    advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });\n                }\n                else {\n                    advance(resolve);\n                }\n                return false;\n            }\n        });\n        return c;\n    }\n    function createRange(lower, upper, lowerOpen, upperOpen) {\n        return {\n            type: 2 ,\n            lower: lower,\n            upper: upper,\n            lowerOpen: lowerOpen,\n            upperOpen: upperOpen\n        };\n    }\n    function rangeEqual(value) {\n        return {\n            type: 1 ,\n            lower: value,\n            upper: value\n        };\n    }\n\n    var WhereClause =  (function () {\n        function WhereClause() {\n        }\n        Object.defineProperty(WhereClause.prototype, \"Collection\", {\n            get: function () {\n                return this._ctx.table.db.Collection;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        WhereClause.prototype.between = function (lower, upper, includeLower, includeUpper) {\n            includeLower = includeLower !== false;\n            includeUpper = includeUpper === true;\n            try {\n                if ((this._cmp(lower, upper) > 0) ||\n                    (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))\n                    return emptyCollection(this);\n                return new this.Collection(this, function () { return createRange(lower, upper, !includeLower, !includeUpper); });\n            }\n            catch (e) {\n                return fail(this, INVALID_KEY_ARGUMENT);\n            }\n        };\n        WhereClause.prototype.equals = function (value) {\n            if (value == null)\n                return fail(this, INVALID_KEY_ARGUMENT);\n            return new this.Collection(this, function () { return rangeEqual(value); });\n        };\n        WhereClause.prototype.above = function (value) {\n            if (value == null)\n                return fail(this, INVALID_KEY_ARGUMENT);\n            return new this.Collection(this, function () { return createRange(value, undefined, true); });\n        };\n        WhereClause.prototype.aboveOrEqual = function (value) {\n            if (value == null)\n                return fail(this, INVALID_KEY_ARGUMENT);\n            return new this.Collection(this, function () { return createRange(value, undefined, false); });\n        };\n        WhereClause.prototype.below = function (value) {\n            if (value == null)\n                return fail(this, INVALID_KEY_ARGUMENT);\n            return new this.Collection(this, function () { return createRange(undefined, value, false, true); });\n        };\n        WhereClause.prototype.belowOrEqual = function (value) {\n            if (value == null)\n                return fail(this, INVALID_KEY_ARGUMENT);\n            return new this.Collection(this, function () { return createRange(undefined, value); });\n        };\n        WhereClause.prototype.startsWith = function (str) {\n            if (typeof str !== 'string')\n                return fail(this, STRING_EXPECTED);\n            return this.between(str, str + maxString, true, true);\n        };\n        WhereClause.prototype.startsWithIgnoreCase = function (str) {\n            if (str === \"\")\n                return this.startsWith(str);\n            return addIgnoreCaseAlgorithm(this, function (x, a) { return x.indexOf(a[0]) === 0; }, [str], maxString);\n        };\n        WhereClause.prototype.equalsIgnoreCase = function (str) {\n            return addIgnoreCaseAlgorithm(this, function (x, a) { return x === a[0]; }, [str], \"\");\n        };\n        WhereClause.prototype.anyOfIgnoreCase = function () {\n            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n            if (set.length === 0)\n                return emptyCollection(this);\n            return addIgnoreCaseAlgorithm(this, function (x, a) { return a.indexOf(x) !== -1; }, set, \"\");\n        };\n        WhereClause.prototype.startsWithAnyOfIgnoreCase = function () {\n            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n            if (set.length === 0)\n                return emptyCollection(this);\n            return addIgnoreCaseAlgorithm(this, function (x, a) { return a.some(function (n) { return x.indexOf(n) === 0; }); }, set, maxString);\n        };\n        WhereClause.prototype.anyOf = function () {\n            var _this = this;\n            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n            var compare = this._cmp;\n            try {\n                set.sort(compare);\n            }\n            catch (e) {\n                return fail(this, INVALID_KEY_ARGUMENT);\n            }\n            if (set.length === 0)\n                return emptyCollection(this);\n            var c = new this.Collection(this, function () { return createRange(set[0], set[set.length - 1]); });\n            c._ondirectionchange = function (direction) {\n                compare = (direction === \"next\" ?\n                    _this._ascending :\n                    _this._descending);\n                set.sort(compare);\n            };\n            var i = 0;\n            c._addAlgorithm(function (cursor, advance, resolve) {\n                var key = cursor.key;\n                while (compare(key, set[i]) > 0) {\n                    ++i;\n                    if (i === set.length) {\n                        advance(resolve);\n                        return false;\n                    }\n                }\n                if (compare(key, set[i]) === 0) {\n                    return true;\n                }\n                else {\n                    advance(function () { cursor.continue(set[i]); });\n                    return false;\n                }\n            });\n            return c;\n        };\n        WhereClause.prototype.notEqual = function (value) {\n            return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });\n        };\n        WhereClause.prototype.noneOf = function () {\n            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n            if (set.length === 0)\n                return new this.Collection(this);\n            try {\n                set.sort(this._ascending);\n            }\n            catch (e) {\n                return fail(this, INVALID_KEY_ARGUMENT);\n            }\n            var ranges = set.reduce(function (res, val) { return res ?\n                res.concat([[res[res.length - 1][1], val]]) :\n                [[minKey, val]]; }, null);\n            ranges.push([set[set.length - 1], this.db._maxKey]);\n            return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });\n        };\n        WhereClause.prototype.inAnyRange = function (ranges, options) {\n            var _this = this;\n            var cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;\n            if (ranges.length === 0)\n                return emptyCollection(this);\n            if (!ranges.every(function (range) {\n                return range[0] !== undefined &&\n                    range[1] !== undefined &&\n                    ascending(range[0], range[1]) <= 0;\n            })) {\n                return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n            }\n            var includeLowers = !options || options.includeLowers !== false;\n            var includeUppers = options && options.includeUppers === true;\n            function addRange(ranges, newRange) {\n                var i = 0, l = ranges.length;\n                for (; i < l; ++i) {\n                    var range = ranges[i];\n                    if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n                        range[0] = min(range[0], newRange[0]);\n                        range[1] = max(range[1], newRange[1]);\n                        break;\n                    }\n                }\n                if (i === l)\n                    ranges.push(newRange);\n                return ranges;\n            }\n            var sortDirection = ascending;\n            function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }\n            var set;\n            try {\n                set = ranges.reduce(addRange, []);\n                set.sort(rangeSorter);\n            }\n            catch (ex) {\n                return fail(this, INVALID_KEY_ARGUMENT);\n            }\n            var rangePos = 0;\n            var keyIsBeyondCurrentEntry = includeUppers ?\n                function (key) { return ascending(key, set[rangePos][1]) > 0; } :\n                function (key) { return ascending(key, set[rangePos][1]) >= 0; };\n            var keyIsBeforeCurrentEntry = includeLowers ?\n                function (key) { return descending(key, set[rangePos][0]) > 0; } :\n                function (key) { return descending(key, set[rangePos][0]) >= 0; };\n            function keyWithinCurrentRange(key) {\n                return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n            }\n            var checkKey = keyIsBeyondCurrentEntry;\n            var c = new this.Collection(this, function () { return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers); });\n            c._ondirectionchange = function (direction) {\n                if (direction === \"next\") {\n                    checkKey = keyIsBeyondCurrentEntry;\n                    sortDirection = ascending;\n                }\n                else {\n                    checkKey = keyIsBeforeCurrentEntry;\n                    sortDirection = descending;\n                }\n                set.sort(rangeSorter);\n            };\n            c._addAlgorithm(function (cursor, advance, resolve) {\n                var key = cursor.key;\n                while (checkKey(key)) {\n                    ++rangePos;\n                    if (rangePos === set.length) {\n                        advance(resolve);\n                        return false;\n                    }\n                }\n                if (keyWithinCurrentRange(key)) {\n                    return true;\n                }\n                else if (_this._cmp(key, set[rangePos][1]) === 0 || _this._cmp(key, set[rangePos][0]) === 0) {\n                    return false;\n                }\n                else {\n                    advance(function () {\n                        if (sortDirection === ascending)\n                            cursor.continue(set[rangePos][0]);\n                        else\n                            cursor.continue(set[rangePos][1]);\n                    });\n                    return false;\n                }\n            });\n            return c;\n        };\n        WhereClause.prototype.startsWithAnyOf = function () {\n            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n            if (!set.every(function (s) { return typeof s === 'string'; })) {\n                return fail(this, \"startsWithAnyOf() only works with strings\");\n            }\n            if (set.length === 0)\n                return emptyCollection(this);\n            return this.inAnyRange(set.map(function (str) { return [str, str + maxString]; }));\n        };\n        return WhereClause;\n    }());\n\n    function createWhereClauseConstructor(db) {\n        return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n            this.db = db;\n            this._ctx = {\n                table: table,\n                index: index === \":id\" ? null : index,\n                or: orCollection\n            };\n            this._cmp = this._ascending = cmp;\n            this._descending = function (a, b) { return cmp(b, a); };\n            this._max = function (a, b) { return cmp(a, b) > 0 ? a : b; };\n            this._min = function (a, b) { return cmp(a, b) < 0 ? a : b; };\n            this._IDBKeyRange = db._deps.IDBKeyRange;\n            if (!this._IDBKeyRange)\n                throw new exceptions.MissingAPI();\n        });\n    }\n\n    function eventRejectHandler(reject) {\n        return wrap(function (event) {\n            preventDefault(event);\n            reject(event.target.error);\n            return false;\n        });\n    }\n    function preventDefault(event) {\n        if (event.stopPropagation)\n            event.stopPropagation();\n        if (event.preventDefault)\n            event.preventDefault();\n    }\n\n    var DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';\n    var STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\n    var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\n\n    var Transaction =  (function () {\n        function Transaction() {\n        }\n        Transaction.prototype._lock = function () {\n            assert(!PSD.global);\n            ++this._reculock;\n            if (this._reculock === 1 && !PSD.global)\n                PSD.lockOwnerFor = this;\n            return this;\n        };\n        Transaction.prototype._unlock = function () {\n            assert(!PSD.global);\n            if (--this._reculock === 0) {\n                if (!PSD.global)\n                    PSD.lockOwnerFor = null;\n                while (this._blockedFuncs.length > 0 && !this._locked()) {\n                    var fnAndPSD = this._blockedFuncs.shift();\n                    try {\n                        usePSD(fnAndPSD[1], fnAndPSD[0]);\n                    }\n                    catch (e) { }\n                }\n            }\n            return this;\n        };\n        Transaction.prototype._locked = function () {\n            return this._reculock && PSD.lockOwnerFor !== this;\n        };\n        Transaction.prototype.create = function (idbtrans) {\n            var _this = this;\n            if (!this.mode)\n                return this;\n            var idbdb = this.db.idbdb;\n            var dbOpenError = this.db._state.dbOpenError;\n            assert(!this.idbtrans);\n            if (!idbtrans && !idbdb) {\n                switch (dbOpenError && dbOpenError.name) {\n                    case \"DatabaseClosedError\":\n                        throw new exceptions.DatabaseClosed(dbOpenError);\n                    case \"MissingAPIError\":\n                        throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n                    default:\n                        throw new exceptions.OpenFailed(dbOpenError);\n                }\n            }\n            if (!this.active)\n                throw new exceptions.TransactionInactive();\n            assert(this._completion._state === null);\n            idbtrans = this.idbtrans = idbtrans ||\n                (this.db.core\n                    ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })\n                    : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));\n            idbtrans.onerror = wrap(function (ev) {\n                preventDefault(ev);\n                _this._reject(idbtrans.error);\n            });\n            idbtrans.onabort = wrap(function (ev) {\n                preventDefault(ev);\n                _this.active && _this._reject(new exceptions.Abort(idbtrans.error));\n                _this.active = false;\n                _this.on(\"abort\").fire(ev);\n            });\n            idbtrans.oncomplete = wrap(function () {\n                _this.active = false;\n                _this._resolve();\n                if ('mutatedParts' in idbtrans) {\n                    globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n                }\n            });\n            return this;\n        };\n        Transaction.prototype._promise = function (mode, fn, bWriteLock) {\n            var _this = this;\n            if (mode === 'readwrite' && this.mode !== 'readwrite')\n                return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n            if (!this.active)\n                return rejection(new exceptions.TransactionInactive());\n            if (this._locked()) {\n                return new DexiePromise(function (resolve, reject) {\n                    _this._blockedFuncs.push([function () {\n                            _this._promise(mode, fn, bWriteLock).then(resolve, reject);\n                        }, PSD]);\n                });\n            }\n            else if (bWriteLock) {\n                return newScope(function () {\n                    var p = new DexiePromise(function (resolve, reject) {\n                        _this._lock();\n                        var rv = fn(resolve, reject, _this);\n                        if (rv && rv.then)\n                            rv.then(resolve, reject);\n                    });\n                    p.finally(function () { return _this._unlock(); });\n                    p._lib = true;\n                    return p;\n                });\n            }\n            else {\n                var p = new DexiePromise(function (resolve, reject) {\n                    var rv = fn(resolve, reject, _this);\n                    if (rv && rv.then)\n                        rv.then(resolve, reject);\n                });\n                p._lib = true;\n                return p;\n            }\n        };\n        Transaction.prototype._root = function () {\n            return this.parent ? this.parent._root() : this;\n        };\n        Transaction.prototype.waitFor = function (promiseLike) {\n            var root = this._root();\n            var promise = DexiePromise.resolve(promiseLike);\n            if (root._waitingFor) {\n                root._waitingFor = root._waitingFor.then(function () { return promise; });\n            }\n            else {\n                root._waitingFor = promise;\n                root._waitingQueue = [];\n                var store = root.idbtrans.objectStore(root.storeNames[0]);\n                (function spin() {\n                    ++root._spinCount;\n                    while (root._waitingQueue.length)\n                        (root._waitingQueue.shift())();\n                    if (root._waitingFor)\n                        store.get(-Infinity).onsuccess = spin;\n                }());\n            }\n            var currentWaitPromise = root._waitingFor;\n            return new DexiePromise(function (resolve, reject) {\n                promise.then(function (res) { return root._waitingQueue.push(wrap(resolve.bind(null, res))); }, function (err) { return root._waitingQueue.push(wrap(reject.bind(null, err))); }).finally(function () {\n                    if (root._waitingFor === currentWaitPromise) {\n                        root._waitingFor = null;\n                    }\n                });\n            });\n        };\n        Transaction.prototype.abort = function () {\n            if (this.active) {\n                this.active = false;\n                if (this.idbtrans)\n                    this.idbtrans.abort();\n                this._reject(new exceptions.Abort());\n            }\n        };\n        Transaction.prototype.table = function (tableName) {\n            var memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));\n            if (hasOwn(memoizedTables, tableName))\n                return memoizedTables[tableName];\n            var tableSchema = this.schema[tableName];\n            if (!tableSchema) {\n                throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n            }\n            var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n            transactionBoundTable.core = this.db.core.table(tableName);\n            memoizedTables[tableName] = transactionBoundTable;\n            return transactionBoundTable;\n        };\n        return Transaction;\n    }());\n\n    function createTransactionConstructor(db) {\n        return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n            var _this = this;\n            this.db = db;\n            this.mode = mode;\n            this.storeNames = storeNames;\n            this.schema = dbschema;\n            this.chromeTransactionDurability = chromeTransactionDurability;\n            this.idbtrans = null;\n            this.on = Events(this, \"complete\", \"error\", \"abort\");\n            this.parent = parent || null;\n            this.active = true;\n            this._reculock = 0;\n            this._blockedFuncs = [];\n            this._resolve = null;\n            this._reject = null;\n            this._waitingFor = null;\n            this._waitingQueue = null;\n            this._spinCount = 0;\n            this._completion = new DexiePromise(function (resolve, reject) {\n                _this._resolve = resolve;\n                _this._reject = reject;\n            });\n            this._completion.then(function () {\n                _this.active = false;\n                _this.on.complete.fire();\n            }, function (e) {\n                var wasActive = _this.active;\n                _this.active = false;\n                _this.on.error.fire(e);\n                _this.parent ?\n                    _this.parent._reject(e) :\n                    wasActive && _this.idbtrans && _this.idbtrans.abort();\n                return rejection(e);\n            });\n        });\n    }\n\n    function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n        return {\n            name: name,\n            keyPath: keyPath,\n            unique: unique,\n            multi: multi,\n            auto: auto,\n            compound: compound,\n            src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n        };\n    }\n    function nameFromKeyPath(keyPath) {\n        return typeof keyPath === 'string' ?\n            keyPath :\n            keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : \"\";\n    }\n\n    function createTableSchema(name, primKey, indexes) {\n        return {\n            name: name,\n            primKey: primKey,\n            indexes: indexes,\n            mappedClass: null,\n            idxByName: arrayToObject(indexes, function (index) { return [index.name, index]; })\n        };\n    }\n\n    function safariMultiStoreFix(storeNames) {\n        return storeNames.length === 1 ? storeNames[0] : storeNames;\n    }\n    var getMaxKey = function (IdbKeyRange) {\n        try {\n            IdbKeyRange.only([[]]);\n            getMaxKey = function () { return [[]]; };\n            return [[]];\n        }\n        catch (e) {\n            getMaxKey = function () { return maxString; };\n            return maxString;\n        }\n    };\n\n    function getKeyExtractor(keyPath) {\n        if (keyPath == null) {\n            return function () { return undefined; };\n        }\n        else if (typeof keyPath === 'string') {\n            return getSinglePathKeyExtractor(keyPath);\n        }\n        else {\n            return function (obj) { return getByKeyPath(obj, keyPath); };\n        }\n    }\n    function getSinglePathKeyExtractor(keyPath) {\n        var split = keyPath.split('.');\n        if (split.length === 1) {\n            return function (obj) { return obj[keyPath]; };\n        }\n        else {\n            return function (obj) { return getByKeyPath(obj, keyPath); };\n        }\n    }\n\n    function arrayify(arrayLike) {\n        return [].slice.call(arrayLike);\n    }\n    var _id_counter = 0;\n    function getKeyPathAlias(keyPath) {\n        return keyPath == null ?\n            \":id\" :\n            typeof keyPath === 'string' ?\n                keyPath :\n                \"[\".concat(keyPath.join('+'), \"]\");\n    }\n    function createDBCore(db, IdbKeyRange, tmpTrans) {\n        function extractSchema(db, trans) {\n            var tables = arrayify(db.objectStoreNames);\n            return {\n                schema: {\n                    name: db.name,\n                    tables: tables.map(function (table) { return trans.objectStore(table); }).map(function (store) {\n                        var keyPath = store.keyPath, autoIncrement = store.autoIncrement;\n                        var compound = isArray(keyPath);\n                        var outbound = keyPath == null;\n                        var indexByKeyPath = {};\n                        var result = {\n                            name: store.name,\n                            primaryKey: {\n                                name: null,\n                                isPrimaryKey: true,\n                                outbound: outbound,\n                                compound: compound,\n                                keyPath: keyPath,\n                                autoIncrement: autoIncrement,\n                                unique: true,\n                                extractKey: getKeyExtractor(keyPath)\n                            },\n                            indexes: arrayify(store.indexNames).map(function (indexName) { return store.index(indexName); })\n                                .map(function (index) {\n                                var name = index.name, unique = index.unique, multiEntry = index.multiEntry, keyPath = index.keyPath;\n                                var compound = isArray(keyPath);\n                                var result = {\n                                    name: name,\n                                    compound: compound,\n                                    keyPath: keyPath,\n                                    unique: unique,\n                                    multiEntry: multiEntry,\n                                    extractKey: getKeyExtractor(keyPath)\n                                };\n                                indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n                                return result;\n                            }),\n                            getIndexByKeyPath: function (keyPath) { return indexByKeyPath[getKeyPathAlias(keyPath)]; }\n                        };\n                        indexByKeyPath[\":id\"] = result.primaryKey;\n                        if (keyPath != null) {\n                            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n                        }\n                        return result;\n                    })\n                },\n                hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&\n                    !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n                        !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n                        [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n            };\n        }\n        function makeIDBKeyRange(range) {\n            if (range.type === 3 )\n                return null;\n            if (range.type === 4 )\n                throw new Error(\"Cannot convert never type to IDBKeyRange\");\n            var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;\n            var idbRange = lower === undefined ?\n                upper === undefined ?\n                    null :\n                    IdbKeyRange.upperBound(upper, !!upperOpen) :\n                upper === undefined ?\n                    IdbKeyRange.lowerBound(lower, !!lowerOpen) :\n                    IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n            return idbRange;\n        }\n        function createDbCoreTable(tableSchema) {\n            var tableName = tableSchema.name;\n            function mutate(_a) {\n                var trans = _a.trans, type = _a.type, keys = _a.keys, values = _a.values, range = _a.range;\n                return new Promise(function (resolve, reject) {\n                    resolve = wrap(resolve);\n                    var store = trans.objectStore(tableName);\n                    var outbound = store.keyPath == null;\n                    var isAddOrPut = type === \"put\" || type === \"add\";\n                    if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')\n                        throw new Error(\"Invalid operation type: \" + type);\n                    var length = (keys || values || { length: 1 }).length;\n                    if (keys && values && keys.length !== values.length) {\n                        throw new Error(\"Given keys array must have same length as given values array.\");\n                    }\n                    if (length === 0)\n                        return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });\n                    var req;\n                    var reqs = [];\n                    var failures = [];\n                    var numFailures = 0;\n                    var errorHandler = function (event) {\n                        ++numFailures;\n                        preventDefault(event);\n                    };\n                    if (type === 'deleteRange') {\n                        if (range.type === 4 )\n                            return resolve({ numFailures: numFailures, failures: failures, results: [], lastResult: undefined });\n                        if (range.type === 3 )\n                            reqs.push(req = store.clear());\n                        else\n                            reqs.push(req = store.delete(makeIDBKeyRange(range)));\n                    }\n                    else {\n                        var _a = isAddOrPut ?\n                            outbound ?\n                                [values, keys] :\n                                [values, null] :\n                            [keys, null], args1 = _a[0], args2 = _a[1];\n                        if (isAddOrPut) {\n                            for (var i = 0; i < length; ++i) {\n                                reqs.push(req = (args2 && args2[i] !== undefined ?\n                                    store[type](args1[i], args2[i]) :\n                                    store[type](args1[i])));\n                                req.onerror = errorHandler;\n                            }\n                        }\n                        else {\n                            for (var i = 0; i < length; ++i) {\n                                reqs.push(req = store[type](args1[i]));\n                                req.onerror = errorHandler;\n                            }\n                        }\n                    }\n                    var done = function (event) {\n                        var lastResult = event.target.result;\n                        reqs.forEach(function (req, i) { return req.error != null && (failures[i] = req.error); });\n                        resolve({\n                            numFailures: numFailures,\n                            failures: failures,\n                            results: type === \"delete\" ? keys : reqs.map(function (req) { return req.result; }),\n                            lastResult: lastResult\n                        });\n                    };\n                    req.onerror = function (event) {\n                        errorHandler(event);\n                        done(event);\n                    };\n                    req.onsuccess = done;\n                });\n            }\n            function openCursor(_a) {\n                var trans = _a.trans, values = _a.values, query = _a.query, reverse = _a.reverse, unique = _a.unique;\n                return new Promise(function (resolve, reject) {\n                    resolve = wrap(resolve);\n                    var index = query.index, range = query.range;\n                    var store = trans.objectStore(tableName);\n                    var source = index.isPrimaryKey ?\n                        store :\n                        store.index(index.name);\n                    var direction = reverse ?\n                        unique ?\n                            \"prevunique\" :\n                            \"prev\" :\n                        unique ?\n                            \"nextunique\" :\n                            \"next\";\n                    var req = values || !('openKeyCursor' in source) ?\n                        source.openCursor(makeIDBKeyRange(range), direction) :\n                        source.openKeyCursor(makeIDBKeyRange(range), direction);\n                    req.onerror = eventRejectHandler(reject);\n                    req.onsuccess = wrap(function (ev) {\n                        var cursor = req.result;\n                        if (!cursor) {\n                            resolve(null);\n                            return;\n                        }\n                        cursor.___id = ++_id_counter;\n                        cursor.done = false;\n                        var _cursorContinue = cursor.continue.bind(cursor);\n                        var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n                        if (_cursorContinuePrimaryKey)\n                            _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n                        var _cursorAdvance = cursor.advance.bind(cursor);\n                        var doThrowCursorIsNotStarted = function () { throw new Error(\"Cursor not started\"); };\n                        var doThrowCursorIsStopped = function () { throw new Error(\"Cursor not stopped\"); };\n                        cursor.trans = trans;\n                        cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n                        cursor.fail = wrap(reject);\n                        cursor.next = function () {\n                            var _this = this;\n                            var gotOne = 1;\n                            return this.start(function () { return gotOne-- ? _this.continue() : _this.stop(); }).then(function () { return _this; });\n                        };\n                        cursor.start = function (callback) {\n                            var iterationPromise = new Promise(function (resolveIteration, rejectIteration) {\n                                resolveIteration = wrap(resolveIteration);\n                                req.onerror = eventRejectHandler(rejectIteration);\n                                cursor.fail = rejectIteration;\n                                cursor.stop = function (value) {\n                                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                                    resolveIteration(value);\n                                };\n                            });\n                            var guardedCallback = function () {\n                                if (req.result) {\n                                    try {\n                                        callback();\n                                    }\n                                    catch (err) {\n                                        cursor.fail(err);\n                                    }\n                                }\n                                else {\n                                    cursor.done = true;\n                                    cursor.start = function () { throw new Error(\"Cursor behind last entry\"); };\n                                    cursor.stop();\n                                }\n                            };\n                            req.onsuccess = wrap(function (ev) {\n                                req.onsuccess = guardedCallback;\n                                guardedCallback();\n                            });\n                            cursor.continue = _cursorContinue;\n                            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n                            cursor.advance = _cursorAdvance;\n                            guardedCallback();\n                            return iterationPromise;\n                        };\n                        resolve(cursor);\n                    }, reject);\n                });\n            }\n            function query(hasGetAll) {\n                return function (request) {\n                    return new Promise(function (resolve, reject) {\n                        resolve = wrap(resolve);\n                        var trans = request.trans, values = request.values, limit = request.limit, query = request.query;\n                        var nonInfinitLimit = limit === Infinity ? undefined : limit;\n                        var index = query.index, range = query.range;\n                        var store = trans.objectStore(tableName);\n                        var source = index.isPrimaryKey ? store : store.index(index.name);\n                        var idbKeyRange = makeIDBKeyRange(range);\n                        if (limit === 0)\n                            return resolve({ result: [] });\n                        if (hasGetAll) {\n                            var req = values ?\n                                source.getAll(idbKeyRange, nonInfinitLimit) :\n                                source.getAllKeys(idbKeyRange, nonInfinitLimit);\n                            req.onsuccess = function (event) { return resolve({ result: event.target.result }); };\n                            req.onerror = eventRejectHandler(reject);\n                        }\n                        else {\n                            var count_1 = 0;\n                            var req_1 = values || !('openKeyCursor' in source) ?\n                                source.openCursor(idbKeyRange) :\n                                source.openKeyCursor(idbKeyRange);\n                            var result_1 = [];\n                            req_1.onsuccess = function (event) {\n                                var cursor = req_1.result;\n                                if (!cursor)\n                                    return resolve({ result: result_1 });\n                                result_1.push(values ? cursor.value : cursor.primaryKey);\n                                if (++count_1 === limit)\n                                    return resolve({ result: result_1 });\n                                cursor.continue();\n                            };\n                            req_1.onerror = eventRejectHandler(reject);\n                        }\n                    });\n                };\n            }\n            return {\n                name: tableName,\n                schema: tableSchema,\n                mutate: mutate,\n                getMany: function (_a) {\n                    var trans = _a.trans, keys = _a.keys;\n                    return new Promise(function (resolve, reject) {\n                        resolve = wrap(resolve);\n                        var store = trans.objectStore(tableName);\n                        var length = keys.length;\n                        var result = new Array(length);\n                        var keyCount = 0;\n                        var callbackCount = 0;\n                        var req;\n                        var successHandler = function (event) {\n                            var req = event.target;\n                            if ((result[req._pos] = req.result) != null)\n                                ;\n                            if (++callbackCount === keyCount)\n                                resolve(result);\n                        };\n                        var errorHandler = eventRejectHandler(reject);\n                        for (var i = 0; i < length; ++i) {\n                            var key = keys[i];\n                            if (key != null) {\n                                req = store.get(keys[i]);\n                                req._pos = i;\n                                req.onsuccess = successHandler;\n                                req.onerror = errorHandler;\n                                ++keyCount;\n                            }\n                        }\n                        if (keyCount === 0)\n                            resolve(result);\n                    });\n                },\n                get: function (_a) {\n                    var trans = _a.trans, key = _a.key;\n                    return new Promise(function (resolve, reject) {\n                        resolve = wrap(resolve);\n                        var store = trans.objectStore(tableName);\n                        var req = store.get(key);\n                        req.onsuccess = function (event) { return resolve(event.target.result); };\n                        req.onerror = eventRejectHandler(reject);\n                    });\n                },\n                query: query(hasGetAll),\n                openCursor: openCursor,\n                count: function (_a) {\n                    var query = _a.query, trans = _a.trans;\n                    var index = query.index, range = query.range;\n                    return new Promise(function (resolve, reject) {\n                        var store = trans.objectStore(tableName);\n                        var source = index.isPrimaryKey ? store : store.index(index.name);\n                        var idbKeyRange = makeIDBKeyRange(range);\n                        var req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n                        req.onsuccess = wrap(function (ev) { return resolve(ev.target.result); });\n                        req.onerror = eventRejectHandler(reject);\n                    });\n                }\n            };\n        }\n        var _a = extractSchema(db, tmpTrans), schema = _a.schema, hasGetAll = _a.hasGetAll;\n        var tables = schema.tables.map(function (tableSchema) { return createDbCoreTable(tableSchema); });\n        var tableMap = {};\n        tables.forEach(function (table) { return tableMap[table.name] = table; });\n        return {\n            stack: \"dbcore\",\n            transaction: db.transaction.bind(db),\n            table: function (name) {\n                var result = tableMap[name];\n                if (!result)\n                    throw new Error(\"Table '\".concat(name, \"' not found\"));\n                return tableMap[name];\n            },\n            MIN_KEY: -Infinity,\n            MAX_KEY: getMaxKey(IdbKeyRange),\n            schema: schema\n        };\n    }\n\n    function createMiddlewareStack(stackImpl, middlewares) {\n        return middlewares.reduce(function (down, _a) {\n            var create = _a.create;\n            return (__assign(__assign({}, down), create(down)));\n        }, stackImpl);\n    }\n    function createMiddlewareStacks(middlewares, idbdb, _a, tmpTrans) {\n        var IDBKeyRange = _a.IDBKeyRange; _a.indexedDB;\n        var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n        return {\n            dbcore: dbcore\n        };\n    }\n    function generateMiddlewareStacks(db, tmpTrans) {\n        var idbdb = tmpTrans.db;\n        var stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n        db.core = stacks.dbcore;\n        db.tables.forEach(function (table) {\n            var tableName = table.name;\n            if (db.core.schema.tables.some(function (tbl) { return tbl.name === tableName; })) {\n                table.core = db.core.table(tableName);\n                if (db[tableName] instanceof db.Table) {\n                    db[tableName].core = table.core;\n                }\n            }\n        });\n    }\n\n    function setApiOnPlace(db, objs, tableNames, dbschema) {\n        tableNames.forEach(function (tableName) {\n            var schema = dbschema[tableName];\n            objs.forEach(function (obj) {\n                var propDesc = getPropertyDescriptor(obj, tableName);\n                if (!propDesc || (\"value\" in propDesc && propDesc.value === undefined)) {\n                    if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n                        setProp(obj, tableName, {\n                            get: function () { return this.table(tableName); },\n                            set: function (value) {\n                                defineProperty(this, tableName, { value: value, writable: true, configurable: true, enumerable: true });\n                            }\n                        });\n                    }\n                    else {\n                        obj[tableName] = new db.Table(tableName, schema);\n                    }\n                }\n            });\n        });\n    }\n    function removeTablesApi(db, objs) {\n        objs.forEach(function (obj) {\n            for (var key in obj) {\n                if (obj[key] instanceof db.Table)\n                    delete obj[key];\n            }\n        });\n    }\n    function lowerVersionFirst(a, b) {\n        return a._cfg.version - b._cfg.version;\n    }\n    function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n        var globalSchema = db._dbSchema;\n        if (idbUpgradeTrans.objectStoreNames.contains('$meta') && !globalSchema.$meta) {\n            globalSchema.$meta = createTableSchema(\"$meta\", parseIndexSyntax(\"\")[0], []);\n            db._storeNames.push('$meta');\n        }\n        var trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n        trans.create(idbUpgradeTrans);\n        trans._completion.catch(reject);\n        var rejectTransaction = trans._reject.bind(trans);\n        var transless = PSD.transless || PSD;\n        newScope(function () {\n            PSD.trans = trans;\n            PSD.transless = transless;\n            if (oldVersion === 0) {\n                keys(globalSchema).forEach(function (tableName) {\n                    createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n                });\n                generateMiddlewareStacks(db, idbUpgradeTrans);\n                DexiePromise.follow(function () { return db.on.populate.fire(trans); }).catch(rejectTransaction);\n            }\n            else {\n                generateMiddlewareStacks(db, idbUpgradeTrans);\n                return getExistingVersion(db, trans, oldVersion)\n                    .then(function (oldVersion) { return updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans); })\n                    .catch(rejectTransaction);\n            }\n        });\n    }\n    function patchCurrentVersion(db, idbUpgradeTrans) {\n        createMissingTables(db._dbSchema, idbUpgradeTrans);\n        if (idbUpgradeTrans.db.version % 10 === 0 && !idbUpgradeTrans.objectStoreNames.contains('$meta')) {\n            idbUpgradeTrans.db.createObjectStore('$meta').add(Math.ceil((idbUpgradeTrans.db.version / 10) - 1), 'version');\n        }\n        var globalSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n        adjustToExistingIndexNames(db, db._dbSchema, idbUpgradeTrans);\n        var diff = getSchemaDiff(globalSchema, db._dbSchema);\n        var _loop_1 = function (tableChange) {\n            if (tableChange.change.length || tableChange.recreate) {\n                console.warn(\"Unable to patch indexes of table \".concat(tableChange.name, \" because it has changes on the type of index or primary key.\"));\n                return { value: void 0 };\n            }\n            var store = idbUpgradeTrans.objectStore(tableChange.name);\n            tableChange.add.forEach(function (idx) {\n                if (debug)\n                    console.debug(\"Dexie upgrade patch: Creating missing index \".concat(tableChange.name, \".\").concat(idx.src));\n                addIndex(store, idx);\n            });\n        };\n        for (var _i = 0, _a = diff.change; _i < _a.length; _i++) {\n            var tableChange = _a[_i];\n            var state_1 = _loop_1(tableChange);\n            if (typeof state_1 === \"object\")\n                return state_1.value;\n        }\n    }\n    function getExistingVersion(db, trans, oldVersion) {\n        if (trans.storeNames.includes('$meta')) {\n            return trans.table('$meta').get('version').then(function (metaVersion) {\n                return metaVersion != null ? metaVersion : oldVersion;\n            });\n        }\n        else {\n            return DexiePromise.resolve(oldVersion);\n        }\n    }\n    function updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans) {\n        var queue = [];\n        var versions = db._versions;\n        var globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n        var versToRun = versions.filter(function (v) { return v._cfg.version >= oldVersion; });\n        if (versToRun.length === 0) {\n            return DexiePromise.resolve();\n        }\n        versToRun.forEach(function (version) {\n            queue.push(function () {\n                var oldSchema = globalSchema;\n                var newSchema = version._cfg.dbschema;\n                adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n                adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n                globalSchema = db._dbSchema = newSchema;\n                var diff = getSchemaDiff(oldSchema, newSchema);\n                diff.add.forEach(function (tuple) {\n                    createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n                });\n                diff.change.forEach(function (change) {\n                    if (change.recreate) {\n                        throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n                    }\n                    else {\n                        var store_1 = idbUpgradeTrans.objectStore(change.name);\n                        change.add.forEach(function (idx) { return addIndex(store_1, idx); });\n                        change.change.forEach(function (idx) {\n                            store_1.deleteIndex(idx.name);\n                            addIndex(store_1, idx);\n                        });\n                        change.del.forEach(function (idxName) { return store_1.deleteIndex(idxName); });\n                    }\n                });\n                var contentUpgrade = version._cfg.contentUpgrade;\n                if (contentUpgrade && version._cfg.version > oldVersion) {\n                    generateMiddlewareStacks(db, idbUpgradeTrans);\n                    trans._memoizedTables = {};\n                    var upgradeSchema_1 = shallowClone(newSchema);\n                    diff.del.forEach(function (table) {\n                        upgradeSchema_1[table] = oldSchema[table];\n                    });\n                    removeTablesApi(db, [db.Transaction.prototype]);\n                    setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema_1), upgradeSchema_1);\n                    trans.schema = upgradeSchema_1;\n                    var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);\n                    if (contentUpgradeIsAsync_1) {\n                        incrementExpectedAwaits();\n                    }\n                    var returnValue_1;\n                    var promiseFollowed = DexiePromise.follow(function () {\n                        returnValue_1 = contentUpgrade(trans);\n                        if (returnValue_1) {\n                            if (contentUpgradeIsAsync_1) {\n                                var decrementor = decrementExpectedAwaits.bind(null, null);\n                                returnValue_1.then(decrementor, decrementor);\n                            }\n                        }\n                    });\n                    return (returnValue_1 && typeof returnValue_1.then === 'function' ?\n                        DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function () { return returnValue_1; }));\n                }\n            });\n            queue.push(function (idbtrans) {\n                var newSchema = version._cfg.dbschema;\n                deleteRemovedTables(newSchema, idbtrans);\n                removeTablesApi(db, [db.Transaction.prototype]);\n                setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n                trans.schema = db._dbSchema;\n            });\n            queue.push(function (idbtrans) {\n                if (db.idbdb.objectStoreNames.contains('$meta')) {\n                    if (Math.ceil(db.idbdb.version / 10) === version._cfg.version) {\n                        db.idbdb.deleteObjectStore('$meta');\n                        delete db._dbSchema.$meta;\n                        db._storeNames = db._storeNames.filter(function (name) { return name !== '$meta'; });\n                    }\n                    else {\n                        idbtrans.objectStore('$meta').put(version._cfg.version, 'version');\n                    }\n                }\n            });\n        });\n        function runQueue() {\n            return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :\n                DexiePromise.resolve();\n        }\n        return runQueue().then(function () {\n            createMissingTables(globalSchema, idbUpgradeTrans);\n        });\n    }\n    function getSchemaDiff(oldSchema, newSchema) {\n        var diff = {\n            del: [],\n            add: [],\n            change: []\n        };\n        var table;\n        for (table in oldSchema) {\n            if (!newSchema[table])\n                diff.del.push(table);\n        }\n        for (table in newSchema) {\n            var oldDef = oldSchema[table], newDef = newSchema[table];\n            if (!oldDef) {\n                diff.add.push([table, newDef]);\n            }\n            else {\n                var change = {\n                    name: table,\n                    def: newDef,\n                    recreate: false,\n                    del: [],\n                    add: [],\n                    change: []\n                };\n                if ((\n                '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||\n                    (oldDef.primKey.auto !== newDef.primKey.auto)) {\n                    change.recreate = true;\n                    diff.change.push(change);\n                }\n                else {\n                    var oldIndexes = oldDef.idxByName;\n                    var newIndexes = newDef.idxByName;\n                    var idxName = void 0;\n                    for (idxName in oldIndexes) {\n                        if (!newIndexes[idxName])\n                            change.del.push(idxName);\n                    }\n                    for (idxName in newIndexes) {\n                        var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n                        if (!oldIdx)\n                            change.add.push(newIdx);\n                        else if (oldIdx.src !== newIdx.src)\n                            change.change.push(newIdx);\n                    }\n                    if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n                        diff.change.push(change);\n                    }\n                }\n            }\n        }\n        return diff;\n    }\n    function createTable(idbtrans, tableName, primKey, indexes) {\n        var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?\n            { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :\n            { autoIncrement: primKey.auto });\n        indexes.forEach(function (idx) { return addIndex(store, idx); });\n        return store;\n    }\n    function createMissingTables(newSchema, idbtrans) {\n        keys(newSchema).forEach(function (tableName) {\n            if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n                if (debug)\n                    console.debug('Dexie: Creating missing table', tableName);\n                createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n            }\n        });\n    }\n    function deleteRemovedTables(newSchema, idbtrans) {\n        [].slice.call(idbtrans.db.objectStoreNames).forEach(function (storeName) {\n            return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);\n        });\n    }\n    function addIndex(store, idx) {\n        store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });\n    }\n    function buildGlobalSchema(db, idbdb, tmpTrans) {\n        var globalSchema = {};\n        var dbStoreNames = slice(idbdb.objectStoreNames, 0);\n        dbStoreNames.forEach(function (storeName) {\n            var store = tmpTrans.objectStore(storeName);\n            var keyPath = store.keyPath;\n            var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", true, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n            var indexes = [];\n            for (var j = 0; j < store.indexNames.length; ++j) {\n                var idbindex = store.index(store.indexNames[j]);\n                keyPath = idbindex.keyPath;\n                var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n                indexes.push(index);\n            }\n            globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n        });\n        return globalSchema;\n    }\n    function readGlobalSchema(db, idbdb, tmpTrans) {\n        db.verno = idbdb.version / 10;\n        var globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n        db._storeNames = slice(idbdb.objectStoreNames, 0);\n        setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n    }\n    function verifyInstalledSchema(db, tmpTrans) {\n        var installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n        var diff = getSchemaDiff(installedSchema, db._dbSchema);\n        return !(diff.add.length || diff.change.some(function (ch) { return ch.add.length || ch.change.length; }));\n    }\n    function adjustToExistingIndexNames(db, schema, idbtrans) {\n        var storeNames = idbtrans.db.objectStoreNames;\n        for (var i = 0; i < storeNames.length; ++i) {\n            var storeName = storeNames[i];\n            var store = idbtrans.objectStore(storeName);\n            db._hasGetAll = 'getAll' in store;\n            for (var j = 0; j < store.indexNames.length; ++j) {\n                var indexName = store.indexNames[j];\n                var keyPath = store.index(indexName).keyPath;\n                var dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n                if (schema[storeName]) {\n                    var indexSpec = schema[storeName].idxByName[dexieName];\n                    if (indexSpec) {\n                        indexSpec.name = indexName;\n                        delete schema[storeName].idxByName[dexieName];\n                        schema[storeName].idxByName[indexName] = indexSpec;\n                    }\n                }\n            }\n        }\n        if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n            !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n            _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&\n            [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n            db._hasGetAll = false;\n        }\n    }\n    function parseIndexSyntax(primKeyAndIndexes) {\n        return primKeyAndIndexes.split(',').map(function (index, indexNum) {\n            index = index.trim();\n            var name = index.replace(/([&*]|\\+\\+)/g, \"\");\n            var keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n            return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n        });\n    }\n\n    var Version =  (function () {\n        function Version() {\n        }\n        Version.prototype._parseStoresSpec = function (stores, outSchema) {\n            keys(stores).forEach(function (tableName) {\n                if (stores[tableName] !== null) {\n                    var indexes = parseIndexSyntax(stores[tableName]);\n                    var primKey = indexes.shift();\n                    primKey.unique = true;\n                    if (primKey.multi)\n                        throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n                    indexes.forEach(function (idx) {\n                        if (idx.auto)\n                            throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n                        if (!idx.keyPath)\n                            throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n                    });\n                    outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n                }\n            });\n        };\n        Version.prototype.stores = function (stores) {\n            var db = this.db;\n            this._cfg.storesSource = this._cfg.storesSource ?\n                extend(this._cfg.storesSource, stores) :\n                stores;\n            var versions = db._versions;\n            var storesSpec = {};\n            var dbschema = {};\n            versions.forEach(function (version) {\n                extend(storesSpec, version._cfg.storesSource);\n                dbschema = (version._cfg.dbschema = {});\n                version._parseStoresSpec(storesSpec, dbschema);\n            });\n            db._dbSchema = dbschema;\n            removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n            setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n            db._storeNames = keys(dbschema);\n            return this;\n        };\n        Version.prototype.upgrade = function (upgradeFunction) {\n            this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n            return this;\n        };\n        return Version;\n    }());\n\n    function createVersionConstructor(db) {\n        return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n            this.db = db;\n            this._cfg = {\n                version: versionNumber,\n                storesSource: null,\n                dbschema: {},\n                tables: {},\n                contentUpgrade: null\n            };\n        });\n    }\n\n    function getDbNamesTable(indexedDB, IDBKeyRange) {\n        var dbNamesDB = indexedDB[\"_dbNamesDB\"];\n        if (!dbNamesDB) {\n            dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n                addons: [],\n                indexedDB: indexedDB,\n                IDBKeyRange: IDBKeyRange,\n            });\n            dbNamesDB.version(1).stores({ dbnames: \"name\" });\n        }\n        return dbNamesDB.table(\"dbnames\");\n    }\n    function hasDatabasesNative(indexedDB) {\n        return indexedDB && typeof indexedDB.databases === \"function\";\n    }\n    function getDatabaseNames(_a) {\n        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n        return hasDatabasesNative(indexedDB)\n            ? Promise.resolve(indexedDB.databases()).then(function (infos) {\n                return infos\n                    .map(function (info) { return info.name; })\n                    .filter(function (name) { return name !== DBNAMES_DB; });\n            })\n            : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n    }\n    function _onDatabaseCreated(_a, name) {\n        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n        !hasDatabasesNative(indexedDB) &&\n            name !== DBNAMES_DB &&\n            getDbNamesTable(indexedDB, IDBKeyRange).put({ name: name }).catch(nop);\n    }\n    function _onDatabaseDeleted(_a, name) {\n        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n        !hasDatabasesNative(indexedDB) &&\n            name !== DBNAMES_DB &&\n            getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n    }\n\n    function vip(fn) {\n        return newScope(function () {\n            PSD.letThrough = true;\n            return fn();\n        });\n    }\n\n    function idbReady() {\n        var isSafari = !navigator.userAgentData &&\n            /Safari\\//.test(navigator.userAgent) &&\n            !/Chrom(e|ium)\\//.test(navigator.userAgent);\n        if (!isSafari || !indexedDB.databases)\n            return Promise.resolve();\n        var intervalId;\n        return new Promise(function (resolve) {\n            var tryIdb = function () { return indexedDB.databases().finally(resolve); };\n            intervalId = setInterval(tryIdb, 100);\n            tryIdb();\n        }).finally(function () { return clearInterval(intervalId); });\n    }\n\n    var _a;\n    function isEmptyRange(node) {\n        return !(\"from\" in node);\n    }\n    var RangeSet = function (fromOrTree, to) {\n        if (this) {\n            extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });\n        }\n        else {\n            var rv = new RangeSet();\n            if (fromOrTree && (\"d\" in fromOrTree)) {\n                extend(rv, fromOrTree);\n            }\n            return rv;\n        }\n    };\n    props(RangeSet.prototype, (_a = {\n            add: function (rangeSet) {\n                mergeRanges(this, rangeSet);\n                return this;\n            },\n            addKey: function (key) {\n                addRange(this, key, key);\n                return this;\n            },\n            addKeys: function (keys) {\n                var _this = this;\n                keys.forEach(function (key) { return addRange(_this, key, key); });\n                return this;\n            }\n        },\n        _a[iteratorSymbol] = function () {\n            return getRangeSetIterator(this);\n        },\n        _a));\n    function addRange(target, from, to) {\n        var diff = cmp(from, to);\n        if (isNaN(diff))\n            return;\n        if (diff > 0)\n            throw RangeError();\n        if (isEmptyRange(target))\n            return extend(target, { from: from, to: to, d: 1 });\n        var left = target.l;\n        var right = target.r;\n        if (cmp(to, target.from) < 0) {\n            left\n                ? addRange(left, from, to)\n                : (target.l = { from: from, to: to, d: 1, l: null, r: null });\n            return rebalance(target);\n        }\n        if (cmp(from, target.to) > 0) {\n            right\n                ? addRange(right, from, to)\n                : (target.r = { from: from, to: to, d: 1, l: null, r: null });\n            return rebalance(target);\n        }\n        if (cmp(from, target.from) < 0) {\n            target.from = from;\n            target.l = null;\n            target.d = right ? right.d + 1 : 1;\n        }\n        if (cmp(to, target.to) > 0) {\n            target.to = to;\n            target.r = null;\n            target.d = target.l ? target.l.d + 1 : 1;\n        }\n        var rightWasCutOff = !target.r;\n        if (left && !target.l) {\n            mergeRanges(target, left);\n        }\n        if (right && rightWasCutOff) {\n            mergeRanges(target, right);\n        }\n    }\n    function mergeRanges(target, newSet) {\n        function _addRangeSet(target, _a) {\n            var from = _a.from, to = _a.to, l = _a.l, r = _a.r;\n            addRange(target, from, to);\n            if (l)\n                _addRangeSet(target, l);\n            if (r)\n                _addRangeSet(target, r);\n        }\n        if (!isEmptyRange(newSet))\n            _addRangeSet(target, newSet);\n    }\n    function rangesOverlap(rangeSet1, rangeSet2) {\n        var i1 = getRangeSetIterator(rangeSet2);\n        var nextResult1 = i1.next();\n        if (nextResult1.done)\n            return false;\n        var a = nextResult1.value;\n        var i2 = getRangeSetIterator(rangeSet1);\n        var nextResult2 = i2.next(a.from);\n        var b = nextResult2.value;\n        while (!nextResult1.done && !nextResult2.done) {\n            if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)\n                return true;\n            cmp(a.from, b.from) < 0\n                ? (a = (nextResult1 = i1.next(b.from)).value)\n                : (b = (nextResult2 = i2.next(a.from)).value);\n        }\n        return false;\n    }\n    function getRangeSetIterator(node) {\n        var state = isEmptyRange(node) ? null : { s: 0, n: node };\n        return {\n            next: function (key) {\n                var keyProvided = arguments.length > 0;\n                while (state) {\n                    switch (state.s) {\n                        case 0:\n                            state.s = 1;\n                            if (keyProvided) {\n                                while (state.n.l && cmp(key, state.n.from) < 0)\n                                    state = { up: state, n: state.n.l, s: 1 };\n                            }\n                            else {\n                                while (state.n.l)\n                                    state = { up: state, n: state.n.l, s: 1 };\n                            }\n                        case 1:\n                            state.s = 2;\n                            if (!keyProvided || cmp(key, state.n.to) <= 0)\n                                return { value: state.n, done: false };\n                        case 2:\n                            if (state.n.r) {\n                                state.s = 3;\n                                state = { up: state, n: state.n.r, s: 0 };\n                                continue;\n                            }\n                        case 3:\n                            state = state.up;\n                    }\n                }\n                return { done: true };\n            },\n        };\n    }\n    function rebalance(target) {\n        var _a, _b;\n        var diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n        var r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n        if (r) {\n            var l = r === \"r\" ? \"l\" : \"r\";\n            var rootClone = __assign({}, target);\n            var oldRootRight = target[r];\n            target.from = oldRootRight.from;\n            target.to = oldRootRight.to;\n            target[r] = oldRootRight[r];\n            rootClone[r] = oldRootRight[l];\n            target[l] = rootClone;\n            rootClone.d = computeDepth(rootClone);\n        }\n        target.d = computeDepth(target);\n    }\n    function computeDepth(_a) {\n        var r = _a.r, l = _a.l;\n        return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;\n    }\n\n    function extendObservabilitySet(target, newSet) {\n        keys(newSet).forEach(function (part) {\n            if (target[part])\n                mergeRanges(target[part], newSet[part]);\n            else\n                target[part] = cloneSimpleObjectTree(newSet[part]);\n        });\n        return target;\n    }\n\n    function obsSetsOverlap(os1, os2) {\n        return os1.all || os2.all || Object.keys(os1).some(function (key) { return os2[key] && rangesOverlap(os2[key], os1[key]); });\n    }\n\n    var cache = {};\n\n    var unsignaledParts = {};\n    var isTaskEnqueued = false;\n    function signalSubscribersLazily(part, optimistic) {\n        extendObservabilitySet(unsignaledParts, part);\n        if (!isTaskEnqueued) {\n            isTaskEnqueued = true;\n            setTimeout(function () {\n                isTaskEnqueued = false;\n                var parts = unsignaledParts;\n                unsignaledParts = {};\n                signalSubscribersNow(parts, false);\n            }, 0);\n        }\n    }\n    function signalSubscribersNow(updatedParts, deleteAffectedCacheEntries) {\n        if (deleteAffectedCacheEntries === void 0) { deleteAffectedCacheEntries = false; }\n        var queriesToSignal = new Set();\n        if (updatedParts.all) {\n            for (var _i = 0, _a = Object.values(cache); _i < _a.length; _i++) {\n                var tblCache = _a[_i];\n                collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);\n            }\n        }\n        else {\n            for (var key in updatedParts) {\n                var parts = /^idb\\:\\/\\/(.*)\\/(.*)\\//.exec(key);\n                if (parts) {\n                    var dbName = parts[1], tableName = parts[2];\n                    var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n                    if (tblCache)\n                        collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);\n                }\n            }\n        }\n        queriesToSignal.forEach(function (requery) { return requery(); });\n    }\n    function collectTableSubscribers(tblCache, updatedParts, outQueriesToSignal, deleteAffectedCacheEntries) {\n        var updatedEntryLists = [];\n        for (var _i = 0, _a = Object.entries(tblCache.queries.query); _i < _a.length; _i++) {\n            var _b = _a[_i], indexName = _b[0], entries = _b[1];\n            var filteredEntries = [];\n            for (var _c = 0, entries_1 = entries; _c < entries_1.length; _c++) {\n                var entry = entries_1[_c];\n                if (obsSetsOverlap(updatedParts, entry.obsSet)) {\n                    entry.subscribers.forEach(function (requery) { return outQueriesToSignal.add(requery); });\n                }\n                else if (deleteAffectedCacheEntries) {\n                    filteredEntries.push(entry);\n                }\n            }\n            if (deleteAffectedCacheEntries)\n                updatedEntryLists.push([indexName, filteredEntries]);\n        }\n        if (deleteAffectedCacheEntries) {\n            for (var _d = 0, updatedEntryLists_1 = updatedEntryLists; _d < updatedEntryLists_1.length; _d++) {\n                var _e = updatedEntryLists_1[_d], indexName = _e[0], filteredEntries = _e[1];\n                tblCache.queries.query[indexName] = filteredEntries;\n            }\n        }\n    }\n\n    function dexieOpen(db) {\n        var state = db._state;\n        var indexedDB = db._deps.indexedDB;\n        if (state.isBeingOpened || db.idbdb)\n            return state.dbReadyPromise.then(function () { return state.dbOpenError ?\n                rejection(state.dbOpenError) :\n                db; });\n        state.isBeingOpened = true;\n        state.dbOpenError = null;\n        state.openComplete = false;\n        var openCanceller = state.openCanceller;\n        var nativeVerToOpen = Math.round(db.verno * 10);\n        var schemaPatchMode = false;\n        function throwIfCancelled() {\n            if (state.openCanceller !== openCanceller)\n                throw new exceptions.DatabaseClosed('db.open() was cancelled');\n        }\n        var resolveDbReady = state.dbReadyResolve,\n        upgradeTransaction = null, wasCreated = false;\n        var tryOpenDB = function () { return new DexiePromise(function (resolve, reject) {\n            throwIfCancelled();\n            if (!indexedDB)\n                throw new exceptions.MissingAPI();\n            var dbName = db.name;\n            var req = state.autoSchema || !nativeVerToOpen ?\n                indexedDB.open(dbName) :\n                indexedDB.open(dbName, nativeVerToOpen);\n            if (!req)\n                throw new exceptions.MissingAPI();\n            req.onerror = eventRejectHandler(reject);\n            req.onblocked = wrap(db._fireOnBlocked);\n            req.onupgradeneeded = wrap(function (e) {\n                upgradeTransaction = req.transaction;\n                if (state.autoSchema && !db._options.allowEmptyDB) {\n                    req.onerror = preventDefault;\n                    upgradeTransaction.abort();\n                    req.result.close();\n                    var delreq = indexedDB.deleteDatabase(dbName);\n                    delreq.onsuccess = delreq.onerror = wrap(function () {\n                        reject(new exceptions.NoSuchDatabase(\"Database \".concat(dbName, \" doesnt exist\")));\n                    });\n                }\n                else {\n                    upgradeTransaction.onerror = eventRejectHandler(reject);\n                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n                    wasCreated = oldVer < 1;\n                    db.idbdb = req.result;\n                    if (schemaPatchMode) {\n                        patchCurrentVersion(db, upgradeTransaction);\n                    }\n                    runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n                }\n            }, reject);\n            req.onsuccess = wrap(function () {\n                upgradeTransaction = null;\n                var idbdb = db.idbdb = req.result;\n                var objectStoreNames = slice(idbdb.objectStoreNames);\n                if (objectStoreNames.length > 0)\n                    try {\n                        var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n                        if (state.autoSchema)\n                            readGlobalSchema(db, idbdb, tmpTrans);\n                        else {\n                            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n                            if (!verifyInstalledSchema(db, tmpTrans) && !schemaPatchMode) {\n                                console.warn(\"Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this.\");\n                                idbdb.close();\n                                nativeVerToOpen = idbdb.version + 1;\n                                schemaPatchMode = true;\n                                return resolve(tryOpenDB());\n                            }\n                        }\n                        generateMiddlewareStacks(db, tmpTrans);\n                    }\n                    catch (e) {\n                    }\n                connections.push(db);\n                idbdb.onversionchange = wrap(function (ev) {\n                    state.vcFired = true;\n                    db.on(\"versionchange\").fire(ev);\n                });\n                idbdb.onclose = wrap(function (ev) {\n                    db.on(\"close\").fire(ev);\n                });\n                if (wasCreated)\n                    _onDatabaseCreated(db._deps, dbName);\n                resolve();\n            }, reject);\n        }).catch(function (err) {\n            switch (err === null || err === void 0 ? void 0 : err.name) {\n                case \"UnknownError\":\n                    if (state.PR1398_maxLoop > 0) {\n                        state.PR1398_maxLoop--;\n                        console.warn('Dexie: Workaround for Chrome UnknownError on open()');\n                        return tryOpenDB();\n                    }\n                    break;\n                case \"VersionError\":\n                    if (nativeVerToOpen > 0) {\n                        nativeVerToOpen = 0;\n                        return tryOpenDB();\n                    }\n                    break;\n            }\n            return DexiePromise.reject(err);\n        }); };\n        return DexiePromise.race([\n            openCanceller,\n            (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)\n        ]).then(function () {\n            throwIfCancelled();\n            state.onReadyBeingFired = [];\n            return DexiePromise.resolve(vip(function () { return db.on.ready.fire(db.vip); })).then(function fireRemainders() {\n                if (state.onReadyBeingFired.length > 0) {\n                    var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);\n                    state.onReadyBeingFired = [];\n                    return DexiePromise.resolve(vip(function () { return remainders_1(db.vip); })).then(fireRemainders);\n                }\n            });\n        }).finally(function () {\n            if (state.openCanceller === openCanceller) {\n                state.onReadyBeingFired = null;\n                state.isBeingOpened = false;\n            }\n        }).catch(function (err) {\n            state.dbOpenError = err;\n            try {\n                upgradeTransaction && upgradeTransaction.abort();\n            }\n            catch (_a) { }\n            if (openCanceller === state.openCanceller) {\n                db._close();\n            }\n            return rejection(err);\n        }).finally(function () {\n            state.openComplete = true;\n            resolveDbReady();\n        }).then(function () {\n            if (wasCreated) {\n                var everything_1 = {};\n                db.tables.forEach(function (table) {\n                    table.schema.indexes.forEach(function (idx) {\n                        if (idx.name)\n                            everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/\").concat(idx.name)] = new RangeSet(-Infinity, [[[]]]);\n                    });\n                    everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/\")] = everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/:dels\")] = new RangeSet(-Infinity, [[[]]]);\n                });\n                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME).fire(everything_1);\n                signalSubscribersNow(everything_1, true);\n            }\n            return db;\n        });\n    }\n\n    function awaitIterator(iterator) {\n        var callNext = function (result) { return iterator.next(result); }, doThrow = function (error) { return iterator.throw(error); }, onSuccess = step(callNext), onError = step(doThrow);\n        function step(getNext) {\n            return function (val) {\n                var next = getNext(val), value = next.value;\n                return next.done ? value :\n                    (!value || typeof value.then !== 'function' ?\n                        isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :\n                        value.then(onSuccess, onError));\n            };\n        }\n        return step(callNext)();\n    }\n\n    function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n        var i = arguments.length;\n        if (i < 2)\n            throw new exceptions.InvalidArgument(\"Too few arguments\");\n        var args = new Array(i - 1);\n        while (--i)\n            args[i - 1] = arguments[i];\n        scopeFunc = args.pop();\n        var tables = flatten(args);\n        return [mode, tables, scopeFunc];\n    }\n    function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n        return DexiePromise.resolve().then(function () {\n            var transless = PSD.transless || PSD;\n            var trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n            trans.explicit = true;\n            var zoneProps = {\n                trans: trans,\n                transless: transless\n            };\n            if (parentTransaction) {\n                trans.idbtrans = parentTransaction.idbtrans;\n            }\n            else {\n                try {\n                    trans.create();\n                    trans.idbtrans._explicit = true;\n                    db._state.PR1398_maxLoop = 3;\n                }\n                catch (ex) {\n                    if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                        console.warn('Dexie: Need to reopen db');\n                        db.close({ disableAutoOpen: false });\n                        return db.open().then(function () { return enterTransactionScope(db, mode, storeNames, null, scopeFunc); });\n                    }\n                    return rejection(ex);\n                }\n            }\n            var scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n            if (scopeFuncIsAsync) {\n                incrementExpectedAwaits();\n            }\n            var returnValue;\n            var promiseFollowed = DexiePromise.follow(function () {\n                returnValue = scopeFunc.call(trans, trans);\n                if (returnValue) {\n                    if (scopeFuncIsAsync) {\n                        var decrementor = decrementExpectedAwaits.bind(null, null);\n                        returnValue.then(decrementor, decrementor);\n                    }\n                    else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n                        returnValue = awaitIterator(returnValue);\n                    }\n                }\n            }, zoneProps);\n            return (returnValue && typeof returnValue.then === 'function' ?\n                DexiePromise.resolve(returnValue).then(function (x) { return trans.active ?\n                    x\n                    : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\")); })\n                : promiseFollowed.then(function () { return returnValue; })).then(function (x) {\n                if (parentTransaction)\n                    trans._resolve();\n                return trans._completion.then(function () { return x; });\n            }).catch(function (e) {\n                trans._reject(e);\n                return rejection(e);\n            });\n        });\n    }\n\n    function pad(a, value, count) {\n        var result = isArray(a) ? a.slice() : [a];\n        for (var i = 0; i < count; ++i)\n            result.push(value);\n        return result;\n    }\n    function createVirtualIndexMiddleware(down) {\n        return __assign(__assign({}, down), { table: function (tableName) {\n                var table = down.table(tableName);\n                var schema = table.schema;\n                var indexLookup = {};\n                var allVirtualIndexes = [];\n                function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n                    var keyPathAlias = getKeyPathAlias(keyPath);\n                    var indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);\n                    var keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;\n                    var isVirtual = keyTail > 0;\n                    var virtualIndex = __assign(__assign({}, lowLevelIndex), { name: isVirtual\n                            ? \"\".concat(keyPathAlias, \"(virtual-from:\").concat(lowLevelIndex.name, \")\")\n                            : lowLevelIndex.name, lowLevelIndex: lowLevelIndex, isVirtual: isVirtual, keyTail: keyTail, keyLength: keyLength, extractKey: getKeyExtractor(keyPath), unique: !isVirtual && lowLevelIndex.unique });\n                    indexList.push(virtualIndex);\n                    if (!virtualIndex.isPrimaryKey) {\n                        allVirtualIndexes.push(virtualIndex);\n                    }\n                    if (keyLength > 1) {\n                        var virtualKeyPath = keyLength === 2 ?\n                            keyPath[0] :\n                            keyPath.slice(0, keyLength - 1);\n                        addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n                    }\n                    indexList.sort(function (a, b) { return a.keyTail - b.keyTail; });\n                    return virtualIndex;\n                }\n                var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n                indexLookup[\":id\"] = [primaryKey];\n                for (var _i = 0, _a = schema.indexes; _i < _a.length; _i++) {\n                    var index = _a[_i];\n                    addVirtualIndexes(index.keyPath, 0, index);\n                }\n                function findBestIndex(keyPath) {\n                    var result = indexLookup[getKeyPathAlias(keyPath)];\n                    return result && result[0];\n                }\n                function translateRange(range, keyTail) {\n                    return {\n                        type: range.type === 1  ?\n                            2  :\n                            range.type,\n                        lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n                        lowerOpen: true,\n                        upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n                        upperOpen: true\n                    };\n                }\n                function translateRequest(req) {\n                    var index = req.query.index;\n                    return index.isVirtual ? __assign(__assign({}, req), { query: {\n                            index: index.lowLevelIndex,\n                            range: translateRange(req.query.range, index.keyTail)\n                        } }) : req;\n                }\n                var result = __assign(__assign({}, table), { schema: __assign(__assign({}, schema), { primaryKey: primaryKey, indexes: allVirtualIndexes, getIndexByKeyPath: findBestIndex }), count: function (req) {\n                        return table.count(translateRequest(req));\n                    }, query: function (req) {\n                        return table.query(translateRequest(req));\n                    }, openCursor: function (req) {\n                        var _a = req.query.index, keyTail = _a.keyTail, isVirtual = _a.isVirtual, keyLength = _a.keyLength;\n                        if (!isVirtual)\n                            return table.openCursor(req);\n                        function createVirtualCursor(cursor) {\n                            function _continue(key) {\n                                key != null ?\n                                    cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :\n                                    req.unique ?\n                                        cursor.continue(cursor.key.slice(0, keyLength)\n                                            .concat(req.reverse\n                                            ? down.MIN_KEY\n                                            : down.MAX_KEY, keyTail)) :\n                                        cursor.continue();\n                            }\n                            var virtualCursor = Object.create(cursor, {\n                                continue: { value: _continue },\n                                continuePrimaryKey: {\n                                    value: function (key, primaryKey) {\n                                        cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                                    }\n                                },\n                                primaryKey: {\n                                    get: function () {\n                                        return cursor.primaryKey;\n                                    }\n                                },\n                                key: {\n                                    get: function () {\n                                        var key = cursor.key;\n                                        return keyLength === 1 ?\n                                            key[0] :\n                                            key.slice(0, keyLength);\n                                    }\n                                },\n                                value: {\n                                    get: function () {\n                                        return cursor.value;\n                                    }\n                                }\n                            });\n                            return virtualCursor;\n                        }\n                        return table.openCursor(translateRequest(req))\n                            .then(function (cursor) { return cursor && createVirtualCursor(cursor); });\n                    } });\n                return result;\n            } });\n    }\n    var virtualIndexMiddleware = {\n        stack: \"dbcore\",\n        name: \"VirtualIndexMiddleware\",\n        level: 1,\n        create: createVirtualIndexMiddleware\n    };\n\n    function getObjectDiff(a, b, rv, prfx) {\n        rv = rv || {};\n        prfx = prfx || '';\n        keys(a).forEach(function (prop) {\n            if (!hasOwn(b, prop)) {\n                rv[prfx + prop] = undefined;\n            }\n            else {\n                var ap = a[prop], bp = b[prop];\n                if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n                    var apTypeName = toStringTag(ap);\n                    var bpTypeName = toStringTag(bp);\n                    if (apTypeName !== bpTypeName) {\n                        rv[prfx + prop] = b[prop];\n                    }\n                    else if (apTypeName === 'Object') {\n                        getObjectDiff(ap, bp, rv, prfx + prop + '.');\n                    }\n                    else if (ap !== bp) {\n                        rv[prfx + prop] = b[prop];\n                    }\n                }\n                else if (ap !== bp)\n                    rv[prfx + prop] = b[prop];\n            }\n        });\n        keys(b).forEach(function (prop) {\n            if (!hasOwn(a, prop)) {\n                rv[prfx + prop] = b[prop];\n            }\n        });\n        return rv;\n    }\n\n    function getEffectiveKeys(primaryKey, req) {\n        if (req.type === 'delete')\n            return req.keys;\n        return req.keys || req.values.map(primaryKey.extractKey);\n    }\n\n    var hooksMiddleware = {\n        stack: \"dbcore\",\n        name: \"HooksMiddleware\",\n        level: 2,\n        create: function (downCore) { return (__assign(__assign({}, downCore), { table: function (tableName) {\n                var downTable = downCore.table(tableName);\n                var primaryKey = downTable.schema.primaryKey;\n                var tableMiddleware = __assign(__assign({}, downTable), { mutate: function (req) {\n                        var dxTrans = PSD.trans;\n                        var _a = dxTrans.table(tableName).hook, deleting = _a.deleting, creating = _a.creating, updating = _a.updating;\n                        switch (req.type) {\n                            case 'add':\n                                if (creating.fire === nop)\n                                    break;\n                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n                            case 'put':\n                                if (creating.fire === nop && updating.fire === nop)\n                                    break;\n                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n                            case 'delete':\n                                if (deleting.fire === nop)\n                                    break;\n                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n                            case 'deleteRange':\n                                if (deleting.fire === nop)\n                                    break;\n                                return dxTrans._promise('readwrite', function () { return deleteRange(req); }, true);\n                        }\n                        return downTable.mutate(req);\n                        function addPutOrDelete(req) {\n                            var dxTrans = PSD.trans;\n                            var keys = req.keys || getEffectiveKeys(primaryKey, req);\n                            if (!keys)\n                                throw new Error(\"Keys missing\");\n                            req = req.type === 'add' || req.type === 'put' ? __assign(__assign({}, req), { keys: keys }) : __assign({}, req);\n                            if (req.type !== 'delete')\n                                req.values = __spreadArray([], req.values, true);\n                            if (req.keys)\n                                req.keys = __spreadArray([], req.keys, true);\n                            return getExistingValues(downTable, req, keys).then(function (existingValues) {\n                                var contexts = keys.map(function (key, i) {\n                                    var existingValue = existingValues[i];\n                                    var ctx = { onerror: null, onsuccess: null };\n                                    if (req.type === 'delete') {\n                                        deleting.fire.call(ctx, key, existingValue, dxTrans);\n                                    }\n                                    else if (req.type === 'add' || existingValue === undefined) {\n                                        var generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n                                        if (key == null && generatedPrimaryKey != null) {\n                                            key = generatedPrimaryKey;\n                                            req.keys[i] = key;\n                                            if (!primaryKey.outbound) {\n                                                setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                                            }\n                                        }\n                                    }\n                                    else {\n                                        var objectDiff = getObjectDiff(existingValue, req.values[i]);\n                                        var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n                                        if (additionalChanges_1) {\n                                            var requestedValue_1 = req.values[i];\n                                            Object.keys(additionalChanges_1).forEach(function (keyPath) {\n                                                if (hasOwn(requestedValue_1, keyPath)) {\n                                                    requestedValue_1[keyPath] = additionalChanges_1[keyPath];\n                                                }\n                                                else {\n                                                    setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);\n                                                }\n                                            });\n                                        }\n                                    }\n                                    return ctx;\n                                });\n                                return downTable.mutate(req).then(function (_a) {\n                                    var failures = _a.failures, results = _a.results, numFailures = _a.numFailures, lastResult = _a.lastResult;\n                                    for (var i = 0; i < keys.length; ++i) {\n                                        var primKey = results ? results[i] : keys[i];\n                                        var ctx = contexts[i];\n                                        if (primKey == null) {\n                                            ctx.onerror && ctx.onerror(failures[i]);\n                                        }\n                                        else {\n                                            ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?\n                                                req.values[i] :\n                                                primKey\n                                            );\n                                        }\n                                    }\n                                    return { failures: failures, results: results, numFailures: numFailures, lastResult: lastResult };\n                                }).catch(function (error) {\n                                    contexts.forEach(function (ctx) { return ctx.onerror && ctx.onerror(error); });\n                                    return Promise.reject(error);\n                                });\n                            });\n                        }\n                        function deleteRange(req) {\n                            return deleteNextChunk(req.trans, req.range, 10000);\n                        }\n                        function deleteNextChunk(trans, range, limit) {\n                            return downTable.query({ trans: trans, values: false, query: { index: primaryKey, range: range }, limit: limit })\n                                .then(function (_a) {\n                                var result = _a.result;\n                                return addPutOrDelete({ type: 'delete', keys: result, trans: trans }).then(function (res) {\n                                    if (res.numFailures > 0)\n                                        return Promise.reject(res.failures[0]);\n                                    if (result.length < limit) {\n                                        return { failures: [], numFailures: 0, lastResult: undefined };\n                                    }\n                                    else {\n                                        return deleteNextChunk(trans, __assign(__assign({}, range), { lower: result[result.length - 1], lowerOpen: true }), limit);\n                                    }\n                                });\n                            });\n                        }\n                    } });\n                return tableMiddleware;\n            } })); }\n    };\n    function getExistingValues(table, req, effectiveKeys) {\n        return req.type === \"add\"\n            ? Promise.resolve([])\n            : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: \"immutable\" });\n    }\n\n    function getFromTransactionCache(keys, cache, clone) {\n        try {\n            if (!cache)\n                return null;\n            if (cache.keys.length < keys.length)\n                return null;\n            var result = [];\n            for (var i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n                if (cmp(cache.keys[i], keys[j]) !== 0)\n                    continue;\n                result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n                ++j;\n            }\n            return result.length === keys.length ? result : null;\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n    var cacheExistingValuesMiddleware = {\n        stack: \"dbcore\",\n        level: -1,\n        create: function (core) {\n            return {\n                table: function (tableName) {\n                    var table = core.table(tableName);\n                    return __assign(__assign({}, table), { getMany: function (req) {\n                            if (!req.cache) {\n                                return table.getMany(req);\n                            }\n                            var cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n                            if (cachedResult) {\n                                return DexiePromise.resolve(cachedResult);\n                            }\n                            return table.getMany(req).then(function (res) {\n                                req.trans[\"_cache\"] = {\n                                    keys: req.keys,\n                                    values: req.cache === \"clone\" ? deepClone(res) : res,\n                                };\n                                return res;\n                            });\n                        }, mutate: function (req) {\n                            if (req.type !== \"add\")\n                                req.trans[\"_cache\"] = null;\n                            return table.mutate(req);\n                        } });\n                },\n            };\n        },\n    };\n\n    function isCachableContext(ctx, table) {\n        return (ctx.trans.mode === 'readonly' &&\n            !!ctx.subscr &&\n            !ctx.trans.explicit &&\n            ctx.trans.db._options.cache !== 'disabled' &&\n            !table.schema.primaryKey.outbound);\n    }\n\n    function isCachableRequest(type, req) {\n        switch (type) {\n            case 'query':\n                return req.values && !req.unique;\n            case 'get':\n                return false;\n            case 'getMany':\n                return false;\n            case 'count':\n                return false;\n            case 'openCursor':\n                return false;\n        }\n    }\n\n    var observabilityMiddleware = {\n        stack: \"dbcore\",\n        level: 0,\n        name: \"Observability\",\n        create: function (core) {\n            var dbName = core.schema.name;\n            var FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n            return __assign(__assign({}, core), { transaction: function (stores, mode, options) {\n                    if (PSD.subscr && mode !== 'readonly') {\n                        throw new exceptions.ReadOnly(\"Readwrite transaction in liveQuery context. Querier source: \".concat(PSD.querier));\n                    }\n                    return core.transaction(stores, mode, options);\n                }, table: function (tableName) {\n                    var table = core.table(tableName);\n                    var schema = table.schema;\n                    var primaryKey = schema.primaryKey, indexes = schema.indexes;\n                    var extractKey = primaryKey.extractKey, outbound = primaryKey.outbound;\n                    var indexesWithAutoIncPK = primaryKey.autoIncrement && indexes.filter(function (index) { return index.compound && index.keyPath.includes(primaryKey.keyPath); });\n                    var tableClone = __assign(__assign({}, table), { mutate: function (req) {\n                            var trans = req.trans;\n                            var mutatedParts = req.mutatedParts || (req.mutatedParts = {});\n                            var getRangeSet = function (indexName) {\n                                var part = \"idb://\".concat(dbName, \"/\").concat(tableName, \"/\").concat(indexName);\n                                return (mutatedParts[part] ||\n                                    (mutatedParts[part] = new RangeSet()));\n                            };\n                            var pkRangeSet = getRangeSet(\"\");\n                            var delsRangeSet = getRangeSet(\":dels\");\n                            var type = req.type;\n                            var _a = req.type === \"deleteRange\"\n                                ? [req.range]\n                                : req.type === \"delete\"\n                                    ? [req.keys]\n                                    : req.values.length < 50\n                                        ? [getEffectiveKeys(primaryKey, req).filter(function (id) { return id; }), req.values]\n                                        : [], keys = _a[0], newObjs = _a[1];\n                            var oldCache = req.trans[\"_cache\"];\n                            if (isArray(keys)) {\n                                pkRangeSet.addKeys(keys);\n                                var oldObjs = type === 'delete' || keys.length === newObjs.length ? getFromTransactionCache(keys, oldCache) : null;\n                                if (!oldObjs) {\n                                    delsRangeSet.addKeys(keys);\n                                }\n                                if (oldObjs || newObjs) {\n                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                                }\n                            }\n                            else if (keys) {\n                                var range = { from: keys.lower, to: keys.upper };\n                                delsRangeSet.add(range);\n                                pkRangeSet.add(range);\n                            }\n                            else {\n                                pkRangeSet.add(FULL_RANGE);\n                                delsRangeSet.add(FULL_RANGE);\n                                schema.indexes.forEach(function (idx) { return getRangeSet(idx.name).add(FULL_RANGE); });\n                            }\n                            return table.mutate(req).then(function (res) {\n                                if (keys && (req.type === 'add' || req.type === 'put')) {\n                                    pkRangeSet.addKeys(res.results);\n                                    if (indexesWithAutoIncPK) {\n                                        indexesWithAutoIncPK.forEach(function (idx) {\n                                            var idxVals = req.values.map(function (v) { return idx.extractKey(v); });\n                                            var pkPos = idx.keyPath.findIndex(function (prop) { return prop === primaryKey.keyPath; });\n                                            res.results.forEach(function (pk) { return idxVals[pkPos] = pk; });\n                                            getRangeSet(idx.name).addKeys(idxVals);\n                                        });\n                                    }\n                                }\n                                trans.mutatedParts = extendObservabilitySet(trans.mutatedParts || {}, mutatedParts);\n                                return res;\n                            });\n                        } });\n                    var getRange = function (_a) {\n                        var _b, _c;\n                        var _d = _a.query, index = _d.index, range = _d.range;\n                        return [\n                            index,\n                            new RangeSet((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY),\n                        ];\n                    };\n                    var readSubscribers = {\n                        get: function (req) { return [primaryKey, new RangeSet(req.key)]; },\n                        getMany: function (req) { return [primaryKey, new RangeSet().addKeys(req.keys)]; },\n                        count: getRange,\n                        query: getRange,\n                        openCursor: getRange,\n                    };\n                    keys(readSubscribers).forEach(function (method) {\n                        tableClone[method] = function (req) {\n                            var subscr = PSD.subscr;\n                            var isLiveQuery = !!subscr;\n                            var cachable = isCachableContext(PSD, table) && isCachableRequest(method, req);\n                            var obsSet = cachable\n                                ? req.obsSet = {}\n                                : subscr;\n                            if (isLiveQuery) {\n                                var getRangeSet = function (indexName) {\n                                    var part = \"idb://\".concat(dbName, \"/\").concat(tableName, \"/\").concat(indexName);\n                                    return (obsSet[part] ||\n                                        (obsSet[part] = new RangeSet()));\n                                };\n                                var pkRangeSet_1 = getRangeSet(\"\");\n                                var delsRangeSet_1 = getRangeSet(\":dels\");\n                                var _a = readSubscribers[method](req), queriedIndex = _a[0], queriedRanges = _a[1];\n                                if (method === 'query' && queriedIndex.isPrimaryKey && !req.values) {\n                                    delsRangeSet_1.add(queriedRanges);\n                                }\n                                else {\n                                    getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n                                }\n                                if (!queriedIndex.isPrimaryKey) {\n                                    if (method === \"count\") {\n                                        delsRangeSet_1.add(FULL_RANGE);\n                                    }\n                                    else {\n                                        var keysPromise_1 = method === \"query\" &&\n                                            outbound &&\n                                            req.values &&\n                                            table.query(__assign(__assign({}, req), { values: false }));\n                                        return table[method].apply(this, arguments).then(function (res) {\n                                            if (method === \"query\") {\n                                                if (outbound && req.values) {\n                                                    return keysPromise_1.then(function (_a) {\n                                                        var resultingKeys = _a.result;\n                                                        pkRangeSet_1.addKeys(resultingKeys);\n                                                        return res;\n                                                    });\n                                                }\n                                                var pKeys = req.values\n                                                    ? res.result.map(extractKey)\n                                                    : res.result;\n                                                if (req.values) {\n                                                    pkRangeSet_1.addKeys(pKeys);\n                                                }\n                                                else {\n                                                    delsRangeSet_1.addKeys(pKeys);\n                                                }\n                                            }\n                                            else if (method === \"openCursor\") {\n                                                var cursor_1 = res;\n                                                var wantValues_1 = req.values;\n                                                return (cursor_1 &&\n                                                    Object.create(cursor_1, {\n                                                        key: {\n                                                            get: function () {\n                                                                delsRangeSet_1.addKey(cursor_1.primaryKey);\n                                                                return cursor_1.key;\n                                                            },\n                                                        },\n                                                        primaryKey: {\n                                                            get: function () {\n                                                                var pkey = cursor_1.primaryKey;\n                                                                delsRangeSet_1.addKey(pkey);\n                                                                return pkey;\n                                                            },\n                                                        },\n                                                        value: {\n                                                            get: function () {\n                                                                wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);\n                                                                return cursor_1.value;\n                                                            },\n                                                        },\n                                                    }));\n                                            }\n                                            return res;\n                                        });\n                                    }\n                                }\n                            }\n                            return table[method].apply(this, arguments);\n                        };\n                    });\n                    return tableClone;\n                } });\n        },\n    };\n    function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n        function addAffectedIndex(ix) {\n            var rangeSet = getRangeSet(ix.name || \"\");\n            function extractKey(obj) {\n                return obj != null ? ix.extractKey(obj) : null;\n            }\n            var addKeyOrKeys = function (key) { return ix.multiEntry && isArray(key)\n                ? key.forEach(function (key) { return rangeSet.addKey(key); })\n                : rangeSet.addKey(key); };\n            (oldObjs || newObjs).forEach(function (_, i) {\n                var oldKey = oldObjs && extractKey(oldObjs[i]);\n                var newKey = newObjs && extractKey(newObjs[i]);\n                if (cmp(oldKey, newKey) !== 0) {\n                    if (oldKey != null)\n                        addKeyOrKeys(oldKey);\n                    if (newKey != null)\n                        addKeyOrKeys(newKey);\n                }\n            });\n        }\n        schema.indexes.forEach(addAffectedIndex);\n    }\n\n    function adjustOptimisticFromFailures(tblCache, req, res) {\n        if (res.numFailures === 0)\n            return req;\n        if (req.type === 'deleteRange') {\n            return null;\n        }\n        var numBulkOps = req.keys\n            ? req.keys.length\n            : 'values' in req && req.values\n                ? req.values.length\n                : 1;\n        if (res.numFailures === numBulkOps) {\n            return null;\n        }\n        var clone = __assign({}, req);\n        if (isArray(clone.keys)) {\n            clone.keys = clone.keys.filter(function (_, i) { return !(i in res.failures); });\n        }\n        if ('values' in clone && isArray(clone.values)) {\n            clone.values = clone.values.filter(function (_, i) { return !(i in res.failures); });\n        }\n        return clone;\n    }\n\n    function isAboveLower(key, range) {\n        return range.lower === undefined\n            ? true\n            : range.lowerOpen\n                ? cmp(key, range.lower) > 0\n                : cmp(key, range.lower) >= 0;\n    }\n    function isBelowUpper(key, range) {\n        return range.upper === undefined\n            ? true\n            : range.upperOpen\n                ? cmp(key, range.upper) < 0\n                : cmp(key, range.upper) <= 0;\n    }\n    function isWithinRange(key, range) {\n        return isAboveLower(key, range) && isBelowUpper(key, range);\n    }\n\n    function applyOptimisticOps(result, req, ops, table, cacheEntry, immutable) {\n        if (!ops || ops.length === 0)\n            return result;\n        var index = req.query.index;\n        var multiEntry = index.multiEntry;\n        var queryRange = req.query.range;\n        var primaryKey = table.schema.primaryKey;\n        var extractPrimKey = primaryKey.extractKey;\n        var extractIndex = index.extractKey;\n        var extractLowLevelIndex = (index.lowLevelIndex || index).extractKey;\n        var finalResult = ops.reduce(function (result, op) {\n            var modifedResult = result;\n            var includedValues = op.type === 'add' || op.type === 'put'\n                ? op.values.filter(function (v) {\n                    var key = extractIndex(v);\n                    return multiEntry && isArray(key)\n                        ? key.some(function (k) { return isWithinRange(k, queryRange); })\n                        : isWithinRange(key, queryRange);\n                }).map(function (v) {\n                    v = deepClone(v);\n                    if (immutable)\n                        Object.freeze(v);\n                    return v;\n                })\n                : [];\n            switch (op.type) {\n                case 'add':\n                    modifedResult = result.concat(req.values\n                        ? includedValues\n                        : includedValues.map(function (v) { return extractPrimKey(v); }));\n                    break;\n                case 'put':\n                    var keySet_1 = new RangeSet().addKeys(op.values.map(function (v) { return extractPrimKey(v); }));\n                    modifedResult = result\n                        .filter(function (item) {\n                        var key = req.values ? extractPrimKey(item) : item;\n                        return !rangesOverlap(new RangeSet(key), keySet_1);\n                    })\n                        .concat(req.values\n                        ? includedValues\n                        : includedValues.map(function (v) { return extractPrimKey(v); }));\n                    break;\n                case 'delete':\n                    var keysToDelete_1 = new RangeSet().addKeys(op.keys);\n                    modifedResult = result.filter(function (item) {\n                        var key = req.values ? extractPrimKey(item) : item;\n                        return !rangesOverlap(new RangeSet(key), keysToDelete_1);\n                    });\n                    break;\n                case 'deleteRange':\n                    var range_1 = op.range;\n                    modifedResult = result.filter(function (item) { return !isWithinRange(extractPrimKey(item), range_1); });\n                    break;\n            }\n            return modifedResult;\n        }, result);\n        if (finalResult === result)\n            return result;\n        finalResult.sort(function (a, b) {\n            return cmp(extractLowLevelIndex(a), extractLowLevelIndex(b)) ||\n                cmp(extractPrimKey(a), extractPrimKey(b));\n        });\n        if (req.limit && req.limit < Infinity) {\n            if (finalResult.length > req.limit) {\n                finalResult.length = req.limit;\n            }\n            else if (result.length === req.limit && finalResult.length < req.limit) {\n                cacheEntry.dirty = true;\n            }\n        }\n        return immutable ? Object.freeze(finalResult) : finalResult;\n    }\n\n    function areRangesEqual(r1, r2) {\n        return (cmp(r1.lower, r2.lower) === 0 &&\n            cmp(r1.upper, r2.upper) === 0 &&\n            !!r1.lowerOpen === !!r2.lowerOpen &&\n            !!r1.upperOpen === !!r2.upperOpen);\n    }\n\n    function compareLowers(lower1, lower2, lowerOpen1, lowerOpen2) {\n        if (lower1 === undefined)\n            return lower2 !== undefined ? -1 : 0;\n        if (lower2 === undefined)\n            return 1;\n        var c = cmp(lower1, lower2);\n        if (c === 0) {\n            if (lowerOpen1 && lowerOpen2)\n                return 0;\n            if (lowerOpen1)\n                return 1;\n            if (lowerOpen2)\n                return -1;\n        }\n        return c;\n    }\n    function compareUppers(upper1, upper2, upperOpen1, upperOpen2) {\n        if (upper1 === undefined)\n            return upper2 !== undefined ? 1 : 0;\n        if (upper2 === undefined)\n            return -1;\n        var c = cmp(upper1, upper2);\n        if (c === 0) {\n            if (upperOpen1 && upperOpen2)\n                return 0;\n            if (upperOpen1)\n                return -1;\n            if (upperOpen2)\n                return 1;\n        }\n        return c;\n    }\n    function isSuperRange(r1, r2) {\n        return (compareLowers(r1.lower, r2.lower, r1.lowerOpen, r2.lowerOpen) <= 0 &&\n            compareUppers(r1.upper, r2.upper, r1.upperOpen, r2.upperOpen) >= 0);\n    }\n\n    function findCompatibleQuery(dbName, tableName, type, req) {\n        var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n        if (!tblCache)\n            return [];\n        var queries = tblCache.queries[type];\n        if (!queries)\n            return [null, false, tblCache, null];\n        var indexName = req.query ? req.query.index.name : null;\n        var entries = queries[indexName || ''];\n        if (!entries)\n            return [null, false, tblCache, null];\n        switch (type) {\n            case 'query':\n                var equalEntry = entries.find(function (entry) {\n                    return entry.req.limit === req.limit &&\n                        entry.req.values === req.values &&\n                        areRangesEqual(entry.req.query.range, req.query.range);\n                });\n                if (equalEntry)\n                    return [\n                        equalEntry,\n                        true,\n                        tblCache,\n                        entries,\n                    ];\n                var superEntry = entries.find(function (entry) {\n                    var limit = 'limit' in entry.req ? entry.req.limit : Infinity;\n                    return (limit >= req.limit &&\n                        (req.values ? entry.req.values : true) &&\n                        isSuperRange(entry.req.query.range, req.query.range));\n                });\n                return [superEntry, false, tblCache, entries];\n            case 'count':\n                var countQuery = entries.find(function (entry) {\n                    return areRangesEqual(entry.req.query.range, req.query.range);\n                });\n                return [countQuery, !!countQuery, tblCache, entries];\n        }\n    }\n\n    function subscribeToCacheEntry(cacheEntry, container, requery, signal) {\n        cacheEntry.subscribers.add(requery);\n        signal.addEventListener(\"abort\", function () {\n            cacheEntry.subscribers.delete(requery);\n            if (cacheEntry.subscribers.size === 0) {\n                enqueForDeletion(cacheEntry, container);\n            }\n        });\n    }\n    function enqueForDeletion(cacheEntry, container) {\n        setTimeout(function () {\n            if (cacheEntry.subscribers.size === 0) {\n                delArrayItem(container, cacheEntry);\n            }\n        }, 3000);\n    }\n\n    var cacheMiddleware = {\n        stack: 'dbcore',\n        level: 0,\n        name: 'Cache',\n        create: function (core) {\n            var dbName = core.schema.name;\n            var coreMW = __assign(__assign({}, core), { transaction: function (stores, mode, options) {\n                    var idbtrans = core.transaction(stores, mode, options);\n                    if (mode === 'readwrite') {\n                        var ac_1 = new AbortController();\n                        var signal = ac_1.signal;\n                        var endTransaction = function (wasCommitted) { return function () {\n                            ac_1.abort();\n                            if (mode === 'readwrite') {\n                                var affectedSubscribers_1 = new Set();\n                                for (var _i = 0, stores_1 = stores; _i < stores_1.length; _i++) {\n                                    var storeName = stores_1[_i];\n                                    var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(storeName)];\n                                    if (tblCache) {\n                                        var table = core.table(storeName);\n                                        var ops = tblCache.optimisticOps.filter(function (op) { return op.trans === idbtrans; });\n                                        if (idbtrans._explicit && wasCommitted && idbtrans.mutatedParts) {\n                                            for (var _a = 0, _b = Object.values(tblCache.queries.query); _a < _b.length; _a++) {\n                                                var entries = _b[_a];\n                                                for (var _c = 0, _d = entries.slice(); _c < _d.length; _c++) {\n                                                    var entry = _d[_c];\n                                                    if (obsSetsOverlap(entry.obsSet, idbtrans.mutatedParts)) {\n                                                        delArrayItem(entries, entry);\n                                                        entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n                                                    }\n                                                }\n                                            }\n                                        }\n                                        else if (ops.length > 0) {\n                                            tblCache.optimisticOps = tblCache.optimisticOps.filter(function (op) { return op.trans !== idbtrans; });\n                                            for (var _e = 0, _f = Object.values(tblCache.queries.query); _e < _f.length; _e++) {\n                                                var entries = _f[_e];\n                                                for (var _g = 0, _h = entries.slice(); _g < _h.length; _g++) {\n                                                    var entry = _h[_g];\n                                                    if (entry.res != null &&\n                                                        idbtrans.mutatedParts\n    ) {\n                                                        if (wasCommitted && !entry.dirty) {\n                                                            var freezeResults = Object.isFrozen(entry.res);\n                                                            var modRes = applyOptimisticOps(entry.res, entry.req, ops, table, entry, freezeResults);\n                                                            if (entry.dirty) {\n                                                                delArrayItem(entries, entry);\n                                                                entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n                                                            }\n                                                            else if (modRes !== entry.res) {\n                                                                entry.res = modRes;\n                                                                entry.promise = DexiePromise.resolve({ result: modRes });\n                                                            }\n                                                        }\n                                                        else {\n                                                            if (entry.dirty) {\n                                                                delArrayItem(entries, entry);\n                                                            }\n                                                            entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                                affectedSubscribers_1.forEach(function (requery) { return requery(); });\n                            }\n                        }; };\n                        idbtrans.addEventListener('abort', endTransaction(false), {\n                            signal: signal,\n                        });\n                        idbtrans.addEventListener('error', endTransaction(false), {\n                            signal: signal,\n                        });\n                        idbtrans.addEventListener('complete', endTransaction(true), {\n                            signal: signal,\n                        });\n                    }\n                    return idbtrans;\n                }, table: function (tableName) {\n                    var downTable = core.table(tableName);\n                    var primKey = downTable.schema.primaryKey;\n                    var tableMW = __assign(__assign({}, downTable), { mutate: function (req) {\n                            var trans = PSD.trans;\n                            if (primKey.outbound ||\n                                trans.db._options.cache === 'disabled' ||\n                                trans.explicit\n                            ) {\n                                return downTable.mutate(req);\n                            }\n                            var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n                            if (!tblCache)\n                                return downTable.mutate(req);\n                            var promise = downTable.mutate(req);\n                            if ((req.type === 'add' || req.type === 'put') && (req.values.length >= 50 || getEffectiveKeys(primKey, req).some(function (key) { return key == null; }))) {\n                                promise.then(function (res) {\n                                    var reqWithResolvedKeys = __assign(__assign({}, req), { values: req.values.map(function (value, i) {\n                                            var _a;\n                                            var valueWithKey = ((_a = primKey.keyPath) === null || _a === void 0 ? void 0 : _a.includes('.'))\n                                                ? deepClone(value)\n                                                : __assign({}, value);\n                                            setByKeyPath(valueWithKey, primKey.keyPath, res.results[i]);\n                                            return valueWithKey;\n                                        }) });\n                                    var adjustedReq = adjustOptimisticFromFailures(tblCache, reqWithResolvedKeys, res);\n                                    tblCache.optimisticOps.push(adjustedReq);\n                                    queueMicrotask(function () { return req.mutatedParts && signalSubscribersLazily(req.mutatedParts); });\n                                });\n                            }\n                            else {\n                                tblCache.optimisticOps.push(req);\n                                req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n                                promise.then(function (res) {\n                                    if (res.numFailures > 0) {\n                                        delArrayItem(tblCache.optimisticOps, req);\n                                        var adjustedReq = adjustOptimisticFromFailures(tblCache, req, res);\n                                        if (adjustedReq) {\n                                            tblCache.optimisticOps.push(adjustedReq);\n                                        }\n                                        req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n                                    }\n                                });\n                                promise.catch(function () {\n                                    delArrayItem(tblCache.optimisticOps, req);\n                                    req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n                                });\n                            }\n                            return promise;\n                        }, query: function (req) {\n                            var _a;\n                            if (!isCachableContext(PSD, downTable) || !isCachableRequest(\"query\", req))\n                                return downTable.query(req);\n                            var freezeResults = ((_a = PSD.trans) === null || _a === void 0 ? void 0 : _a.db._options.cache) === 'immutable';\n                            var _b = PSD, requery = _b.requery, signal = _b.signal;\n                            var _c = findCompatibleQuery(dbName, tableName, 'query', req), cacheEntry = _c[0], exactMatch = _c[1], tblCache = _c[2], container = _c[3];\n                            if (cacheEntry && exactMatch) {\n                                cacheEntry.obsSet = req.obsSet;\n                            }\n                            else {\n                                var promise = downTable.query(req).then(function (res) {\n                                    var result = res.result;\n                                    if (cacheEntry)\n                                        cacheEntry.res = result;\n                                    if (freezeResults) {\n                                        for (var i = 0, l = result.length; i < l; ++i) {\n                                            Object.freeze(result[i]);\n                                        }\n                                        Object.freeze(result);\n                                    }\n                                    else {\n                                        res.result = deepClone(result);\n                                    }\n                                    return res;\n                                }).catch(function (error) {\n                                    if (container && cacheEntry)\n                                        delArrayItem(container, cacheEntry);\n                                    return Promise.reject(error);\n                                });\n                                cacheEntry = {\n                                    obsSet: req.obsSet,\n                                    promise: promise,\n                                    subscribers: new Set(),\n                                    type: 'query',\n                                    req: req,\n                                    dirty: false,\n                                };\n                                if (container) {\n                                    container.push(cacheEntry);\n                                }\n                                else {\n                                    container = [cacheEntry];\n                                    if (!tblCache) {\n                                        tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)] = {\n                                            queries: {\n                                                query: {},\n                                                count: {},\n                                            },\n                                            objs: new Map(),\n                                            optimisticOps: [],\n                                            unsignaledParts: {}\n                                        };\n                                    }\n                                    tblCache.queries.query[req.query.index.name || ''] = container;\n                                }\n                            }\n                            subscribeToCacheEntry(cacheEntry, container, requery, signal);\n                            return cacheEntry.promise.then(function (res) {\n                                return {\n                                    result: applyOptimisticOps(res.result, req, tblCache === null || tblCache === void 0 ? void 0 : tblCache.optimisticOps, downTable, cacheEntry, freezeResults),\n                                };\n                            });\n                        } });\n                    return tableMW;\n                } });\n            return coreMW;\n        },\n    };\n\n    function vipify(target, vipDb) {\n        return new Proxy(target, {\n            get: function (target, prop, receiver) {\n                if (prop === 'db')\n                    return vipDb;\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n\n    var Dexie$1 =  (function () {\n        function Dexie(name, options) {\n            var _this = this;\n            this._middlewares = {};\n            this.verno = 0;\n            var deps = Dexie.dependencies;\n            this._options = options = __assign({\n                addons: Dexie.addons, autoOpen: true,\n                indexedDB: deps.indexedDB, IDBKeyRange: deps.IDBKeyRange, cache: 'cloned' }, options);\n            this._deps = {\n                indexedDB: options.indexedDB,\n                IDBKeyRange: options.IDBKeyRange\n            };\n            var addons = options.addons;\n            this._dbSchema = {};\n            this._versions = [];\n            this._storeNames = [];\n            this._allTables = {};\n            this.idbdb = null;\n            this._novip = this;\n            var state = {\n                dbOpenError: null,\n                isBeingOpened: false,\n                onReadyBeingFired: null,\n                openComplete: false,\n                dbReadyResolve: nop,\n                dbReadyPromise: null,\n                cancelOpen: nop,\n                openCanceller: null,\n                autoSchema: true,\n                PR1398_maxLoop: 3,\n                autoOpen: options.autoOpen,\n            };\n            state.dbReadyPromise = new DexiePromise(function (resolve) {\n                state.dbReadyResolve = resolve;\n            });\n            state.openCanceller = new DexiePromise(function (_, reject) {\n                state.cancelOpen = reject;\n            });\n            this._state = state;\n            this.name = name;\n            this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", { ready: [promisableChain, nop] });\n            this.on.ready.subscribe = override(this.on.ready.subscribe, function (subscribe) {\n                return function (subscriber, bSticky) {\n                    Dexie.vip(function () {\n                        var state = _this._state;\n                        if (state.openComplete) {\n                            if (!state.dbOpenError)\n                                DexiePromise.resolve().then(subscriber);\n                            if (bSticky)\n                                subscribe(subscriber);\n                        }\n                        else if (state.onReadyBeingFired) {\n                            state.onReadyBeingFired.push(subscriber);\n                            if (bSticky)\n                                subscribe(subscriber);\n                        }\n                        else {\n                            subscribe(subscriber);\n                            var db_1 = _this;\n                            if (!bSticky)\n                                subscribe(function unsubscribe() {\n                                    db_1.on.ready.unsubscribe(subscriber);\n                                    db_1.on.ready.unsubscribe(unsubscribe);\n                                });\n                        }\n                    });\n                };\n            });\n            this.Collection = createCollectionConstructor(this);\n            this.Table = createTableConstructor(this);\n            this.Transaction = createTransactionConstructor(this);\n            this.Version = createVersionConstructor(this);\n            this.WhereClause = createWhereClauseConstructor(this);\n            this.on(\"versionchange\", function (ev) {\n                if (ev.newVersion > 0)\n                    console.warn(\"Another connection wants to upgrade database '\".concat(_this.name, \"'. Closing db now to resume the upgrade.\"));\n                else\n                    console.warn(\"Another connection wants to delete database '\".concat(_this.name, \"'. Closing db now to resume the delete request.\"));\n                _this.close({ disableAutoOpen: false });\n            });\n            this.on(\"blocked\", function (ev) {\n                if (!ev.newVersion || ev.newVersion < ev.oldVersion)\n                    console.warn(\"Dexie.delete('\".concat(_this.name, \"') was blocked\"));\n                else\n                    console.warn(\"Upgrade '\".concat(_this.name, \"' blocked by other connection holding version \").concat(ev.oldVersion / 10));\n            });\n            this._maxKey = getMaxKey(options.IDBKeyRange);\n            this._createTransaction = function (mode, storeNames, dbschema, parentTransaction) { return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction); };\n            this._fireOnBlocked = function (ev) {\n                _this.on(\"blocked\").fire(ev);\n                connections\n                    .filter(function (c) { return c.name === _this.name && c !== _this && !c._state.vcFired; })\n                    .map(function (c) { return c.on(\"versionchange\").fire(ev); });\n            };\n            this.use(cacheExistingValuesMiddleware);\n            this.use(cacheMiddleware);\n            this.use(observabilityMiddleware);\n            this.use(virtualIndexMiddleware);\n            this.use(hooksMiddleware);\n            var vipDB = new Proxy(this, {\n                get: function (_, prop, receiver) {\n                    if (prop === '_vip')\n                        return true;\n                    if (prop === 'table')\n                        return function (tableName) { return vipify(_this.table(tableName), vipDB); };\n                    var rv = Reflect.get(_, prop, receiver);\n                    if (rv instanceof Table)\n                        return vipify(rv, vipDB);\n                    if (prop === 'tables')\n                        return rv.map(function (t) { return vipify(t, vipDB); });\n                    if (prop === '_createTransaction')\n                        return function () {\n                            var tx = rv.apply(this, arguments);\n                            return vipify(tx, vipDB);\n                        };\n                    return rv;\n                }\n            });\n            this.vip = vipDB;\n            addons.forEach(function (addon) { return addon(_this); });\n        }\n        Dexie.prototype.version = function (versionNumber) {\n            if (isNaN(versionNumber) || versionNumber < 0.1)\n                throw new exceptions.Type(\"Given version is not a positive number\");\n            versionNumber = Math.round(versionNumber * 10) / 10;\n            if (this.idbdb || this._state.isBeingOpened)\n                throw new exceptions.Schema(\"Cannot add version when database is open\");\n            this.verno = Math.max(this.verno, versionNumber);\n            var versions = this._versions;\n            var versionInstance = versions.filter(function (v) { return v._cfg.version === versionNumber; })[0];\n            if (versionInstance)\n                return versionInstance;\n            versionInstance = new this.Version(versionNumber);\n            versions.push(versionInstance);\n            versions.sort(lowerVersionFirst);\n            versionInstance.stores({});\n            this._state.autoSchema = false;\n            return versionInstance;\n        };\n        Dexie.prototype._whenReady = function (fn) {\n            var _this = this;\n            return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise(function (resolve, reject) {\n                if (_this._state.openComplete) {\n                    return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));\n                }\n                if (!_this._state.isBeingOpened) {\n                    if (!_this._state.autoOpen) {\n                        reject(new exceptions.DatabaseClosed());\n                        return;\n                    }\n                    _this.open().catch(nop);\n                }\n                _this._state.dbReadyPromise.then(resolve, reject);\n            }).then(fn);\n        };\n        Dexie.prototype.use = function (_a) {\n            var stack = _a.stack, create = _a.create, level = _a.level, name = _a.name;\n            if (name)\n                this.unuse({ stack: stack, name: name });\n            var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n            middlewares.push({ stack: stack, create: create, level: level == null ? 10 : level, name: name });\n            middlewares.sort(function (a, b) { return a.level - b.level; });\n            return this;\n        };\n        Dexie.prototype.unuse = function (_a) {\n            var stack = _a.stack, name = _a.name, create = _a.create;\n            if (stack && this._middlewares[stack]) {\n                this._middlewares[stack] = this._middlewares[stack].filter(function (mw) {\n                    return create ? mw.create !== create :\n                        name ? mw.name !== name :\n                            false;\n                });\n            }\n            return this;\n        };\n        Dexie.prototype.open = function () {\n            var _this = this;\n            return usePSD(globalPSD,\n            function () { return dexieOpen(_this); });\n        };\n        Dexie.prototype._close = function () {\n            var state = this._state;\n            var idx = connections.indexOf(this);\n            if (idx >= 0)\n                connections.splice(idx, 1);\n            if (this.idbdb) {\n                try {\n                    this.idbdb.close();\n                }\n                catch (e) { }\n                this.idbdb = null;\n            }\n            if (!state.isBeingOpened) {\n                state.dbReadyPromise = new DexiePromise(function (resolve) {\n                    state.dbReadyResolve = resolve;\n                });\n                state.openCanceller = new DexiePromise(function (_, reject) {\n                    state.cancelOpen = reject;\n                });\n            }\n        };\n        Dexie.prototype.close = function (_a) {\n            var _b = _a === void 0 ? { disableAutoOpen: true } : _a, disableAutoOpen = _b.disableAutoOpen;\n            var state = this._state;\n            if (disableAutoOpen) {\n                if (state.isBeingOpened) {\n                    state.cancelOpen(new exceptions.DatabaseClosed());\n                }\n                this._close();\n                state.autoOpen = false;\n                state.dbOpenError = new exceptions.DatabaseClosed();\n            }\n            else {\n                this._close();\n                state.autoOpen = this._options.autoOpen ||\n                    state.isBeingOpened;\n                state.openComplete = false;\n                state.dbOpenError = null;\n            }\n        };\n        Dexie.prototype.delete = function (closeOptions) {\n            var _this = this;\n            if (closeOptions === void 0) { closeOptions = { disableAutoOpen: true }; }\n            var hasInvalidArguments = arguments.length > 0 && typeof arguments[0] !== 'object';\n            var state = this._state;\n            return new DexiePromise(function (resolve, reject) {\n                var doDelete = function () {\n                    _this.close(closeOptions);\n                    var req = _this._deps.indexedDB.deleteDatabase(_this.name);\n                    req.onsuccess = wrap(function () {\n                        _onDatabaseDeleted(_this._deps, _this.name);\n                        resolve();\n                    });\n                    req.onerror = eventRejectHandler(reject);\n                    req.onblocked = _this._fireOnBlocked;\n                };\n                if (hasInvalidArguments)\n                    throw new exceptions.InvalidArgument(\"Invalid closeOptions argument to db.delete()\");\n                if (state.isBeingOpened) {\n                    state.dbReadyPromise.then(doDelete);\n                }\n                else {\n                    doDelete();\n                }\n            });\n        };\n        Dexie.prototype.backendDB = function () {\n            return this.idbdb;\n        };\n        Dexie.prototype.isOpen = function () {\n            return this.idbdb !== null;\n        };\n        Dexie.prototype.hasBeenClosed = function () {\n            var dbOpenError = this._state.dbOpenError;\n            return dbOpenError && (dbOpenError.name === 'DatabaseClosed');\n        };\n        Dexie.prototype.hasFailed = function () {\n            return this._state.dbOpenError !== null;\n        };\n        Dexie.prototype.dynamicallyOpened = function () {\n            return this._state.autoSchema;\n        };\n        Object.defineProperty(Dexie.prototype, \"tables\", {\n            get: function () {\n                var _this = this;\n                return keys(this._allTables).map(function (name) { return _this._allTables[name]; });\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Dexie.prototype.transaction = function () {\n            var args = extractTransactionArgs.apply(this, arguments);\n            return this._transaction.apply(this, args);\n        };\n        Dexie.prototype._transaction = function (mode, tables, scopeFunc) {\n            var _this = this;\n            var parentTransaction = PSD.trans;\n            if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)\n                parentTransaction = null;\n            var onlyIfCompatible = mode.indexOf('?') !== -1;\n            mode = mode.replace('!', '').replace('?', '');\n            var idbMode, storeNames;\n            try {\n                storeNames = tables.map(function (table) {\n                    var storeName = table instanceof _this.Table ? table.name : table;\n                    if (typeof storeName !== 'string')\n                        throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n                    return storeName;\n                });\n                if (mode == \"r\" || mode === READONLY)\n                    idbMode = READONLY;\n                else if (mode == \"rw\" || mode == READWRITE)\n                    idbMode = READWRITE;\n                else\n                    throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n                if (parentTransaction) {\n                    if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n                        if (onlyIfCompatible) {\n                            parentTransaction = null;\n                        }\n                        else\n                            throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n                    }\n                    if (parentTransaction) {\n                        storeNames.forEach(function (storeName) {\n                            if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                                if (onlyIfCompatible) {\n                                    parentTransaction = null;\n                                }\n                                else\n                                    throw new exceptions.SubTransaction(\"Table \" + storeName +\n                                        \" not included in parent transaction.\");\n                            }\n                        });\n                    }\n                    if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n                        parentTransaction = null;\n                    }\n                }\n            }\n            catch (e) {\n                return parentTransaction ?\n                    parentTransaction._promise(null, function (_, reject) { reject(e); }) :\n                    rejection(e);\n            }\n            var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n            return (parentTransaction ?\n                parentTransaction._promise(idbMode, enterTransaction, \"lock\") :\n                PSD.trans ?\n                    usePSD(PSD.transless, function () { return _this._whenReady(enterTransaction); }) :\n                    this._whenReady(enterTransaction));\n        };\n        Dexie.prototype.table = function (tableName) {\n            if (!hasOwn(this._allTables, tableName)) {\n                throw new exceptions.InvalidTable(\"Table \".concat(tableName, \" does not exist\"));\n            }\n            return this._allTables[tableName];\n        };\n        return Dexie;\n    }());\n\n    var symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol\n        ? Symbol.observable\n        : \"@@observable\";\n    var Observable =  (function () {\n        function Observable(subscribe) {\n            this._subscribe = subscribe;\n        }\n        Observable.prototype.subscribe = function (x, error, complete) {\n            return this._subscribe(!x || typeof x === \"function\" ? { next: x, error: error, complete: complete } : x);\n        };\n        Observable.prototype[symbolObservable] = function () {\n            return this;\n        };\n        return Observable;\n    }());\n\n    var domDeps;\n    try {\n        domDeps = {\n            indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n            IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n        };\n    }\n    catch (e) {\n        domDeps = { indexedDB: null, IDBKeyRange: null };\n    }\n\n    function liveQuery(querier) {\n        var hasValue = false;\n        var currentValue;\n        var observable = new Observable(function (observer) {\n            var scopeFuncIsAsync = isAsyncFunction(querier);\n            function execute(ctx) {\n                var wasRootExec = beginMicroTickScope();\n                try {\n                    if (scopeFuncIsAsync) {\n                        incrementExpectedAwaits();\n                    }\n                    var rv = newScope(querier, ctx);\n                    if (scopeFuncIsAsync) {\n                        rv = rv.finally(decrementExpectedAwaits);\n                    }\n                    return rv;\n                }\n                finally {\n                    wasRootExec && endMicroTickScope();\n                }\n            }\n            var closed = false;\n            var abortController;\n            var accumMuts = {};\n            var currentObs = {};\n            var subscription = {\n                get closed() {\n                    return closed;\n                },\n                unsubscribe: function () {\n                    if (closed)\n                        return;\n                    closed = true;\n                    if (abortController)\n                        abortController.abort();\n                    if (startedListening)\n                        globalEvents.storagemutated.unsubscribe(mutationListener);\n                },\n            };\n            observer.start && observer.start(subscription);\n            var startedListening = false;\n            var doQuery = function () { return execInGlobalContext(_doQuery); };\n            function shouldNotify() {\n                return obsSetsOverlap(currentObs, accumMuts);\n            }\n            var mutationListener = function (parts) {\n                extendObservabilitySet(accumMuts, parts);\n                if (shouldNotify()) {\n                    doQuery();\n                }\n            };\n            var _doQuery = function () {\n                if (closed ||\n                    !domDeps.indexedDB)\n                 {\n                    return;\n                }\n                accumMuts = {};\n                var subscr = {};\n                if (abortController)\n                    abortController.abort();\n                abortController = new AbortController();\n                var ctx = {\n                    subscr: subscr,\n                    signal: abortController.signal,\n                    requery: doQuery,\n                    querier: querier,\n                    trans: null\n                };\n                var ret = execute(ctx);\n                Promise.resolve(ret).then(function (result) {\n                    hasValue = true;\n                    currentValue = result;\n                    if (closed || ctx.signal.aborted) {\n                        return;\n                    }\n                    accumMuts = {};\n                    currentObs = subscr;\n                    if (!objectIsEmpty(currentObs) && !startedListening) {\n                        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n                        startedListening = true;\n                    }\n                    execInGlobalContext(function () { return !closed && observer.next && observer.next(result); });\n                }, function (err) {\n                    hasValue = false;\n                    if (!['DatabaseClosedError', 'AbortError'].includes(err === null || err === void 0 ? void 0 : err.name)) {\n                        if (!closed)\n                            execInGlobalContext(function () {\n                                if (closed)\n                                    return;\n                                observer.error && observer.error(err);\n                            });\n                    }\n                });\n            };\n            setTimeout(doQuery, 0);\n            return subscription;\n        });\n        observable.hasValue = function () { return hasValue; };\n        observable.getValue = function () { return currentValue; };\n        return observable;\n    }\n\n    var Dexie = Dexie$1;\n    props(Dexie, __assign(__assign({}, fullNameExceptions), {\n        delete: function (databaseName) {\n            var db = new Dexie(databaseName, { addons: [] });\n            return db.delete();\n        },\n        exists: function (name) {\n            return new Dexie(name, { addons: [] }).open().then(function (db) {\n                db.close();\n                return true;\n            }).catch('NoSuchDatabaseError', function () { return false; });\n        },\n        getDatabaseNames: function (cb) {\n            try {\n                return getDatabaseNames(Dexie.dependencies).then(cb);\n            }\n            catch (_a) {\n                return rejection(new exceptions.MissingAPI());\n            }\n        },\n        defineClass: function () {\n            function Class(content) {\n                extend(this, content);\n            }\n            return Class;\n        }, ignoreTransaction: function (scopeFunc) {\n            return PSD.trans ?\n                usePSD(PSD.transless, scopeFunc) :\n                scopeFunc();\n        }, vip: vip, async: function (generatorFn) {\n            return function () {\n                try {\n                    var rv = awaitIterator(generatorFn.apply(this, arguments));\n                    if (!rv || typeof rv.then !== 'function')\n                        return DexiePromise.resolve(rv);\n                    return rv;\n                }\n                catch (e) {\n                    return rejection(e);\n                }\n            };\n        }, spawn: function (generatorFn, args, thiz) {\n            try {\n                var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n                if (!rv || typeof rv.then !== 'function')\n                    return DexiePromise.resolve(rv);\n                return rv;\n            }\n            catch (e) {\n                return rejection(e);\n            }\n        },\n        currentTransaction: {\n            get: function () { return PSD.trans || null; }\n        }, waitFor: function (promiseOrFunction, optionalTimeout) {\n            var promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?\n                Dexie.ignoreTransaction(promiseOrFunction) :\n                promiseOrFunction)\n                .timeout(optionalTimeout || 60000);\n            return PSD.trans ?\n                PSD.trans.waitFor(promise) :\n                promise;\n        },\n        Promise: DexiePromise,\n        debug: {\n            get: function () { return debug; },\n            set: function (value) {\n                setDebug(value);\n            }\n        },\n        derive: derive, extend: extend, props: props, override: override,\n        Events: Events, on: globalEvents, liveQuery: liveQuery, extendObservabilitySet: extendObservabilitySet,\n        getByKeyPath: getByKeyPath, setByKeyPath: setByKeyPath, delByKeyPath: delByKeyPath, shallowClone: shallowClone, deepClone: deepClone, getObjectDiff: getObjectDiff, cmp: cmp, asap: asap$1,\n        minKey: minKey,\n        addons: [],\n        connections: connections,\n        errnames: errnames,\n        dependencies: domDeps, cache: cache,\n        semVer: DEXIE_VERSION, version: DEXIE_VERSION.split('.')\n            .map(function (n) { return parseInt(n); })\n            .reduce(function (p, c, i) { return p + (c / Math.pow(10, i * 2)); }) }));\n    Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\n\n    if (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (updatedParts) {\n            if (!propagatingLocally) {\n                var event_1;\n                event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n                    detail: updatedParts\n                });\n                propagatingLocally = true;\n                dispatchEvent(event_1);\n                propagatingLocally = false;\n            }\n        });\n        addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function (_a) {\n            var detail = _a.detail;\n            if (!propagatingLocally) {\n                propagateLocally(detail);\n            }\n        });\n    }\n    function propagateLocally(updateParts) {\n        var wasMe = propagatingLocally;\n        try {\n            propagatingLocally = true;\n            globalEvents.storagemutated.fire(updateParts);\n            signalSubscribersNow(updateParts, true);\n        }\n        finally {\n            propagatingLocally = wasMe;\n        }\n    }\n    var propagatingLocally = false;\n\n    var bc;\n    var createBC = function () { };\n    if (typeof BroadcastChannel !== 'undefined') {\n        createBC = function () {\n            bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n            bc.onmessage = function (ev) { return ev.data && propagateLocally(ev.data); };\n        };\n        createBC();\n        if (typeof bc.unref === 'function') {\n            bc.unref();\n        }\n        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (changedParts) {\n            if (!propagatingLocally) {\n                bc.postMessage(changedParts);\n            }\n        });\n    }\n\n    if (typeof addEventListener !== 'undefined') {\n        addEventListener('pagehide', function (event) {\n            if (!Dexie$1.disableBfCache && event.persisted) {\n                if (debug)\n                    console.debug('Dexie: handling persisted pagehide');\n                bc === null || bc === void 0 ? void 0 : bc.close();\n                for (var _i = 0, connections_1 = connections; _i < connections_1.length; _i++) {\n                    var db = connections_1[_i];\n                    db.close({ disableAutoOpen: false });\n                }\n            }\n        });\n        addEventListener('pageshow', function (event) {\n            if (!Dexie$1.disableBfCache && event.persisted) {\n                if (debug)\n                    console.debug('Dexie: handling persisted pageshow');\n                createBC();\n                propagateLocally({ all: new RangeSet(-Infinity, [[]]) });\n            }\n        });\n    }\n\n    function add(value) {\n        return new PropModification({ add: value });\n    }\n\n    function remove(value) {\n        return new PropModification({ remove: value });\n    }\n\n    function replacePrefix(a, b) {\n        return new PropModification({ replacePrefix: [a, b] });\n    }\n\n    DexiePromise.rejectionMapper = mapError;\n    setDebug(debug);\n\n    var namedExports = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        Dexie: Dexie$1,\n        liveQuery: liveQuery,\n        Entity: Entity,\n        cmp: cmp,\n        PropModSymbol: PropModSymbol,\n        PropModification: PropModification,\n        replacePrefix: replacePrefix,\n        add: add,\n        remove: remove,\n        'default': Dexie$1,\n        RangeSet: RangeSet,\n        mergeRanges: mergeRanges,\n        rangesOverlap: rangesOverlap\n    });\n\n    __assign(Dexie$1, namedExports, { default: Dexie$1 });\n\n    return Dexie$1;\n\n}));\n//# sourceMappingURL=dexie.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZGV4aWUvZGlzdC9kZXhpZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUE0RDtBQUNoRSxJQUFJLENBQ29HO0FBQ3hHLENBQUMsdUJBQXVCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixPQUFPO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyRUFBMkU7QUFDekYsY0FBYyw2REFBNkQ7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQseUNBQXlDLHVDQUF1QyxHQUFHO0FBQ25GOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwyQkFBMkI7QUFDekY7QUFDQSwrQkFBK0Isd0JBQXdCO0FBQ3ZEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxzQ0FBc0MsWUFBWTtBQUNsRDs7QUFFQTtBQUNBLHNDQUFzQyxlQUFlO0FBQ3JEOztBQUVBO0FBQ0Esc0NBQXNDLHVCQUF1QjtBQUM3RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsc0NBQXNDLGtCQUFrQjs7QUFFeEQ7O0FBRUEsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd29vcG9zLy4vbm9kZV9tb2R1bGVzL2RleGllL2Rpc3QvZGV4aWUuanM/NGExNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogRGV4aWUuanMgLSBhIG1pbmltYWxpc3RpYyB3cmFwcGVyIGZvciBJbmRleGVkREJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQnkgRGF2aWQgRmFobGFuZGVyLCBkYXZpZC5mYWhsYW5kZXJAZ21haWwuY29tXG4gKlxuICogVmVyc2lvbiA0LjAuNywgU3VuIE1heSAyNiAyMDI0XG4gKlxuICogaHR0cHM6Ly9kZXhpZS5vcmdcbiAqXG4gKiBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgSmFudWFyeSAyMDA0LCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvXG4gKi9cbiBcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLkRleGllID0gZmFjdG9yeSgpKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICAgIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuICAgIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG4gICAgUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXG4gICAgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxuICAgIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuICAgIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXG4gICAgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxuICAgIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH1cbiAgICB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcbiAgICAgICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbiAgICB9XG5cbiAgICB2YXIgX2dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOlxuICAgICAgICB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDpcbiAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDpcbiAgICAgICAgICAgICAgICBnbG9iYWw7XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzO1xuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiAgICBpZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmICFfZ2xvYmFsLlByb21pc2UpIHtcbiAgICAgICAgX2dsb2JhbC5Qcm9taXNlID0gUHJvbWlzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXh0ZW5kKG9iaiwgZXh0ZW5zaW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIGtleXMoZXh0ZW5zaW9uKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gZXh0ZW5zaW9uW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gICAgdmFyIF9oYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgICBmdW5jdGlvbiBoYXNPd24ob2JqLCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBfaGFzT3duLmNhbGwob2JqLCBwcm9wKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvcHMocHJvdG8sIGV4dGVuc2lvbikge1xuICAgICAgICBpZiAodHlwZW9mIGV4dGVuc2lvbiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbihnZXRQcm90byhwcm90bykpO1xuICAgICAgICAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgPyBrZXlzIDogUmVmbGVjdC5vd25LZXlzKShleHRlbnNpb24pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgc2V0UHJvcChwcm90bywga2V5LCBleHRlbnNpb25ba2V5XSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gICAgZnVuY3Rpb24gc2V0UHJvcChvYmosIHByb3AsIGZ1bmN0aW9uT3JHZXRTZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBleHRlbmQoZnVuY3Rpb25PckdldFNldCAmJiBoYXNPd24oZnVuY3Rpb25PckdldFNldCwgXCJnZXRcIikgJiYgdHlwZW9mIGZ1bmN0aW9uT3JHZXRTZXQuZ2V0ID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgIHsgZ2V0OiBmdW5jdGlvbk9yR2V0U2V0LmdldCwgc2V0OiBmdW5jdGlvbk9yR2V0U2V0LnNldCwgY29uZmlndXJhYmxlOiB0cnVlIH0gOlxuICAgICAgICAgICAgeyB2YWx1ZTogZnVuY3Rpb25PckdldFNldCwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9LCBvcHRpb25zKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlcml2ZShDaGlsZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogZnVuY3Rpb24gKFBhcmVudCkge1xuICAgICAgICAgICAgICAgIENoaWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgc2V0UHJvcChDaGlsZC5wcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgQ2hpbGQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZDogcHJvcHMuYmluZChudWxsLCBDaGlsZC5wcm90b3R5cGUpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgZnVuY3Rpb24gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCkge1xuICAgICAgICB2YXIgcGQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKTtcbiAgICAgICAgdmFyIHByb3RvO1xuICAgICAgICByZXR1cm4gcGQgfHwgKHByb3RvID0gZ2V0UHJvdG8ob2JqKSkgJiYgZ2V0UHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBwcm9wKTtcbiAgICB9XG4gICAgdmFyIF9zbGljZSA9IFtdLnNsaWNlO1xuICAgIGZ1bmN0aW9uIHNsaWNlKGFyZ3MsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIF9zbGljZS5jYWxsKGFyZ3MsIHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvdmVycmlkZShvcmlnRnVuYywgb3ZlcnJpZGVkRmFjdG9yeSkge1xuICAgICAgICByZXR1cm4gb3ZlcnJpZGVkRmFjdG9yeShvcmlnRnVuYyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydChiKSB7XG4gICAgICAgIGlmICghYilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzc2VydGlvbiBGYWlsZWRcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzYXAkMShmbikge1xuICAgICAgICBpZiAoX2dsb2JhbC5zZXRJbW1lZGlhdGUpXG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJyYXlUb09iamVjdChhcnJheSwgZXh0cmFjdG9yKSB7XG4gICAgICAgIHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgaXRlbSwgaSkge1xuICAgICAgICAgICAgdmFyIG5hbWVBbmRWYWx1ZSA9IGV4dHJhY3RvcihpdGVtLCBpKTtcbiAgICAgICAgICAgIGlmIChuYW1lQW5kVmFsdWUpXG4gICAgICAgICAgICAgICAgcmVzdWx0W25hbWVBbmRWYWx1ZVswXV0gPSBuYW1lQW5kVmFsdWVbMV07XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyAmJiBoYXNPd24ob2JqLCBrZXlQYXRoKSlcbiAgICAgICAgICAgIHJldHVybiBvYmpba2V5UGF0aF07XG4gICAgICAgIGlmICgha2V5UGF0aClcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5UGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBydiA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlQYXRoLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBnZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoW2ldKTtcbiAgICAgICAgICAgICAgICBydi5wdXNoKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBlcmlvZCA9IGtleVBhdGguaW5kZXhPZignLicpO1xuICAgICAgICBpZiAocGVyaW9kICE9PSAtMSkge1xuICAgICAgICAgICAgdmFyIGlubmVyT2JqID0gb2JqW2tleVBhdGguc3Vic3RyKDAsIHBlcmlvZCldO1xuICAgICAgICAgICAgcmV0dXJuIGlubmVyT2JqID09IG51bGwgPyB1bmRlZmluZWQgOiBnZXRCeUtleVBhdGgoaW5uZXJPYmosIGtleVBhdGguc3Vic3RyKHBlcmlvZCArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIW9iaiB8fCBrZXlQYXRoID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICgnaXNGcm96ZW4nIGluIE9iamVjdCAmJiBPYmplY3QuaXNGcm96ZW4ob2JqKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJyAmJiAnbGVuZ3RoJyBpbiBrZXlQYXRoKSB7XG4gICAgICAgICAgICBhc3NlcnQodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiAnbGVuZ3RoJyBpbiB2YWx1ZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleVBhdGgubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aFtpXSwgdmFsdWVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBlcmlvZCA9IGtleVBhdGguaW5kZXhPZignLicpO1xuICAgICAgICAgICAgaWYgKHBlcmlvZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudEtleVBhdGggPSBrZXlQYXRoLnN1YnN0cigwLCBwZXJpb2QpO1xuICAgICAgICAgICAgICAgIHZhciByZW1haW5pbmdLZXlQYXRoID0ga2V5UGF0aC5zdWJzdHIocGVyaW9kICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbWFpbmluZ0tleVBhdGggPT09IFwiXCIpXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShvYmopICYmICFpc05hTihwYXJzZUludChjdXJyZW50S2V5UGF0aCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5zcGxpY2UoY3VycmVudEtleVBhdGgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpbY3VycmVudEtleVBhdGhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtjdXJyZW50S2V5UGF0aF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlubmVyT2JqID0gb2JqW2N1cnJlbnRLZXlQYXRoXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbm5lck9iaiB8fCAhaGFzT3duKG9iaiwgY3VycmVudEtleVBhdGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJPYmogPSAob2JqW2N1cnJlbnRLZXlQYXRoXSA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKGlubmVyT2JqLCByZW1haW5pbmdLZXlQYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkob2JqKSAmJiAhaXNOYU4ocGFyc2VJbnQoa2V5UGF0aCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnNwbGljZShrZXlQYXRoLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9ialtrZXlQYXRoXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmpba2V5UGF0aF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZWxCeUtleVBhdGgob2JqLCBrZXlQYXRoKSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoLCB1bmRlZmluZWQpO1xuICAgICAgICBlbHNlIGlmICgnbGVuZ3RoJyBpbiBrZXlQYXRoKVxuICAgICAgICAgICAgW10ubWFwLmNhbGwoa2V5UGF0aCwgZnVuY3Rpb24gKGtwKSB7XG4gICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga3AsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hhbGxvd0Nsb25lKG9iaikge1xuICAgICAgICB2YXIgcnYgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgbSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24ob2JqLCBtKSlcbiAgICAgICAgICAgICAgICBydlttXSA9IG9ialttXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgfVxuICAgIHZhciBjb25jYXQgPSBbXS5jb25jYXQ7XG4gICAgZnVuY3Rpb24gZmxhdHRlbihhKSB7XG4gICAgICAgIHJldHVybiBjb25jYXQuYXBwbHkoW10sIGEpO1xuICAgIH1cbiAgICB2YXIgaW50cmluc2ljVHlwZU5hbWVzID0gXCJCaWdVaW50NjRBcnJheSxCaWdJbnQ2NEFycmF5LEFycmF5LEJvb2xlYW4sU3RyaW5nLERhdGUsUmVnRXhwLEJsb2IsRmlsZSxGaWxlTGlzdCxGaWxlU3lzdGVtRmlsZUhhbmRsZSxGaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlLEFycmF5QnVmZmVyLERhdGFWaWV3LFVpbnQ4Q2xhbXBlZEFycmF5LEltYWdlQml0bWFwLEltYWdlRGF0YSxNYXAsU2V0LENyeXB0b0tleVwiXG4gICAgICAgIC5zcGxpdCgnLCcpLmNvbmNhdChmbGF0dGVuKFs4LCAxNiwgMzIsIDY0XS5tYXAoZnVuY3Rpb24gKG51bSkgeyByZXR1cm4gW1wiSW50XCIsIFwiVWludFwiLCBcIkZsb2F0XCJdLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdCArIG51bSArIFwiQXJyYXlcIjsgfSk7IH0pKSkuZmlsdGVyKGZ1bmN0aW9uICh0KSB7IHJldHVybiBfZ2xvYmFsW3RdOyB9KTtcbiAgICB2YXIgaW50cmluc2ljVHlwZXMgPSBuZXcgU2V0KGludHJpbnNpY1R5cGVOYW1lcy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIF9nbG9iYWxbdF07IH0pKTtcbiAgICBmdW5jdGlvbiBjbG9uZVNpbXBsZU9iamVjdFRyZWUobykge1xuICAgICAgICB2YXIgcnYgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgayBpbiBvKVxuICAgICAgICAgICAgaWYgKGhhc093bihvLCBrKSkge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gb1trXTtcbiAgICAgICAgICAgICAgICBydltrXSA9ICF2IHx8IHR5cGVvZiB2ICE9PSAnb2JqZWN0JyB8fCBpbnRyaW5zaWNUeXBlcy5oYXModi5jb25zdHJ1Y3RvcikgPyB2IDogY2xvbmVTaW1wbGVPYmplY3RUcmVlKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9iamVjdElzRW1wdHkobykge1xuICAgICAgICBmb3IgKHZhciBrIGluIG8pXG4gICAgICAgICAgICBpZiAoaGFzT3duKG8sIGspKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBjaXJjdWxhclJlZnMgPSBudWxsO1xuICAgIGZ1bmN0aW9uIGRlZXBDbG9uZShhbnkpIHtcbiAgICAgICAgY2lyY3VsYXJSZWZzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdmFyIHJ2ID0gaW5uZXJEZWVwQ2xvbmUoYW55KTtcbiAgICAgICAgY2lyY3VsYXJSZWZzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbm5lckRlZXBDbG9uZSh4KSB7XG4gICAgICAgIGlmICgheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgdmFyIHJ2ID0gY2lyY3VsYXJSZWZzLmdldCh4KTtcbiAgICAgICAgaWYgKHJ2KVxuICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICBpZiAoaXNBcnJheSh4KSkge1xuICAgICAgICAgICAgcnYgPSBbXTtcbiAgICAgICAgICAgIGNpcmN1bGFyUmVmcy5zZXQoeCwgcnYpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB4Lmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgIHJ2LnB1c2goaW5uZXJEZWVwQ2xvbmUoeFtpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGludHJpbnNpY1R5cGVzLmhhcyh4LmNvbnN0cnVjdG9yKSkge1xuICAgICAgICAgICAgcnYgPSB4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByb3RvID0gZ2V0UHJvdG8oeCk7XG4gICAgICAgICAgICBydiA9IHByb3RvID09PSBPYmplY3QucHJvdG90eXBlID8ge30gOiBPYmplY3QuY3JlYXRlKHByb3RvKTtcbiAgICAgICAgICAgIGNpcmN1bGFyUmVmcy5zZXQoeCwgcnYpO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiB4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093bih4LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICBydltwcm9wXSA9IGlubmVyRGVlcENsb25lKHhbcHJvcF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgfVxuICAgIHZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nVGFnKG8pIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICAgIH1cbiAgICB2YXIgaXRlcmF0b3JTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICAgIFN5bWJvbC5pdGVyYXRvciA6XG4gICAgICAgICdAQGl0ZXJhdG9yJztcbiAgICB2YXIgZ2V0SXRlcmF0b3JPZiA9IHR5cGVvZiBpdGVyYXRvclN5bWJvbCA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICByZXR1cm4geCAhPSBudWxsICYmIChpID0geFtpdGVyYXRvclN5bWJvbF0pICYmIGkuYXBwbHkoeCk7XG4gICAgfSA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgZnVuY3Rpb24gZGVsQXJyYXlJdGVtKGEsIHgpIHtcbiAgICAgICAgdmFyIGkgPSBhLmluZGV4T2YoeCk7XG4gICAgICAgIGlmIChpID49IDApXG4gICAgICAgICAgICBhLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuIGkgPj0gMDtcbiAgICB9XG4gICAgdmFyIE5PX0NIQVJfQVJSQVkgPSB7fTtcbiAgICBmdW5jdGlvbiBnZXRBcnJheU9mKGFycmF5TGlrZSkge1xuICAgICAgICB2YXIgaSwgYSwgeCwgaXQ7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheShhcnJheUxpa2UpKVxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheUxpa2Uuc2xpY2UoKTtcbiAgICAgICAgICAgIGlmICh0aGlzID09PSBOT19DSEFSX0FSUkFZICYmIHR5cGVvZiBhcnJheUxpa2UgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHJldHVybiBbYXJyYXlMaWtlXTtcbiAgICAgICAgICAgIGlmICgoaXQgPSBnZXRJdGVyYXRvck9mKGFycmF5TGlrZSkpKSB7XG4gICAgICAgICAgICAgICAgYSA9IFtdO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoeCA9IGl0Lm5leHQoKSksICF4LmRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGEucHVzaCh4LnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcnJheUxpa2UgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gW2FycmF5TGlrZV07XG4gICAgICAgICAgICBpID0gYXJyYXlMaWtlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBhID0gbmV3IEFycmF5KGkpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgICAgICAgIGFbaV0gPSBhcnJheUxpa2VbaV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2FycmF5TGlrZV07XG4gICAgICAgIH1cbiAgICAgICAgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGEgPSBuZXcgQXJyYXkoaSk7XG4gICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICBhW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgdmFyIGlzQXN5bmNGdW5jdGlvbiA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbltTeW1ib2wudG9TdHJpbmdUYWddID09PSAnQXN5bmNGdW5jdGlvbic7IH1cbiAgICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcblxuICAgIHZhciBkZXhpZUVycm9yTmFtZXMgPSBbXG4gICAgICAgICdNb2RpZnknLFxuICAgICAgICAnQnVsaycsXG4gICAgICAgICdPcGVuRmFpbGVkJyxcbiAgICAgICAgJ1ZlcnNpb25DaGFuZ2UnLFxuICAgICAgICAnU2NoZW1hJyxcbiAgICAgICAgJ1VwZ3JhZGUnLFxuICAgICAgICAnSW52YWxpZFRhYmxlJyxcbiAgICAgICAgJ01pc3NpbmdBUEknLFxuICAgICAgICAnTm9TdWNoRGF0YWJhc2UnLFxuICAgICAgICAnSW52YWxpZEFyZ3VtZW50JyxcbiAgICAgICAgJ1N1YlRyYW5zYWN0aW9uJyxcbiAgICAgICAgJ1Vuc3VwcG9ydGVkJyxcbiAgICAgICAgJ0ludGVybmFsJyxcbiAgICAgICAgJ0RhdGFiYXNlQ2xvc2VkJyxcbiAgICAgICAgJ1ByZW1hdHVyZUNvbW1pdCcsXG4gICAgICAgICdGb3JlaWduQXdhaXQnXG4gICAgXTtcbiAgICB2YXIgaWRiRG9tRXJyb3JOYW1lcyA9IFtcbiAgICAgICAgJ1Vua25vd24nLFxuICAgICAgICAnQ29uc3RyYWludCcsXG4gICAgICAgICdEYXRhJyxcbiAgICAgICAgJ1RyYW5zYWN0aW9uSW5hY3RpdmUnLFxuICAgICAgICAnUmVhZE9ubHknLFxuICAgICAgICAnVmVyc2lvbicsXG4gICAgICAgICdOb3RGb3VuZCcsXG4gICAgICAgICdJbnZhbGlkU3RhdGUnLFxuICAgICAgICAnSW52YWxpZEFjY2VzcycsXG4gICAgICAgICdBYm9ydCcsXG4gICAgICAgICdUaW1lb3V0JyxcbiAgICAgICAgJ1F1b3RhRXhjZWVkZWQnLFxuICAgICAgICAnU3ludGF4JyxcbiAgICAgICAgJ0RhdGFDbG9uZSdcbiAgICBdO1xuICAgIHZhciBlcnJvckxpc3QgPSBkZXhpZUVycm9yTmFtZXMuY29uY2F0KGlkYkRvbUVycm9yTmFtZXMpO1xuICAgIHZhciBkZWZhdWx0VGV4dHMgPSB7XG4gICAgICAgIFZlcnNpb25DaGFuZ2VkOiBcIkRhdGFiYXNlIHZlcnNpb24gY2hhbmdlZCBieSBvdGhlciBkYXRhYmFzZSBjb25uZWN0aW9uXCIsXG4gICAgICAgIERhdGFiYXNlQ2xvc2VkOiBcIkRhdGFiYXNlIGhhcyBiZWVuIGNsb3NlZFwiLFxuICAgICAgICBBYm9ydDogXCJUcmFuc2FjdGlvbiBhYm9ydGVkXCIsXG4gICAgICAgIFRyYW5zYWN0aW9uSW5hY3RpdmU6IFwiVHJhbnNhY3Rpb24gaGFzIGFscmVhZHkgY29tcGxldGVkIG9yIGZhaWxlZFwiLFxuICAgICAgICBNaXNzaW5nQVBJOiBcIkluZGV4ZWREQiBBUEkgbWlzc2luZy4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vdGlueXVybC5jb20veTJ1dXZza2JcIlxuICAgIH07XG4gICAgZnVuY3Rpb24gRGV4aWVFcnJvcihuYW1lLCBtc2cpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbXNnO1xuICAgIH1cbiAgICBkZXJpdmUoRGV4aWVFcnJvcikuZnJvbShFcnJvcikuZXh0ZW5kKHtcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZTsgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGdldE11bHRpRXJyb3JNZXNzYWdlKG1zZywgZmFpbHVyZXMpIHtcbiAgICAgICAgcmV0dXJuIG1zZyArIFwiLiBFcnJvcnM6IFwiICsgT2JqZWN0LmtleXMoZmFpbHVyZXMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGZhaWx1cmVzW2tleV0udG9TdHJpbmcoKTsgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHYsIGksIHMpIHsgcmV0dXJuIHMuaW5kZXhPZih2KSA9PT0gaTsgfSlcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTW9kaWZ5RXJyb3IobXNnLCBmYWlsdXJlcywgc3VjY2Vzc0NvdW50LCBmYWlsZWRLZXlzKSB7XG4gICAgICAgIHRoaXMuZmFpbHVyZXMgPSBmYWlsdXJlcztcbiAgICAgICAgdGhpcy5mYWlsZWRLZXlzID0gZmFpbGVkS2V5cztcbiAgICAgICAgdGhpcy5zdWNjZXNzQ291bnQgPSBzdWNjZXNzQ291bnQ7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGdldE11bHRpRXJyb3JNZXNzYWdlKG1zZywgZmFpbHVyZXMpO1xuICAgIH1cbiAgICBkZXJpdmUoTW9kaWZ5RXJyb3IpLmZyb20oRGV4aWVFcnJvcik7XG4gICAgZnVuY3Rpb24gQnVsa0Vycm9yKG1zZywgZmFpbHVyZXMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJCdWxrRXJyb3JcIjtcbiAgICAgICAgdGhpcy5mYWlsdXJlcyA9IE9iamVjdC5rZXlzKGZhaWx1cmVzKS5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gZmFpbHVyZXNbcG9zXTsgfSk7XG4gICAgICAgIHRoaXMuZmFpbHVyZXNCeVBvcyA9IGZhaWx1cmVzO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNdWx0aUVycm9yTWVzc2FnZShtc2csIHRoaXMuZmFpbHVyZXMpO1xuICAgIH1cbiAgICBkZXJpdmUoQnVsa0Vycm9yKS5mcm9tKERleGllRXJyb3IpO1xuICAgIHZhciBlcnJuYW1lcyA9IGVycm9yTGlzdC5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgbmFtZSkgeyByZXR1cm4gKG9ialtuYW1lXSA9IG5hbWUgKyBcIkVycm9yXCIsIG9iaik7IH0sIHt9KTtcbiAgICB2YXIgQmFzZUV4Y2VwdGlvbiA9IERleGllRXJyb3I7XG4gICAgdmFyIGV4Y2VwdGlvbnMgPSBlcnJvckxpc3QucmVkdWNlKGZ1bmN0aW9uIChvYmosIG5hbWUpIHtcbiAgICAgICAgdmFyIGZ1bGxOYW1lID0gbmFtZSArIFwiRXJyb3JcIjtcbiAgICAgICAgZnVuY3Rpb24gRGV4aWVFcnJvcihtc2dPcklubmVyLCBpbm5lcikge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gZnVsbE5hbWU7XG4gICAgICAgICAgICBpZiAoIW1zZ09ySW5uZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBkZWZhdWx0VGV4dHNbbmFtZV0gfHwgZnVsbE5hbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbXNnT3JJbm5lciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIlwiLmNvbmNhdChtc2dPcklubmVyKS5jb25jYXQoIWlubmVyID8gJycgOiAnXFxuICcgKyBpbm5lcik7XG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyIHx8IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbXNnT3JJbm5lciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIlwiLmNvbmNhdChtc2dPcklubmVyLm5hbWUsIFwiIFwiKS5jb25jYXQobXNnT3JJbm5lci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlubmVyID0gbXNnT3JJbm5lcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZXJpdmUoRGV4aWVFcnJvcikuZnJvbShCYXNlRXhjZXB0aW9uKTtcbiAgICAgICAgb2JqW25hbWVdID0gRGV4aWVFcnJvcjtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCB7fSk7XG4gICAgZXhjZXB0aW9ucy5TeW50YXggPSBTeW50YXhFcnJvcjtcbiAgICBleGNlcHRpb25zLlR5cGUgPSBUeXBlRXJyb3I7XG4gICAgZXhjZXB0aW9ucy5SYW5nZSA9IFJhbmdlRXJyb3I7XG4gICAgdmFyIGV4Y2VwdGlvbk1hcCA9IGlkYkRvbUVycm9yTmFtZXMucmVkdWNlKGZ1bmN0aW9uIChvYmosIG5hbWUpIHtcbiAgICAgICAgb2JqW25hbWUgKyBcIkVycm9yXCJdID0gZXhjZXB0aW9uc1tuYW1lXTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCB7fSk7XG4gICAgZnVuY3Rpb24gbWFwRXJyb3IoZG9tRXJyb3IsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCFkb21FcnJvciB8fCBkb21FcnJvciBpbnN0YW5jZW9mIERleGllRXJyb3IgfHwgZG9tRXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgfHwgZG9tRXJyb3IgaW5zdGFuY2VvZiBTeW50YXhFcnJvciB8fCAhZG9tRXJyb3IubmFtZSB8fCAhZXhjZXB0aW9uTWFwW2RvbUVycm9yLm5hbWVdKVxuICAgICAgICAgICAgcmV0dXJuIGRvbUVycm9yO1xuICAgICAgICB2YXIgcnYgPSBuZXcgZXhjZXB0aW9uTWFwW2RvbUVycm9yLm5hbWVdKG1lc3NhZ2UgfHwgZG9tRXJyb3IubWVzc2FnZSwgZG9tRXJyb3IpO1xuICAgICAgICBpZiAoXCJzdGFja1wiIGluIGRvbUVycm9yKSB7XG4gICAgICAgICAgICBzZXRQcm9wKHJ2LCBcInN0YWNrXCIsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlubmVyLnN0YWNrO1xuICAgICAgICAgICAgICAgIH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH1cbiAgICB2YXIgZnVsbE5hbWVFeGNlcHRpb25zID0gZXJyb3JMaXN0LnJlZHVjZShmdW5jdGlvbiAob2JqLCBuYW1lKSB7XG4gICAgICAgIGlmIChbXCJTeW50YXhcIiwgXCJUeXBlXCIsIFwiUmFuZ2VcIl0uaW5kZXhPZihuYW1lKSA9PT0gLTEpXG4gICAgICAgICAgICBvYmpbbmFtZSArIFwiRXJyb3JcIl0gPSBleGNlcHRpb25zW25hbWVdO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sIHt9KTtcbiAgICBmdWxsTmFtZUV4Y2VwdGlvbnMuTW9kaWZ5RXJyb3IgPSBNb2RpZnlFcnJvcjtcbiAgICBmdWxsTmFtZUV4Y2VwdGlvbnMuRGV4aWVFcnJvciA9IERleGllRXJyb3I7XG4gICAgZnVsbE5hbWVFeGNlcHRpb25zLkJ1bGtFcnJvciA9IEJ1bGtFcnJvcjtcblxuICAgIGZ1bmN0aW9uIG5vcCgpIHsgfVxuICAgIGZ1bmN0aW9uIG1pcnJvcih2YWwpIHsgcmV0dXJuIHZhbDsgfVxuICAgIGZ1bmN0aW9uIHB1cmVGdW5jdGlvbkNoYWluKGYxLCBmMikge1xuICAgICAgICBpZiAoZjEgPT0gbnVsbCB8fCBmMSA9PT0gbWlycm9yKVxuICAgICAgICAgICAgcmV0dXJuIGYyO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGYyKGYxKHZhbCkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYWxsQm90aChvbjEsIG9uMikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb24xLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBvbjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaG9va0NyZWF0aW5nQ2hhaW4oZjEsIGYyKSB7XG4gICAgICAgIGlmIChmMSA9PT0gbm9wKVxuICAgICAgICAgICAgcmV0dXJuIGYyO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzWzBdID0gcmVzO1xuICAgICAgICAgICAgdmFyIG9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzLFxuICAgICAgICAgICAgb25lcnJvciA9IHRoaXMub25lcnJvcjtcbiAgICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICB2YXIgcmVzMiA9IGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAob25zdWNjZXNzKVxuICAgICAgICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MgPyBjYWxsQm90aChvbnN1Y2Nlc3MsIHRoaXMub25zdWNjZXNzKSA6IG9uc3VjY2VzcztcbiAgICAgICAgICAgIGlmIChvbmVycm9yKVxuICAgICAgICAgICAgICAgIHRoaXMub25lcnJvciA9IHRoaXMub25lcnJvciA/IGNhbGxCb3RoKG9uZXJyb3IsIHRoaXMub25lcnJvcikgOiBvbmVycm9yO1xuICAgICAgICAgICAgcmV0dXJuIHJlczIgIT09IHVuZGVmaW5lZCA/IHJlczIgOiByZXM7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhvb2tEZWxldGluZ0NoYWluKGYxLCBmMikge1xuICAgICAgICBpZiAoZjEgPT09IG5vcClcbiAgICAgICAgICAgIHJldHVybiBmMjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgb25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MsXG4gICAgICAgICAgICBvbmVycm9yID0gdGhpcy5vbmVycm9yO1xuICAgICAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmIChvbnN1Y2Nlc3MpXG4gICAgICAgICAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyA/IGNhbGxCb3RoKG9uc3VjY2VzcywgdGhpcy5vbnN1Y2Nlc3MpIDogb25zdWNjZXNzO1xuICAgICAgICAgICAgaWYgKG9uZXJyb3IpXG4gICAgICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gdGhpcy5vbmVycm9yID8gY2FsbEJvdGgob25lcnJvciwgdGhpcy5vbmVycm9yKSA6IG9uZXJyb3I7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhvb2tVcGRhdGluZ0NoYWluKGYxLCBmMikge1xuICAgICAgICBpZiAoZjEgPT09IG5vcClcbiAgICAgICAgICAgIHJldHVybiBmMjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb2RpZmljYXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGV4dGVuZChtb2RpZmljYXRpb25zLCByZXMpO1xuICAgICAgICAgICAgdmFyIG9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzLFxuICAgICAgICAgICAgb25lcnJvciA9IHRoaXMub25lcnJvcjtcbiAgICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICB2YXIgcmVzMiA9IGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAob25zdWNjZXNzKVxuICAgICAgICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MgPyBjYWxsQm90aChvbnN1Y2Nlc3MsIHRoaXMub25zdWNjZXNzKSA6IG9uc3VjY2VzcztcbiAgICAgICAgICAgIGlmIChvbmVycm9yKVxuICAgICAgICAgICAgICAgIHRoaXMub25lcnJvciA9IHRoaXMub25lcnJvciA/IGNhbGxCb3RoKG9uZXJyb3IsIHRoaXMub25lcnJvcikgOiBvbmVycm9yO1xuICAgICAgICAgICAgcmV0dXJuIHJlcyA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAocmVzMiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVzMikgOlxuICAgICAgICAgICAgICAgIChleHRlbmQocmVzLCByZXMyKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldmVyc2VTdG9wcGFibGVFdmVudENoYWluKGYxLCBmMikge1xuICAgICAgICBpZiAoZjEgPT09IG5vcClcbiAgICAgICAgICAgIHJldHVybiBmMjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvbWlzYWJsZUNoYWluKGYxLCBmMikge1xuICAgICAgICBpZiAoZjEgPT09IG5vcClcbiAgICAgICAgICAgIHJldHVybiBmMjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhpeiA9IHRoaXMsIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGkpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGYyLmFwcGx5KHRoaXosIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGRlYnVnID0gdHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAvXihodHRwfGh0dHBzKTpcXC9cXC8obG9jYWxob3N0fDEyN1xcLjBcXC4wXFwuMSkvLnRlc3QobG9jYXRpb24uaHJlZik7XG4gICAgZnVuY3Rpb24gc2V0RGVidWcodmFsdWUsIGZpbHRlcikge1xuICAgICAgICBkZWJ1ZyA9IHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBJTlRFUk5BTCA9IHt9O1xuICAgIHZhciBaT05FX0VDSE9fTElNSVQgPSAxMDAsIF9hJDEgPSB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICBbXSA6XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZ2xvYmFsUCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gPT09ICd1bmRlZmluZWQnIHx8ICFjcnlwdG8uc3VidGxlKVxuICAgICAgICAgICAgICAgIHJldHVybiBbZ2xvYmFsUCwgZ2V0UHJvdG8oZ2xvYmFsUCksIGdsb2JhbFBdO1xuICAgICAgICAgICAgdmFyIG5hdGl2ZVAgPSBjcnlwdG8uc3VidGxlLmRpZ2VzdChcIlNIQS01MTJcIiwgbmV3IFVpbnQ4QXJyYXkoWzBdKSk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG5hdGl2ZVAsXG4gICAgICAgICAgICAgICAgZ2V0UHJvdG8obmF0aXZlUCksXG4gICAgICAgICAgICAgICAgZ2xvYmFsUFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSkoKSwgcmVzb2x2ZWROYXRpdmVQcm9taXNlID0gX2EkMVswXSwgbmF0aXZlUHJvbWlzZVByb3RvID0gX2EkMVsxXSwgcmVzb2x2ZWRHbG9iYWxQcm9taXNlID0gX2EkMVsyXSwgbmF0aXZlUHJvbWlzZVRoZW4gPSBuYXRpdmVQcm9taXNlUHJvdG8gJiYgbmF0aXZlUHJvbWlzZVByb3RvLnRoZW47XG4gICAgdmFyIE5hdGl2ZVByb21pc2UgPSByZXNvbHZlZE5hdGl2ZVByb21pc2UgJiYgcmVzb2x2ZWROYXRpdmVQcm9taXNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBwYXRjaEdsb2JhbFByb21pc2UgPSAhIXJlc29sdmVkR2xvYmFsUHJvbWlzZTtcbiAgICBmdW5jdGlvbiBzY2hlZHVsZVBoeXNpY2FsVGljaygpIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2socGh5c2ljYWxUaWNrKTtcbiAgICB9XG4gICAgdmFyIGFzYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICAgICAgbWljcm90aWNrUXVldWUucHVzaChbY2FsbGJhY2ssIGFyZ3NdKTtcbiAgICAgICAgaWYgKG5lZWRzTmV3UGh5c2ljYWxUaWNrKSB7XG4gICAgICAgICAgICBzY2hlZHVsZVBoeXNpY2FsVGljaygpO1xuICAgICAgICAgICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGlzT3V0c2lkZU1pY3JvVGljayA9IHRydWUsXG4gICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSB0cnVlLFxuICAgIHVuaGFuZGxlZEVycm9ycyA9IFtdLFxuICAgIHJlamVjdGluZ0Vycm9ycyA9IFtdLFxuICAgIHJlamVjdGlvbk1hcHBlciA9IG1pcnJvcjtcbiAgICB2YXIgZ2xvYmFsUFNEID0ge1xuICAgICAgICBpZDogJ2dsb2JhbCcsXG4gICAgICAgIGdsb2JhbDogdHJ1ZSxcbiAgICAgICAgcmVmOiAwLFxuICAgICAgICB1bmhhbmRsZWRzOiBbXSxcbiAgICAgICAgb251bmhhbmRsZWQ6IG5vcCxcbiAgICAgICAgcGdwOiBmYWxzZSxcbiAgICAgICAgZW52OiB7fSxcbiAgICAgICAgZmluYWxpemU6IG5vcFxuICAgIH07XG4gICAgdmFyIFBTRCA9IGdsb2JhbFBTRDtcbiAgICB2YXIgbWljcm90aWNrUXVldWUgPSBbXTtcbiAgICB2YXIgbnVtU2NoZWR1bGVkQ2FsbHMgPSAwO1xuICAgIHZhciB0aWNrRmluYWxpemVycyA9IFtdO1xuICAgIGZ1bmN0aW9uIERleGllUHJvbWlzZShmbikge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZXMgbXVzdCBiZSBjb25zdHJ1Y3RlZCB2aWEgbmV3Jyk7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLl9saWIgPSBmYWxzZTtcbiAgICAgICAgdmFyIHBzZCA9ICh0aGlzLl9QU0QgPSBQU0QpO1xuICAgICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoZm4gIT09IElOVEVSTkFMKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICBoYW5kbGVSZWplY3Rpb24odGhpcywgdGhpcy5fdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgICAgICArK3BzZC5yZWY7XG4gICAgICAgIGV4ZWN1dGVQcm9taXNlVGFzayh0aGlzLCBmbik7XG4gICAgfVxuICAgIHZhciB0aGVuUHJvcCA9IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcHNkID0gUFNELCBtaWNyb1Rhc2tJZCA9IHRvdGFsRWNob2VzO1xuICAgICAgICAgICAgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIHBvc3NpYmxlQXdhaXQgPSAhcHNkLmdsb2JhbCAmJiAocHNkICE9PSBQU0QgfHwgbWljcm9UYXNrSWQgIT09IHRvdGFsRWNob2VzKTtcbiAgICAgICAgICAgICAgICB2YXIgY2xlYW51cCA9IHBvc3NpYmxlQXdhaXQgJiYgIWRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICAgICAgdmFyIHJ2ID0gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BhZ2F0ZVRvTGlzdGVuZXIoX3RoaXMsIG5ldyBMaXN0ZW5lcihuYXRpdmVBd2FpdENvbXBhdGlibGVXcmFwKG9uRnVsZmlsbGVkLCBwc2QsIHBvc3NpYmxlQXdhaXQsIGNsZWFudXApLCBuYXRpdmVBd2FpdENvbXBhdGlibGVXcmFwKG9uUmVqZWN0ZWQsIHBzZCwgcG9zc2libGVBd2FpdCwgY2xlYW51cCksIHJlc29sdmUsIHJlamVjdCwgcHNkKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnNvbGVUYXNrKVxuICAgICAgICAgICAgICAgICAgICBydi5fY29uc29sZVRhc2sgPSB0aGlzLl9jb25zb2xlVGFzaztcbiAgICAgICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGVuLnByb3RvdHlwZSA9IElOVEVSTkFMO1xuICAgICAgICAgICAgcmV0dXJuIHRoZW47XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBzZXRQcm9wKHRoaXMsICd0aGVuJywgdmFsdWUgJiYgdmFsdWUucHJvdG90eXBlID09PSBJTlRFUk5BTCA/XG4gICAgICAgICAgICAgICAgdGhlblByb3AgOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNldDogdGhlblByb3Auc2V0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHByb3BzKERleGllUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAgICAgdGhlbjogdGhlblByb3AsXG4gICAgICAgIF90aGVuOiBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgIHByb3BhZ2F0ZVRvTGlzdGVuZXIodGhpcywgbmV3IExpc3RlbmVyKG51bGwsIG51bGwsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBQU0QpKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2F0Y2g6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBhcmd1bWVudHNbMF0sIGhhbmRsZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0aGlzLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnIgaW5zdGFuY2VvZiB0eXBlID8gaGFuZGxlcihlcnIpIDogUHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICA6IHRoaXMudGhlbihudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnIgJiYgZXJyLm5hbWUgPT09IHR5cGUgPyBoYW5kbGVyKGVycikgOiBQcm9taXNlUmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmFsbHk6IGZ1bmN0aW9uIChvbkZpbmFsbHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUob25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJvbWlzZVJlamVjdChlcnIpOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB0aW1lb3V0OiBmdW5jdGlvbiAobXMsIG1zZykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBtcyA8IEluZmluaXR5ID9cbiAgICAgICAgICAgICAgICBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVqZWN0KG5ldyBleGNlcHRpb25zLlRpbWVvdXQobXNnKSk7IH0sIG1zKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudGhlbihyZXNvbHZlLCByZWplY3QpLmZpbmFsbHkoY2xlYXJUaW1lb3V0LmJpbmQobnVsbCwgaGFuZGxlKSk7XG4gICAgICAgICAgICAgICAgfSkgOiB0aGlzO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZylcbiAgICAgICAgc2V0UHJvcChEZXhpZVByb21pc2UucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsICdEZXhpZS5Qcm9taXNlJyk7XG4gICAgZ2xvYmFsUFNELmVudiA9IHNuYXBTaG90KCk7XG4gICAgZnVuY3Rpb24gTGlzdGVuZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHJlc29sdmUsIHJlamVjdCwgem9uZSkge1xuICAgICAgICB0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiBudWxsO1xuICAgICAgICB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uUmVqZWN0ZWQgOiBudWxsO1xuICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgdGhpcy5wc2QgPSB6b25lO1xuICAgIH1cbiAgICBwcm9wcyhEZXhpZVByb21pc2UsIHtcbiAgICAgICAgYWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gZ2V0QXJyYXlPZi5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAoYSwgaSkgeyByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUoYSkudGhlbihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbaV0gPSB4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIS0tcmVtYWluaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICAgICAgICAgIH0sIHJlamVjdCk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc29sdmU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGV4aWVQcm9taXNlKVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBydiA9IG5ldyBEZXhpZVByb21pc2UoSU5URVJOQUwsIHRydWUsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfSxcbiAgICAgICAgcmVqZWN0OiBQcm9taXNlUmVqZWN0LFxuICAgICAgICByYWNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gZ2V0QXJyYXlPZi5hcHBseShudWxsLCBhcmd1bWVudHMpLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihyZXNvbHZlLCByZWplY3QpOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBQU0Q6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUFNEOyB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIFBTRCA9IHZhbHVlOyB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvdGFsRWNob2VzOiB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdG90YWxFY2hvZXM7IH0gfSxcbiAgICAgICAgbmV3UFNEOiBuZXdTY29wZSxcbiAgICAgICAgdXNlUFNEOiB1c2VQU0QsXG4gICAgICAgIHNjaGVkdWxlcjoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhc2FwOyB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgYXNhcCA9IHZhbHVlOyB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlamVjdGlvbk1hcHBlcjoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWplY3Rpb25NYXBwZXI7IH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZWplY3Rpb25NYXBwZXIgPSB2YWx1ZTsgfVxuICAgICAgICB9LFxuICAgICAgICBmb2xsb3c6IGZ1bmN0aW9uIChmbiwgem9uZVByb3BzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3BlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBzZCA9IFBTRDtcbiAgICAgICAgICAgICAgICAgICAgcHNkLnVuaGFuZGxlZHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcHNkLm9udW5oYW5kbGVkID0gcmVqZWN0O1xuICAgICAgICAgICAgICAgICAgICBwc2QuZmluYWxpemUgPSBjYWxsQm90aChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVuX2F0X2VuZF9vZl90aGlzX29yX25leHRfcGh5c2ljYWxfdGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudW5oYW5kbGVkcy5sZW5ndGggPT09IDAgPyByZXNvbHZlKCkgOiByZWplY3QoX3RoaXMudW5oYW5kbGVkc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgcHNkLmZpbmFsaXplKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9LCB6b25lUHJvcHMsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChOYXRpdmVQcm9taXNlKSB7XG4gICAgICAgIGlmIChOYXRpdmVQcm9taXNlLmFsbFNldHRsZWQpXG4gICAgICAgICAgICBzZXRQcm9wKERleGllUHJvbWlzZSwgXCJhbGxTZXR0bGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zc2libGVQcm9taXNlcyA9IGdldEFycmF5T2YuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5tYXAob25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zc2libGVQcm9taXNlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IHBvc3NpYmxlUHJvbWlzZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheShyZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZVByb21pc2VzLmZvckVhY2goZnVuY3Rpb24gKHAsIGkpIHsgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKHApLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiByZXN1bHRzW2ldID0geyBzdGF0dXM6IFwiZnVsZmlsbGVkXCIsIHZhbHVlOiB2YWx1ZSB9OyB9LCBmdW5jdGlvbiAocmVhc29uKSB7IHJldHVybiByZXN1bHRzW2ldID0geyBzdGF0dXM6IFwicmVqZWN0ZWRcIiwgcmVhc29uOiByZWFzb24gfTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIC0tcmVtYWluaW5nIHx8IHJlc29sdmUocmVzdWx0cyk7IH0pOyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoTmF0aXZlUHJvbWlzZS5hbnkgJiYgdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIHNldFByb3AoRGV4aWVQcm9taXNlLCBcImFueVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvc3NpYmxlUHJvbWlzZXMgPSBnZXRBcnJheU9mLmFwcGx5KG51bGwsIGFyZ3VtZW50cykubWFwKG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zc2libGVQcm9taXNlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEFnZ3JlZ2F0ZUVycm9yKFtdKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZW1haW5pbmcgPSBwb3NzaWJsZVByb21pc2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZhaWx1cmVzID0gbmV3IEFycmF5KHJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlUHJvbWlzZXMuZm9yRWFjaChmdW5jdGlvbiAocCwgaSkgeyByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUocCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHJlc29sdmUodmFsdWUpOyB9LCBmdW5jdGlvbiAoZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZXNbaV0gPSBmYWlsdXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEtLXJlbWFpbmluZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEFnZ3JlZ2F0ZUVycm9yKGZhaWx1cmVzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBleGVjdXRlUHJvbWlzZVRhc2socHJvbWlzZSwgZm4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gcHJvbWlzZSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi4nKTtcbiAgICAgICAgICAgICAgICB2YXIgc2hvdWxkRXhlY3V0ZVRpY2sgPSBwcm9taXNlLl9saWIgJiYgYmVnaW5NaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBleGVjdXRlUHJvbWlzZVRhc2socHJvbWlzZSwgZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBEZXhpZVByb21pc2UgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl90aGVuKHJlc29sdmUsIHJlamVjdCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9zdGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHByb3BhZ2F0ZUFsbExpc3RlbmVycyhwcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZEV4ZWN1dGVUaWNrKVxuICAgICAgICAgICAgICAgICAgICBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICAgICAgfSwgaGFuZGxlUmVqZWN0aW9uLmJpbmQobnVsbCwgcHJvbWlzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgaGFuZGxlUmVqZWN0aW9uKHByb21pc2UsIGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVSZWplY3Rpb24ocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgICAgIHJlamVjdGluZ0Vycm9ycy5wdXNoKHJlYXNvbik7XG4gICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHNob3VsZEV4ZWN1dGVUaWNrID0gcHJvbWlzZS5fbGliICYmIGJlZ2luTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgcmVhc29uID0gcmVqZWN0aW9uTWFwcGVyKHJlYXNvbik7XG4gICAgICAgIHByb21pc2UuX3N0YXRlID0gZmFsc2U7XG4gICAgICAgIHByb21pc2UuX3ZhbHVlID0gcmVhc29uO1xuICAgICAgICBhZGRQb3NzaWJseVVuaGFuZGxlZEVycm9yKHByb21pc2UpO1xuICAgICAgICBwcm9wYWdhdGVBbGxMaXN0ZW5lcnMocHJvbWlzZSk7XG4gICAgICAgIGlmIChzaG91bGRFeGVjdXRlVGljaylcbiAgICAgICAgICAgIGVuZE1pY3JvVGlja1Njb3BlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZUFsbExpc3RlbmVycyhwcm9taXNlKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBwcm9taXNlLl9saXN0ZW5lcnM7XG4gICAgICAgIHByb21pc2UuX2xpc3RlbmVycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBwcm9wYWdhdGVUb0xpc3RlbmVyKHByb21pc2UsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBzZCA9IHByb21pc2UuX1BTRDtcbiAgICAgICAgLS1wc2QucmVmIHx8IHBzZC5maW5hbGl6ZSgpO1xuICAgICAgICBpZiAobnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApIHtcbiAgICAgICAgICAgICsrbnVtU2NoZWR1bGVkQ2FsbHM7XG4gICAgICAgICAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoLS1udW1TY2hlZHVsZWRDYWxscyA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgZmluYWxpemVQaHlzaWNhbFRpY2soKTtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9wYWdhdGVUb0xpc3RlbmVyKHByb21pc2UsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvbWlzZS5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYiA9IHByb21pc2UuX3N0YXRlID8gbGlzdGVuZXIub25GdWxmaWxsZWQgOiBsaXN0ZW5lci5vblJlamVjdGVkO1xuICAgICAgICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAocHJvbWlzZS5fc3RhdGUgPyBsaXN0ZW5lci5yZXNvbHZlIDogbGlzdGVuZXIucmVqZWN0KShwcm9taXNlLl92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgKytsaXN0ZW5lci5wc2QucmVmO1xuICAgICAgICArK251bVNjaGVkdWxlZENhbGxzO1xuICAgICAgICBhc2FwKGNhbGxMaXN0ZW5lciwgW2NiLCBwcm9taXNlLCBsaXN0ZW5lcl0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYWxsTGlzdGVuZXIoY2IsIHByb21pc2UsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmV0LCB2YWx1ZSA9IHByb21pc2UuX3ZhbHVlO1xuICAgICAgICAgICAgaWYgKCFwcm9taXNlLl9zdGF0ZSAmJiByZWplY3RpbmdFcnJvcnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJlamVjdGluZ0Vycm9ycyA9IFtdO1xuICAgICAgICAgICAgcmV0ID0gZGVidWcgJiYgcHJvbWlzZS5fY29uc29sZVRhc2sgPyBwcm9taXNlLl9jb25zb2xlVGFzay5ydW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gY2IodmFsdWUpOyB9KSA6IGNiKHZhbHVlKTtcbiAgICAgICAgICAgIGlmICghcHJvbWlzZS5fc3RhdGUgJiYgcmVqZWN0aW5nRXJyb3JzLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG1hcmtFcnJvckFzSGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RlbmVyLnJlc29sdmUocmV0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGlzdGVuZXIucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKC0tbnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApXG4gICAgICAgICAgICAgICAgZmluYWxpemVQaHlzaWNhbFRpY2soKTtcbiAgICAgICAgICAgIC0tbGlzdGVuZXIucHNkLnJlZiB8fCBsaXN0ZW5lci5wc2QuZmluYWxpemUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwaHlzaWNhbFRpY2soKSB7XG4gICAgICAgIHVzZVBTRChnbG9iYWxQU0QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGJlZ2luTWljcm9UaWNrU2NvcGUoKSAmJiBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmVnaW5NaWNyb1RpY2tTY29wZSgpIHtcbiAgICAgICAgdmFyIHdhc1Jvb3RFeGVjID0gaXNPdXRzaWRlTWljcm9UaWNrO1xuICAgICAgICBpc091dHNpZGVNaWNyb1RpY2sgPSBmYWxzZTtcbiAgICAgICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHdhc1Jvb3RFeGVjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmRNaWNyb1RpY2tTY29wZSgpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrcywgaSwgbDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgd2hpbGUgKG1pY3JvdGlja1F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3MgPSBtaWNyb3RpY2tRdWV1ZTtcbiAgICAgICAgICAgICAgICBtaWNyb3RpY2tRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIGwgPSBjYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBjYWxsYmFja3NbaV07XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bMF0uYXBwbHkobnVsbCwgaXRlbVsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChtaWNyb3RpY2tRdWV1ZS5sZW5ndGggPiAwKTtcbiAgICAgICAgaXNPdXRzaWRlTWljcm9UaWNrID0gdHJ1ZTtcbiAgICAgICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5hbGl6ZVBoeXNpY2FsVGljaygpIHtcbiAgICAgICAgdmFyIHVuaGFuZGxlZEVycnMgPSB1bmhhbmRsZWRFcnJvcnM7XG4gICAgICAgIHVuaGFuZGxlZEVycm9ycyA9IFtdO1xuICAgICAgICB1bmhhbmRsZWRFcnJzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHAuX1BTRC5vbnVuaGFuZGxlZC5jYWxsKG51bGwsIHAuX3ZhbHVlLCBwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBmaW5hbGl6ZXJzID0gdGlja0ZpbmFsaXplcnMuc2xpY2UoMCk7XG4gICAgICAgIHZhciBpID0gZmluYWxpemVycy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpKVxuICAgICAgICAgICAgZmluYWxpemVyc1stLWldKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJ1bl9hdF9lbmRfb2ZfdGhpc19vcl9uZXh0X3BoeXNpY2FsX3RpY2soZm4pIHtcbiAgICAgICAgZnVuY3Rpb24gZmluYWxpemVyKCkge1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIHRpY2tGaW5hbGl6ZXJzLnNwbGljZSh0aWNrRmluYWxpemVycy5pbmRleE9mKGZpbmFsaXplciksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRpY2tGaW5hbGl6ZXJzLnB1c2goZmluYWxpemVyKTtcbiAgICAgICAgKytudW1TY2hlZHVsZWRDYWxscztcbiAgICAgICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoLS1udW1TY2hlZHVsZWRDYWxscyA9PT0gMClcbiAgICAgICAgICAgICAgICBmaW5hbGl6ZVBoeXNpY2FsVGljaygpO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZFBvc3NpYmx5VW5oYW5kbGVkRXJyb3IocHJvbWlzZSkge1xuICAgICAgICBpZiAoIXVuaGFuZGxlZEVycm9ycy5zb21lKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLl92YWx1ZSA9PT0gcHJvbWlzZS5fdmFsdWU7IH0pKVxuICAgICAgICAgICAgdW5oYW5kbGVkRXJyb3JzLnB1c2gocHJvbWlzZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtFcnJvckFzSGFuZGxlZChwcm9taXNlKSB7XG4gICAgICAgIHZhciBpID0gdW5oYW5kbGVkRXJyb3JzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGkpXG4gICAgICAgICAgICBpZiAodW5oYW5kbGVkRXJyb3JzWy0taV0uX3ZhbHVlID09PSBwcm9taXNlLl92YWx1ZSkge1xuICAgICAgICAgICAgICAgIHVuaGFuZGxlZEVycm9ycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBQcm9taXNlUmVqZWN0KHJlYXNvbikge1xuICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShJTlRFUk5BTCwgZmFsc2UsIHJlYXNvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyYXAoZm4sIGVycm9yQ2F0Y2hlcikge1xuICAgICAgICB2YXIgcHNkID0gUFNEO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHdhc1Jvb3RFeGVjID0gYmVnaW5NaWNyb1RpY2tTY29wZSgpLCBvdXRlclNjb3BlID0gUFNEO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2hUb1pvbmUocHNkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JDYXRjaGVyICYmIGVycm9yQ2F0Y2hlcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHN3aXRjaFRvWm9uZShvdXRlclNjb3BlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKHdhc1Jvb3RFeGVjKVxuICAgICAgICAgICAgICAgICAgICBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgdGFzayA9IHsgYXdhaXRzOiAwLCBlY2hvZXM6IDAsIGlkOiAwIH07XG4gICAgdmFyIHRhc2tDb3VudGVyID0gMDtcbiAgICB2YXIgem9uZVN0YWNrID0gW107XG4gICAgdmFyIHpvbmVFY2hvZXMgPSAwO1xuICAgIHZhciB0b3RhbEVjaG9lcyA9IDA7XG4gICAgdmFyIHpvbmVfaWRfY291bnRlciA9IDA7XG4gICAgZnVuY3Rpb24gbmV3U2NvcGUoZm4sIHByb3BzLCBhMSwgYTIpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IFBTRCwgcHNkID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgICAgICBwc2QucGFyZW50ID0gcGFyZW50O1xuICAgICAgICBwc2QucmVmID0gMDtcbiAgICAgICAgcHNkLmdsb2JhbCA9IGZhbHNlO1xuICAgICAgICBwc2QuaWQgPSArK3pvbmVfaWRfY291bnRlcjtcbiAgICAgICAgZ2xvYmFsUFNELmVudjtcbiAgICAgICAgcHNkLmVudiA9IHBhdGNoR2xvYmFsUHJvbWlzZSA/IHtcbiAgICAgICAgICAgIFByb21pc2U6IERleGllUHJvbWlzZSxcbiAgICAgICAgICAgIFByb21pc2VQcm9wOiB7IHZhbHVlOiBEZXhpZVByb21pc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSxcbiAgICAgICAgICAgIGFsbDogRGV4aWVQcm9taXNlLmFsbCxcbiAgICAgICAgICAgIHJhY2U6IERleGllUHJvbWlzZS5yYWNlLFxuICAgICAgICAgICAgYWxsU2V0dGxlZDogRGV4aWVQcm9taXNlLmFsbFNldHRsZWQsXG4gICAgICAgICAgICBhbnk6IERleGllUHJvbWlzZS5hbnksXG4gICAgICAgICAgICByZXNvbHZlOiBEZXhpZVByb21pc2UucmVzb2x2ZSxcbiAgICAgICAgICAgIHJlamVjdDogRGV4aWVQcm9taXNlLnJlamVjdCxcbiAgICAgICAgfSA6IHt9O1xuICAgICAgICBpZiAocHJvcHMpXG4gICAgICAgICAgICBleHRlbmQocHNkLCBwcm9wcyk7XG4gICAgICAgICsrcGFyZW50LnJlZjtcbiAgICAgICAgcHNkLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLS10aGlzLnBhcmVudC5yZWYgfHwgdGhpcy5wYXJlbnQuZmluYWxpemUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJ2ID0gdXNlUFNEKHBzZCwgZm4sIGExLCBhMik7XG4gICAgICAgIGlmIChwc2QucmVmID09PSAwKVxuICAgICAgICAgICAgcHNkLmZpbmFsaXplKCk7XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKSB7XG4gICAgICAgIGlmICghdGFzay5pZClcbiAgICAgICAgICAgIHRhc2suaWQgPSArK3Rhc2tDb3VudGVyO1xuICAgICAgICArK3Rhc2suYXdhaXRzO1xuICAgICAgICB0YXNrLmVjaG9lcyArPSBaT05FX0VDSE9fTElNSVQ7XG4gICAgICAgIHJldHVybiB0YXNrLmlkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpIHtcbiAgICAgICAgaWYgKCF0YXNrLmF3YWl0cylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKC0tdGFzay5hd2FpdHMgPT09IDApXG4gICAgICAgICAgICB0YXNrLmlkID0gMDtcbiAgICAgICAgdGFzay5lY2hvZXMgPSB0YXNrLmF3YWl0cyAqIFpPTkVfRUNIT19MSU1JVDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICgoJycgKyBuYXRpdmVQcm9taXNlVGhlbikuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpID09PSAtMSkge1xuICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cyA9IGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzID0gbm9wO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMocG9zc2libGVQcm9taXNlKSB7XG4gICAgICAgIGlmICh0YXNrLmVjaG9lcyAmJiBwb3NzaWJsZVByb21pc2UgJiYgcG9zc2libGVQcm9taXNlLmNvbnN0cnVjdG9yID09PSBOYXRpdmVQcm9taXNlKSB7XG4gICAgICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3NpYmxlUHJvbWlzZS50aGVuKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvc3NpYmxlUHJvbWlzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gem9uZUVudGVyRWNobyh0YXJnZXRab25lKSB7XG4gICAgICAgICsrdG90YWxFY2hvZXM7XG4gICAgICAgIGlmICghdGFzay5lY2hvZXMgfHwgLS10YXNrLmVjaG9lcyA9PT0gMCkge1xuICAgICAgICAgICAgdGFzay5lY2hvZXMgPSB0YXNrLmF3YWl0cyA9IHRhc2suaWQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHpvbmVTdGFjay5wdXNoKFBTRCk7XG4gICAgICAgIHN3aXRjaFRvWm9uZSh0YXJnZXRab25lLCB0cnVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gem9uZUxlYXZlRWNobygpIHtcbiAgICAgICAgdmFyIHpvbmUgPSB6b25lU3RhY2tbem9uZVN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICB6b25lU3RhY2sucG9wKCk7XG4gICAgICAgIHN3aXRjaFRvWm9uZSh6b25lLCBmYWxzZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN3aXRjaFRvWm9uZSh0YXJnZXRab25lLCBiRW50ZXJpbmdab25lKSB7XG4gICAgICAgIHZhciBjdXJyZW50Wm9uZSA9IFBTRDtcbiAgICAgICAgaWYgKGJFbnRlcmluZ1pvbmUgPyB0YXNrLmVjaG9lcyAmJiAoIXpvbmVFY2hvZXMrKyB8fCB0YXJnZXRab25lICE9PSBQU0QpIDogem9uZUVjaG9lcyAmJiAoIS0tem9uZUVjaG9lcyB8fCB0YXJnZXRab25lICE9PSBQU0QpKSB7XG4gICAgICAgICAgICBxdWV1ZU1pY3JvdGFzayhiRW50ZXJpbmdab25lID8gem9uZUVudGVyRWNoby5iaW5kKG51bGwsIHRhcmdldFpvbmUpIDogem9uZUxlYXZlRWNobyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldFpvbmUgPT09IFBTRClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgUFNEID0gdGFyZ2V0Wm9uZTtcbiAgICAgICAgaWYgKGN1cnJlbnRab25lID09PSBnbG9iYWxQU0QpXG4gICAgICAgICAgICBnbG9iYWxQU0QuZW52ID0gc25hcFNob3QoKTtcbiAgICAgICAgaWYgKHBhdGNoR2xvYmFsUHJvbWlzZSkge1xuICAgICAgICAgICAgdmFyIEdsb2JhbFByb21pc2UgPSBnbG9iYWxQU0QuZW52LlByb21pc2U7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0RW52ID0gdGFyZ2V0Wm9uZS5lbnY7XG4gICAgICAgICAgICBpZiAoY3VycmVudFpvbmUuZ2xvYmFsIHx8IHRhcmdldFpvbmUuZ2xvYmFsKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9nbG9iYWwsICdQcm9taXNlJywgdGFyZ2V0RW52LlByb21pc2VQcm9wKTtcbiAgICAgICAgICAgICAgICBHbG9iYWxQcm9taXNlLmFsbCA9IHRhcmdldEVudi5hbGw7XG4gICAgICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5yYWNlID0gdGFyZ2V0RW52LnJhY2U7XG4gICAgICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5yZXNvbHZlID0gdGFyZ2V0RW52LnJlc29sdmU7XG4gICAgICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5yZWplY3QgPSB0YXJnZXRFbnYucmVqZWN0O1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbnYuYWxsU2V0dGxlZClcbiAgICAgICAgICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5hbGxTZXR0bGVkID0gdGFyZ2V0RW52LmFsbFNldHRsZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldEVudi5hbnkpXG4gICAgICAgICAgICAgICAgICAgIEdsb2JhbFByb21pc2UuYW55ID0gdGFyZ2V0RW52LmFueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzbmFwU2hvdCgpIHtcbiAgICAgICAgdmFyIEdsb2JhbFByb21pc2UgPSBfZ2xvYmFsLlByb21pc2U7XG4gICAgICAgIHJldHVybiBwYXRjaEdsb2JhbFByb21pc2UgPyB7XG4gICAgICAgICAgICBQcm9taXNlOiBHbG9iYWxQcm9taXNlLFxuICAgICAgICAgICAgUHJvbWlzZVByb3A6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoX2dsb2JhbCwgXCJQcm9taXNlXCIpLFxuICAgICAgICAgICAgYWxsOiBHbG9iYWxQcm9taXNlLmFsbCxcbiAgICAgICAgICAgIHJhY2U6IEdsb2JhbFByb21pc2UucmFjZSxcbiAgICAgICAgICAgIGFsbFNldHRsZWQ6IEdsb2JhbFByb21pc2UuYWxsU2V0dGxlZCxcbiAgICAgICAgICAgIGFueTogR2xvYmFsUHJvbWlzZS5hbnksXG4gICAgICAgICAgICByZXNvbHZlOiBHbG9iYWxQcm9taXNlLnJlc29sdmUsXG4gICAgICAgICAgICByZWplY3Q6IEdsb2JhbFByb21pc2UucmVqZWN0LFxuICAgICAgICB9IDoge307XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZVBTRChwc2QsIGZuLCBhMSwgYTIsIGEzKSB7XG4gICAgICAgIHZhciBvdXRlclNjb3BlID0gUFNEO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3dpdGNoVG9ab25lKHBzZCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gZm4oYTEsIGEyLCBhMyk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBzd2l0Y2hUb1pvbmUob3V0ZXJTY29wZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAoZm4sIHpvbmUsIHBvc3NpYmxlQXdhaXQsIGNsZWFudXApIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJyA/IGZuIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG91dGVyWm9uZSA9IFBTRDtcbiAgICAgICAgICAgIGlmIChwb3NzaWJsZUF3YWl0KVxuICAgICAgICAgICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICBzd2l0Y2hUb1pvbmUoem9uZSwgdHJ1ZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoVG9ab25lKG91dGVyWm9uZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChjbGVhbnVwKVxuICAgICAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzayhkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV4ZWNJbkdsb2JhbENvbnRleHQoY2IpIHtcbiAgICAgICAgaWYgKFByb21pc2UgPT09IE5hdGl2ZVByb21pc2UgJiYgdGFzay5lY2hvZXMgPT09IDApIHtcbiAgICAgICAgICAgIGlmICh6b25lRWNob2VzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVucXVldWVOYXRpdmVNaWNyb1Rhc2soY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlamVjdGlvbiA9IERleGllUHJvbWlzZS5yZWplY3Q7XG5cbiAgICBmdW5jdGlvbiB0ZW1wVHJhbnNhY3Rpb24oZGIsIG1vZGUsIHN0b3JlTmFtZXMsIGZuKSB7XG4gICAgICAgIGlmICghZGIuaWRiZGIgfHwgKCFkYi5fc3RhdGUub3BlbkNvbXBsZXRlICYmICghUFNELmxldFRocm91Z2ggJiYgIWRiLl92aXApKSkge1xuICAgICAgICAgICAgaWYgKGRiLl9zdGF0ZS5vcGVuQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKGRiLl9zdGF0ZS5kYk9wZW5FcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYi5fc3RhdGUuaXNCZWluZ09wZW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICghZGIuX3N0YXRlLmF1dG9PcGVuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCkpO1xuICAgICAgICAgICAgICAgIGRiLm9wZW4oKS5jYXRjaChub3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRiLl9zdGF0ZS5kYlJlYWR5UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRlbXBUcmFuc2FjdGlvbihkYiwgbW9kZSwgc3RvcmVOYW1lcywgZm4pOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0cmFucyA9IGRiLl9jcmVhdGVUcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYi5fZGJTY2hlbWEpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0cmFucy5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICBkYi5fc3RhdGUuUFIxMzk4X21heExvb3AgPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4Lm5hbWUgPT09IGVycm5hbWVzLkludmFsaWRTdGF0ZSAmJiBkYi5pc09wZW4oKSAmJiAtLWRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXhpZTogTmVlZCB0byByZW9wZW4gZGInKTtcbiAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoeyBkaXNhYmxlQXV0b09wZW46IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGIub3BlbigpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdGVtcFRyYW5zYWN0aW9uKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBmbik7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cmFucy5fcHJvbWlzZShtb2RlLCBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgUFNELnRyYW5zID0gdHJhbnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihyZXNvbHZlLCByZWplY3QsIHRyYW5zKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSAncmVhZHdyaXRlJylcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zLmlkYnRyYW5zLmNvbW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGUgPT09ICdyZWFkb25seScgPyByZXN1bHQgOiB0cmFucy5fY29tcGxldGlvbi50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc3VsdDsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBERVhJRV9WRVJTSU9OID0gJzQuMC43JztcbiAgICB2YXIgbWF4U3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZSg2NTUzNSk7XG4gICAgdmFyIG1pbktleSA9IC1JbmZpbml0eTtcbiAgICB2YXIgSU5WQUxJRF9LRVlfQVJHVU1FTlQgPSBcIkludmFsaWQga2V5IHByb3ZpZGVkLiBLZXlzIG11c3QgYmUgb2YgdHlwZSBzdHJpbmcsIG51bWJlciwgRGF0ZSBvciBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBEYXRlPi5cIjtcbiAgICB2YXIgU1RSSU5HX0VYUEVDVEVEID0gXCJTdHJpbmcgZXhwZWN0ZWQuXCI7XG4gICAgdmFyIGNvbm5lY3Rpb25zID0gW107XG4gICAgdmFyIERCTkFNRVNfREIgPSAnX19kYm5hbWVzJztcbiAgICB2YXIgUkVBRE9OTFkgPSAncmVhZG9ubHknO1xuICAgIHZhciBSRUFEV1JJVEUgPSAncmVhZHdyaXRlJztcblxuICAgIGZ1bmN0aW9uIGNvbWJpbmUoZmlsdGVyMSwgZmlsdGVyMikge1xuICAgICAgICByZXR1cm4gZmlsdGVyMSA/XG4gICAgICAgICAgICBmaWx0ZXIyID9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXIxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgJiYgZmlsdGVyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IDpcbiAgICAgICAgICAgICAgICBmaWx0ZXIxIDpcbiAgICAgICAgICAgIGZpbHRlcjI7XG4gICAgfVxuXG4gICAgdmFyIEFueVJhbmdlID0ge1xuICAgICAgICB0eXBlOiAzICxcbiAgICAgICAgbG93ZXI6IC1JbmZpbml0eSxcbiAgICAgICAgbG93ZXJPcGVuOiBmYWxzZSxcbiAgICAgICAgdXBwZXI6IFtbXV0sXG4gICAgICAgIHVwcGVyT3BlbjogZmFsc2VcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gd29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGtleVBhdGggPT09IFwic3RyaW5nXCIgJiYgIS9cXC4vLnRlc3Qoa2V5UGF0aClcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmpba2V5UGF0aF0gPT09IHVuZGVmaW5lZCAmJiAoa2V5UGF0aCBpbiBvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGRlZXBDbG9uZShvYmopO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2tleVBhdGhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmo7IH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRW50aXR5KCkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb25zLlR5cGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbXAoYSwgYikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHRhID0gdHlwZShhKTtcbiAgICAgICAgICAgIHZhciB0YiA9IHR5cGUoYik7XG4gICAgICAgICAgICBpZiAodGEgIT09IHRiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhID09PSAnQXJyYXknKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICBpZiAodGIgPT09ICdBcnJheScpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICBpZiAodGEgPT09ICdiaW5hcnknKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICBpZiAodGIgPT09ICdiaW5hcnknKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgaWYgKHRhID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgaWYgKHRiID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIGlmICh0YSA9PT0gJ0RhdGUnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICBpZiAodGIgIT09ICdEYXRlJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHRhKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdEYXRlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XG4gICAgICAgICAgICAgICAgY2FzZSAnYmluYXJ5Jzoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZVVpbnQ4QXJyYXlzKGdldFVpbnQ4QXJyYXkoYSksIGdldFVpbnQ4QXJyYXkoYikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlQXJyYXlzKGEsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYSwgYikge1xuICAgICAgICB2YXIgYWwgPSBhLmxlbmd0aDtcbiAgICAgICAgdmFyIGJsID0gYi5sZW5ndGg7XG4gICAgICAgIHZhciBsID0gYWwgPCBibCA/IGFsIDogYmw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gY21wKGFbaV0sIGJbaV0pO1xuICAgICAgICAgICAgaWYgKHJlcyAhPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbCA9PT0gYmwgPyAwIDogYWwgPCBibCA/IC0xIDogMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZVVpbnQ4QXJyYXlzKGEsIGIpIHtcbiAgICAgICAgdmFyIGFsID0gYS5sZW5ndGg7XG4gICAgICAgIHZhciBibCA9IGIubGVuZ3RoO1xuICAgICAgICB2YXIgbCA9IGFsIDwgYmwgPyBhbCA6IGJsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFbaV0gPCBiW2ldID8gLTEgOiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbCA9PT0gYmwgPyAwIDogYWwgPCBibCA/IC0xIDogMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHlwZSh4KSB7XG4gICAgICAgIHZhciB0ID0gdHlwZW9mIHg7XG4gICAgICAgIGlmICh0ICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHgpKVxuICAgICAgICAgICAgcmV0dXJuICdiaW5hcnknO1xuICAgICAgICB2YXIgdHNUYWcgPSB0b1N0cmluZ1RhZyh4KTtcbiAgICAgICAgcmV0dXJuIHRzVGFnID09PSAnQXJyYXlCdWZmZXInID8gJ2JpbmFyeScgOiB0c1RhZztcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VWludDhBcnJheShhKSB7XG4gICAgICAgIGlmIChhIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGEpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLCBhLmJ5dGVPZmZzZXQsIGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShhKTtcbiAgICB9XG5cbiAgICB2YXIgVGFibGUgPSAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVGFibGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgVGFibGUucHJvdG90eXBlLl90cmFucyA9IGZ1bmN0aW9uIChtb2RlLCBmbiwgd3JpdGVMb2NrZWQpIHtcbiAgICAgICAgICAgIHZhciB0cmFucyA9IHRoaXMuX3R4IHx8IFBTRC50cmFucztcbiAgICAgICAgICAgIHZhciB0YWJsZU5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgICAgICB2YXIgdGFzayA9IGRlYnVnICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLmNyZWF0ZVRhc2sgJiYgY29uc29sZS5jcmVhdGVUYXNrKFwiRGV4aWU6IFwiLmNvbmNhdChtb2RlID09PSAncmVhZG9ubHknID8gJ3JlYWQnIDogJ3dyaXRlJywgXCIgXCIpLmNvbmNhdCh0aGlzLm5hbWUpKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrVGFibGVJblRyYW5zYWN0aW9uKHJlc29sdmUsIHJlamVjdCwgdHJhbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRyYW5zLnNjaGVtYVt0YWJsZU5hbWVdKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5Ob3RGb3VuZChcIlRhYmxlIFwiICsgdGFibGVOYW1lICsgXCIgbm90IHBhcnQgb2YgdHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKHRyYW5zLmlkYnRyYW5zLCB0cmFucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgd2FzUm9vdEV4ZWMgPSBiZWdpbk1pY3JvVGlja1Njb3BlKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBwID0gdHJhbnMgJiYgdHJhbnMuZGIuX25vdmlwID09PSB0aGlzLmRiLl9ub3ZpcCA/XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zID09PSBQU0QudHJhbnMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnMuX3Byb21pc2UobW9kZSwgY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24sIHdyaXRlTG9ja2VkKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTY29wZShmdW5jdGlvbiAoKSB7IHJldHVybiB0cmFucy5fcHJvbWlzZShtb2RlLCBjaGVja1RhYmxlSW5UcmFuc2FjdGlvbiwgd3JpdGVMb2NrZWQpOyB9LCB7IHRyYW5zOiB0cmFucywgdHJhbnNsZXNzOiBQU0QudHJhbnNsZXNzIHx8IFBTRCB9KSA6XG4gICAgICAgICAgICAgICAgICAgIHRlbXBUcmFuc2FjdGlvbih0aGlzLmRiLCBtb2RlLCBbdGhpcy5uYW1lXSwgY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHAuX2NvbnNvbGVUYXNrID0gdGFzaztcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS50cmFjZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAod2FzUm9vdEV4ZWMpXG4gICAgICAgICAgICAgICAgICAgIGVuZE1pY3JvVGlja1Njb3BlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5T3JDcml0LCBjYikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmIChrZXlPckNyaXQgJiYga2V5T3JDcml0LmNvbnN0cnVjdG9yID09PSBPYmplY3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlcmUoa2V5T3JDcml0KS5maXJzdChjYik7XG4gICAgICAgICAgICBpZiAoa2V5T3JDcml0ID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5UeXBlKFwiSW52YWxpZCBhcmd1bWVudCB0byBUYWJsZS5nZXQoKVwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWRvbmx5JywgZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvcmUuZ2V0KHsgdHJhbnM6IHRyYW5zLCBrZXk6IGtleU9yQ3JpdCB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiBfdGhpcy5ob29rLnJlYWRpbmcuZmlyZShyZXMpOyB9KTtcbiAgICAgICAgICAgIH0pLnRoZW4oY2IpO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS5wcm90b3R5cGUud2hlcmUgPSBmdW5jdGlvbiAoaW5kZXhPckNyaXQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXhPckNyaXQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzLCBpbmRleE9yQ3JpdCk7XG4gICAgICAgICAgICBpZiAoaXNBcnJheShpbmRleE9yQ3JpdCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMsIFwiW1wiLmNvbmNhdChpbmRleE9yQ3JpdC5qb2luKCcrJyksIFwiXVwiKSk7XG4gICAgICAgICAgICB2YXIga2V5UGF0aHMgPSBrZXlzKGluZGV4T3JDcml0KTtcbiAgICAgICAgICAgIGlmIChrZXlQYXRocy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgLndoZXJlKGtleVBhdGhzWzBdKVxuICAgICAgICAgICAgICAgICAgICAuZXF1YWxzKGluZGV4T3JDcml0W2tleVBhdGhzWzBdXSk7XG4gICAgICAgICAgICB2YXIgY29tcG91bmRJbmRleCA9IHRoaXMuc2NoZW1hLmluZGV4ZXMuY29uY2F0KHRoaXMuc2NoZW1hLnByaW1LZXkpLmZpbHRlcihmdW5jdGlvbiAoaXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXguY29tcG91bmQgJiZcbiAgICAgICAgICAgICAgICAgICAga2V5UGF0aHMuZXZlcnkoZnVuY3Rpb24gKGtleVBhdGgpIHsgcmV0dXJuIGl4LmtleVBhdGguaW5kZXhPZihrZXlQYXRoKSA+PSAwOyB9KSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleVBhdGhzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UGF0aHMuaW5kZXhPZihpeC5rZXlQYXRoW2ldKSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmtleVBhdGgubGVuZ3RoIC0gYi5rZXlQYXRoLmxlbmd0aDsgfSlbMF07XG4gICAgICAgICAgICBpZiAoY29tcG91bmRJbmRleCAmJiB0aGlzLmRiLl9tYXhLZXkgIT09IG1heFN0cmluZykge1xuICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoc0luVmFsaWRPcmRlciA9IGNvbXBvdW5kSW5kZXgua2V5UGF0aC5zbGljZSgwLCBrZXlQYXRocy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIC53aGVyZShrZXlQYXRoc0luVmFsaWRPcmRlcilcbiAgICAgICAgICAgICAgICAgICAgLmVxdWFscyhrZXlQYXRoc0luVmFsaWRPcmRlci5tYXAoZnVuY3Rpb24gKGtwKSB7IHJldHVybiBpbmRleE9yQ3JpdFtrcF07IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY29tcG91bmRJbmRleCAmJiBkZWJ1ZylcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgcXVlcnkgXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KGluZGV4T3JDcml0KSwgXCIgb24gXCIpLmNvbmNhdCh0aGlzLm5hbWUsIFwiIHdvdWxkIGJlbmVmaXQgZnJvbSBhIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiY29tcG91bmQgaW5kZXggW1wiLmNvbmNhdChrZXlQYXRocy5qb2luKCcrJyksIFwiXVwiKSk7XG4gICAgICAgICAgICB2YXIgaWR4QnlOYW1lID0gdGhpcy5zY2hlbWEuaWR4QnlOYW1lO1xuICAgICAgICAgICAgdmFyIGlkYiA9IHRoaXMuZGIuX2RlcHMuaW5kZXhlZERCO1xuICAgICAgICAgICAgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWRiLmNtcChhLCBiKSA9PT0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYSA9IGtleVBhdGhzLnJlZHVjZShmdW5jdGlvbiAoX2EsIGtleVBhdGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldkluZGV4ID0gX2FbMF0sIHByZXZGaWx0ZXJGbiA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGlkeEJ5TmFtZVtrZXlQYXRoXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBpbmRleE9yQ3JpdFtrZXlQYXRoXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBwcmV2SW5kZXggfHwgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHByZXZJbmRleCB8fCAhaW5kZXggP1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tYmluZShwcmV2RmlsdGVyRm4sIGluZGV4ICYmIGluZGV4Lm11bHRpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IGdldEJ5S2V5UGF0aCh4LCBrZXlQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkocHJvcCkgJiYgcHJvcC5zb21lKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBlcXVhbHModmFsdWUsIGl0ZW0pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGVxdWFscyh2YWx1ZSwgZ2V0QnlLZXlQYXRoKHgsIGtleVBhdGgpKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcHJldkZpbHRlckZuXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0sIFtudWxsLCBudWxsXSksIGlkeCA9IF9hWzBdLCBmaWx0ZXJGdW5jdGlvbiA9IF9hWzFdO1xuICAgICAgICAgICAgcmV0dXJuIGlkeCA/XG4gICAgICAgICAgICAgICAgdGhpcy53aGVyZShpZHgubmFtZSkuZXF1YWxzKGluZGV4T3JDcml0W2lkeC5rZXlQYXRoXSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmaWx0ZXJGdW5jdGlvbikgOlxuICAgICAgICAgICAgICAgIGNvbXBvdW5kSW5kZXggP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcihmaWx0ZXJGdW5jdGlvbikgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLndoZXJlKGtleVBhdGhzKS5lcXVhbHMoJycpO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGZpbHRlckZ1bmN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5hbmQoZmlsdGVyRnVuY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAodGhlblNob3J0Y3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5jb3VudCh0aGVuU2hvcnRjdXQpO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkub2Zmc2V0KG9mZnNldCk7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlLnByb3RvdHlwZS5saW1pdCA9IGZ1bmN0aW9uIChudW1Sb3dzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5saW1pdChudW1Sb3dzKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGUucHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLmVhY2goY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICh0aGVuU2hvcnRjdXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLnRvQXJyYXkodGhlblNob3J0Y3V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGUucHJvdG90eXBlLnRvQ29sbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5kYi5Db2xsZWN0aW9uKG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMpKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGUucHJvdG90eXBlLm9yZGVyQnkgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5kYi5Db2xsZWN0aW9uKG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMsIGlzQXJyYXkoaW5kZXgpID9cbiAgICAgICAgICAgICAgICBcIltcIi5jb25jYXQoaW5kZXguam9pbignKycpLCBcIl1cIikgOlxuICAgICAgICAgICAgICAgIGluZGV4KSk7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkucmV2ZXJzZSgpO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS5wcm90b3R5cGUubWFwVG9DbGFzcyA9IGZ1bmN0aW9uIChjb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcywgZGIgPSBfYS5kYiwgdGFibGVOYW1lID0gX2EubmFtZTtcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hLm1hcHBlZENsYXNzID0gY29uc3RydWN0b3I7XG4gICAgICAgICAgICBpZiAoY29uc3RydWN0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgRW50aXR5KSB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3IgPSAgKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzEucHJvdG90eXBlLCBcImRiXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGI7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUudGFibGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0YWJsZU5hbWU7IH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgICAgICAgICAgICAgIH0oY29uc3RydWN0b3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbmhlcml0ZWRQcm9wcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3RvID0gY29uc3RydWN0b3IucHJvdG90eXBlOyBwcm90bzsgcHJvdG8gPSBnZXRQcm90byhwcm90bykpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90bykuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHsgcmV0dXJuIGluaGVyaXRlZFByb3BzLmFkZChwcm9wTmFtZSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlYWRIb29rID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIGlmICghb2JqKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbSBpbiBvYmopXG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5oZXJpdGVkUHJvcHMuaGFzKG0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNbbV0gPSBvYmpbbV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5zY2hlbWEucmVhZEhvb2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhvb2sucmVhZGluZy51bnN1YnNjcmliZSh0aGlzLnNjaGVtYS5yZWFkSG9vayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNjaGVtYS5yZWFkSG9vayA9IHJlYWRIb29rO1xuICAgICAgICAgICAgdGhpcy5ob29rKFwicmVhZGluZ1wiLCByZWFkSG9vayk7XG4gICAgICAgICAgICByZXR1cm4gY29uc3RydWN0b3I7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlLnByb3RvdHlwZS5kZWZpbmVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIENsYXNzKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBleHRlbmQodGhpcywgY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBUb0NsYXNzKENsYXNzKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuc2NoZW1hLnByaW1LZXksIGF1dG8gPSBfYS5hdXRvLCBrZXlQYXRoID0gX2Eua2V5UGF0aDtcbiAgICAgICAgICAgIHZhciBvYmpUb0FkZCA9IG9iajtcbiAgICAgICAgICAgIGlmIChrZXlQYXRoICYmIGF1dG8pIHtcbiAgICAgICAgICAgICAgICBvYmpUb0FkZCA9IHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICh0cmFucykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zOiB0cmFucywgdHlwZTogJ2FkZCcsIGtleXM6IGtleSAhPSBudWxsID8gW2tleV0gOiBudWxsLCB2YWx1ZXM6IFtvYmpUb0FkZF0gfSk7XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHJlcy5udW1GYWlsdXJlcyA/IERleGllUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKSA6IHJlcy5sYXN0UmVzdWx0OyB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChsYXN0UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIGxhc3RSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChrZXlPck9iamVjdCwgbW9kaWZpY2F0aW9ucykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXlPck9iamVjdCA9PT0gJ29iamVjdCcgJiYgIWlzQXJyYXkoa2V5T3JPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGdldEJ5S2V5UGF0aChrZXlPck9iamVjdCwgdGhpcy5zY2hlbWEucHJpbUtleS5rZXlQYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiR2l2ZW4gb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gaXRzIHByaW1hcnkga2V5XCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53aGVyZShcIjppZFwiKS5lcXVhbHMoa2V5KS5tb2RpZnkobW9kaWZpY2F0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53aGVyZShcIjppZFwiKS5lcXVhbHMoa2V5T3JPYmplY3QpLm1vZGlmeShtb2RpZmljYXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgVGFibGUucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuc2NoZW1hLnByaW1LZXksIGF1dG8gPSBfYS5hdXRvLCBrZXlQYXRoID0gX2Eua2V5UGF0aDtcbiAgICAgICAgICAgIHZhciBvYmpUb0FkZCA9IG9iajtcbiAgICAgICAgICAgIGlmIChrZXlQYXRoICYmIGF1dG8pIHtcbiAgICAgICAgICAgICAgICBvYmpUb0FkZCA9IHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICh0cmFucykgeyByZXR1cm4gX3RoaXMuY29yZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdwdXQnLCB2YWx1ZXM6IFtvYmpUb0FkZF0sIGtleXM6IGtleSAhPSBudWxsID8gW2tleV0gOiBudWxsIH0pOyB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHJlcy5udW1GYWlsdXJlcyA/IERleGllUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKSA6IHJlcy5sYXN0UmVzdWx0OyB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChsYXN0UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIGxhc3RSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGUucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICh0cmFucykgeyByZXR1cm4gX3RoaXMuY29yZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdkZWxldGUnLCBrZXlzOiBba2V5XSB9KTsgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMubnVtRmFpbHVyZXMgPyBEZXhpZVByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiB1bmRlZmluZWQ7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAodHJhbnMpIHsgcmV0dXJuIF90aGlzLmNvcmUubXV0YXRlKHsgdHJhbnM6IHRyYW5zLCB0eXBlOiAnZGVsZXRlUmFuZ2UnLCByYW5nZTogQW55UmFuZ2UgfSk7IH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcmVzLm51bUZhaWx1cmVzID8gRGV4aWVQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pIDogdW5kZWZpbmVkOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGUucHJvdG90eXBlLmJ1bGtHZXQgPSBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZG9ubHknLCBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29yZS5nZXRNYW55KHtcbiAgICAgICAgICAgICAgICAgICAga2V5czoga2V5cyxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnM6IHRyYW5zXG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQubWFwKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIF90aGlzLmhvb2sucmVhZGluZy5maXJlKHJlcyk7IH0pOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS5wcm90b3R5cGUuYnVsa0FkZCA9IGZ1bmN0aW9uIChvYmplY3RzLCBrZXlzT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGtleXMgPSBBcnJheS5pc0FycmF5KGtleXNPck9wdGlvbnMpID8ga2V5c09yT3B0aW9ucyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IChrZXlzID8gdW5kZWZpbmVkIDoga2V5c09yT3B0aW9ucyk7XG4gICAgICAgICAgICB2YXIgd2FudFJlc3VsdHMgPSBvcHRpb25zID8gb3B0aW9ucy5hbGxLZXlzIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5zY2hlbWEucHJpbUtleSwgYXV0byA9IF9hLmF1dG8sIGtleVBhdGggPSBfYS5rZXlQYXRoO1xuICAgICAgICAgICAgICAgIGlmIChrZXlQYXRoICYmIGtleXMpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcImJ1bGtBZGQoKToga2V5cyBhcmd1bWVudCBpbnZhbGlkIG9uIHRhYmxlcyB3aXRoIGluYm91bmQga2V5c1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cyAmJiBrZXlzLmxlbmd0aCAhPT0gb2JqZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkFyZ3VtZW50cyBvYmplY3RzIGFuZCBrZXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7XG4gICAgICAgICAgICAgICAgdmFyIG51bU9iamVjdHMgPSBvYmplY3RzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0c1RvQWRkID0ga2V5UGF0aCAmJiBhdXRvID9cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0cy5tYXAod29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkpIDpcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0cztcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29yZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdhZGQnLCBrZXlzOiBrZXlzLCB2YWx1ZXM6IG9iamVjdHNUb0FkZCwgd2FudFJlc3VsdHM6IHdhbnRSZXN1bHRzIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtRmFpbHVyZXMgPSBfYS5udW1GYWlsdXJlcywgcmVzdWx0cyA9IF9hLnJlc3VsdHMsIGxhc3RSZXN1bHQgPSBfYS5sYXN0UmVzdWx0LCBmYWlsdXJlcyA9IF9hLmZhaWx1cmVzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gd2FudFJlc3VsdHMgPyByZXN1bHRzIDogbGFzdFJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJ1bGtFcnJvcihcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi5idWxrQWRkKCk6IFwiKS5jb25jYXQobnVtRmFpbHVyZXMsIFwiIG9mIFwiKS5jb25jYXQobnVtT2JqZWN0cywgXCIgb3BlcmF0aW9ucyBmYWlsZWRcIiksIGZhaWx1cmVzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS5wcm90b3R5cGUuYnVsa1B1dCA9IGZ1bmN0aW9uIChvYmplY3RzLCBrZXlzT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGtleXMgPSBBcnJheS5pc0FycmF5KGtleXNPck9wdGlvbnMpID8ga2V5c09yT3B0aW9ucyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IChrZXlzID8gdW5kZWZpbmVkIDoga2V5c09yT3B0aW9ucyk7XG4gICAgICAgICAgICB2YXIgd2FudFJlc3VsdHMgPSBvcHRpb25zID8gb3B0aW9ucy5hbGxLZXlzIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5zY2hlbWEucHJpbUtleSwgYXV0byA9IF9hLmF1dG8sIGtleVBhdGggPSBfYS5rZXlQYXRoO1xuICAgICAgICAgICAgICAgIGlmIChrZXlQYXRoICYmIGtleXMpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcImJ1bGtQdXQoKToga2V5cyBhcmd1bWVudCBpbnZhbGlkIG9uIHRhYmxlcyB3aXRoIGluYm91bmQga2V5c1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cyAmJiBrZXlzLmxlbmd0aCAhPT0gb2JqZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkFyZ3VtZW50cyBvYmplY3RzIGFuZCBrZXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7XG4gICAgICAgICAgICAgICAgdmFyIG51bU9iamVjdHMgPSBvYmplY3RzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0c1RvUHV0ID0ga2V5UGF0aCAmJiBhdXRvID9cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0cy5tYXAod29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkpIDpcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0cztcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29yZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdwdXQnLCBrZXlzOiBrZXlzLCB2YWx1ZXM6IG9iamVjdHNUb1B1dCwgd2FudFJlc3VsdHM6IHdhbnRSZXN1bHRzIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtRmFpbHVyZXMgPSBfYS5udW1GYWlsdXJlcywgcmVzdWx0cyA9IF9hLnJlc3VsdHMsIGxhc3RSZXN1bHQgPSBfYS5sYXN0UmVzdWx0LCBmYWlsdXJlcyA9IF9hLmZhaWx1cmVzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gd2FudFJlc3VsdHMgPyByZXN1bHRzIDogbGFzdFJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJ1bGtFcnJvcihcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi5idWxrUHV0KCk6IFwiKS5jb25jYXQobnVtRmFpbHVyZXMsIFwiIG9mIFwiKS5jb25jYXQobnVtT2JqZWN0cywgXCIgb3BlcmF0aW9ucyBmYWlsZWRcIiksIGZhaWx1cmVzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS5wcm90b3R5cGUuYnVsa1VwZGF0ZSA9IGZ1bmN0aW9uIChrZXlzQW5kQ2hhbmdlcykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjb3JlVGFibGUgPSB0aGlzLmNvcmU7XG4gICAgICAgICAgICB2YXIga2V5cyA9IGtleXNBbmRDaGFuZ2VzLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5LmtleTsgfSk7XG4gICAgICAgICAgICB2YXIgY2hhbmdlU3BlY3MgPSBrZXlzQW5kQ2hhbmdlcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeS5jaGFuZ2VzOyB9KTtcbiAgICAgICAgICAgIHZhciBvZmZzZXRNYXAgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcmVUYWJsZS5nZXRNYW55KHsgdHJhbnM6IHRyYW5zLCBrZXlzOiBrZXlzLCBjYWNoZTogJ2Nsb25lJyB9KS50aGVuKGZ1bmN0aW9uIChvYmpzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRLZXlzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRPYmpzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGtleXNBbmRDaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKF9hLCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfYS5rZXksIGNoYW5nZXMgPSBfYS5jaGFuZ2VzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IG9ianNbaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9iID0gT2JqZWN0LmtleXMoY2hhbmdlcyk7IF9pIDwgX2IubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoID0gX2JbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjaGFuZ2VzW2tleVBhdGhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UGF0aCA9PT0gX3RoaXMuc2NoZW1hLnByaW1LZXkua2V5UGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNtcCh2YWx1ZSwga2V5KSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkNvbnN0cmFpbnQoXCJDYW5ub3QgdXBkYXRlIHByaW1hcnkga2V5IGluIGJ1bGtVcGRhdGUoKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRNYXAucHVzaChpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdEtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdE9ianMucHVzaChvYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bUVudHJpZXMgPSByZXN1bHRLZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmVUYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncHV0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IHJlc3VsdEtleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHJlc3VsdE9ianMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5czoga2V5cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VTcGVjczogY2hhbmdlU3BlY3NcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG51bUZhaWx1cmVzID0gX2EubnVtRmFpbHVyZXMsIGZhaWx1cmVzID0gX2EuZmFpbHVyZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtRmFpbHVyZXMgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bUVudHJpZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9iID0gT2JqZWN0LmtleXMoZmFpbHVyZXMpOyBfaSA8IF9iLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBfYltfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcHBlZE9mZnNldCA9IG9mZnNldE1hcFtOdW1iZXIob2Zmc2V0KV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcHBlZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWlsdXJlID0gZmFpbHVyZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGZhaWx1cmVzW29mZnNldF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmVzW21hcHBlZE9mZnNldF0gPSBmYWlsdXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCdWxrRXJyb3IoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCIuYnVsa1VwZGF0ZSgpOiBcIikuY29uY2F0KG51bUZhaWx1cmVzLCBcIiBvZiBcIikuY29uY2F0KG51bUVudHJpZXMsIFwiIG9wZXJhdGlvbnMgZmFpbGVkXCIpLCBmYWlsdXJlcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlLnByb3RvdHlwZS5idWxrRGVsZXRlID0gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgbnVtS2V5cyA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29yZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdkZWxldGUnLCBrZXlzOiBrZXlzIH0pO1xuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgbnVtRmFpbHVyZXMgPSBfYS5udW1GYWlsdXJlcywgbGFzdFJlc3VsdCA9IF9hLmxhc3RSZXN1bHQsIGZhaWx1cmVzID0gX2EuZmFpbHVyZXM7XG4gICAgICAgICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQnVsa0Vycm9yKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLmJ1bGtEZWxldGUoKTogXCIpLmNvbmNhdChudW1GYWlsdXJlcywgXCIgb2YgXCIpLmNvbmNhdChudW1LZXlzLCBcIiBvcGVyYXRpb25zIGZhaWxlZFwiKSwgZmFpbHVyZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUYWJsZTtcbiAgICB9KCkpO1xuXG4gICAgZnVuY3Rpb24gRXZlbnRzKGN0eCkge1xuICAgICAgICB2YXIgZXZzID0ge307XG4gICAgICAgIHZhciBydiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGkgLSAxKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoLS1pKVxuICAgICAgICAgICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICBldnNbZXZlbnROYW1lXS5zdWJzY3JpYmUuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoZXZlbnROYW1lKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJ2LmFkZEV2ZW50VHlwZSA9IGFkZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBhZGQoYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgIGZ1bmN0aW9uIGFkZChldmVudE5hbWUsIGNoYWluRnVuY3Rpb24sIGRlZmF1bHRGdW5jdGlvbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgICAgIHJldHVybiBhZGRDb25maWd1cmVkRXZlbnRzKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICBpZiAoIWNoYWluRnVuY3Rpb24pXG4gICAgICAgICAgICAgICAgY2hhaW5GdW5jdGlvbiA9IHJldmVyc2VTdG9wcGFibGVFdmVudENoYWluO1xuICAgICAgICAgICAgaWYgKCFkZWZhdWx0RnVuY3Rpb24pXG4gICAgICAgICAgICAgICAgZGVmYXVsdEZ1bmN0aW9uID0gbm9wO1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcnM6IFtdLFxuICAgICAgICAgICAgICAgIGZpcmU6IGRlZmF1bHRGdW5jdGlvbixcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5zdWJzY3JpYmVycy5pbmRleE9mKGNiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaWJlcnMucHVzaChjYik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpcmUgPSBjaGFpbkZ1bmN0aW9uKGNvbnRleHQuZmlyZSwgY2IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaWJlcnMgPSBjb250ZXh0LnN1YnNjcmliZXJzLmZpbHRlcihmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuICE9PSBjYjsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlyZSA9IGNvbnRleHQuc3Vic2NyaWJlcnMucmVkdWNlKGNoYWluRnVuY3Rpb24sIGRlZmF1bHRGdW5jdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV2c1tldmVudE5hbWVdID0gcnZbZXZlbnROYW1lXSA9IGNvbnRleHQ7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRDb25maWd1cmVkRXZlbnRzKGNmZykge1xuICAgICAgICAgICAga2V5cyhjZmcpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gY2ZnW2V2ZW50TmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoYXJncykpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkKGV2ZW50TmFtZSwgY2ZnW2V2ZW50TmFtZV1bMF0sIGNmZ1tldmVudE5hbWVdWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJncyA9PT0gJ2FzYXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gYWRkKGV2ZW50TmFtZSwgbWlycm9yLCBmdW5jdGlvbiBmaXJlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzYXAkMShmdW5jdGlvbiBmaXJlRXZlbnQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkludmFsaWQgZXZlbnQgY29uZmlnXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQ2xhc3NDb25zdHJ1Y3Rvcihwcm90b3R5cGUsIGNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGRlcml2ZShjb25zdHJ1Y3RvcikuZnJvbSh7IHByb3RvdHlwZTogcHJvdG90eXBlIH0pO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0b3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVGFibGVDb25zdHJ1Y3RvcihkYikge1xuICAgICAgICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3IoVGFibGUucHJvdG90eXBlLCBmdW5jdGlvbiBUYWJsZShuYW1lLCB0YWJsZVNjaGVtYSwgdHJhbnMpIHtcbiAgICAgICAgICAgIHRoaXMuZGIgPSBkYjtcbiAgICAgICAgICAgIHRoaXMuX3R4ID0gdHJhbnM7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5zY2hlbWEgPSB0YWJsZVNjaGVtYTtcbiAgICAgICAgICAgIHRoaXMuaG9vayA9IGRiLl9hbGxUYWJsZXNbbmFtZV0gPyBkYi5fYWxsVGFibGVzW25hbWVdLmhvb2sgOiBFdmVudHMobnVsbCwge1xuICAgICAgICAgICAgICAgIFwiY3JlYXRpbmdcIjogW2hvb2tDcmVhdGluZ0NoYWluLCBub3BdLFxuICAgICAgICAgICAgICAgIFwicmVhZGluZ1wiOiBbcHVyZUZ1bmN0aW9uQ2hhaW4sIG1pcnJvcl0sXG4gICAgICAgICAgICAgICAgXCJ1cGRhdGluZ1wiOiBbaG9va1VwZGF0aW5nQ2hhaW4sIG5vcF0sXG4gICAgICAgICAgICAgICAgXCJkZWxldGluZ1wiOiBbaG9va0RlbGV0aW5nQ2hhaW4sIG5vcF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1BsYWluS2V5UmFuZ2UoY3R4LCBpZ25vcmVMaW1pdEZpbHRlcikge1xuICAgICAgICByZXR1cm4gIShjdHguZmlsdGVyIHx8IGN0eC5hbGdvcml0aG0gfHwgY3R4Lm9yKSAmJlxuICAgICAgICAgICAgKGlnbm9yZUxpbWl0RmlsdGVyID8gY3R4Lmp1c3RMaW1pdCA6ICFjdHgucmVwbGF5RmlsdGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkRmlsdGVyKGN0eCwgZm4pIHtcbiAgICAgICAgY3R4LmZpbHRlciA9IGNvbWJpbmUoY3R4LmZpbHRlciwgZm4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRSZXBsYXlGaWx0ZXIoY3R4LCBmYWN0b3J5LCBpc0xpbWl0RmlsdGVyKSB7XG4gICAgICAgIHZhciBjdXJyID0gY3R4LnJlcGxheUZpbHRlcjtcbiAgICAgICAgY3R4LnJlcGxheUZpbHRlciA9IGN1cnIgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21iaW5lKGN1cnIoKSwgZmFjdG9yeSgpKTsgfSA6IGZhY3Rvcnk7XG4gICAgICAgIGN0eC5qdXN0TGltaXQgPSBpc0xpbWl0RmlsdGVyICYmICFjdXJyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRNYXRjaEZpbHRlcihjdHgsIGZuKSB7XG4gICAgICAgIGN0eC5pc01hdGNoID0gY29tYmluZShjdHguaXNNYXRjaCwgZm4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRJbmRleE9yU3RvcmUoY3R4LCBjb3JlU2NoZW1hKSB7XG4gICAgICAgIGlmIChjdHguaXNQcmltS2V5KVxuICAgICAgICAgICAgcmV0dXJuIGNvcmVTY2hlbWEucHJpbWFyeUtleTtcbiAgICAgICAgdmFyIGluZGV4ID0gY29yZVNjaGVtYS5nZXRJbmRleEJ5S2V5UGF0aChjdHguaW5kZXgpO1xuICAgICAgICBpZiAoIWluZGV4KVxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiS2V5UGF0aCBcIiArIGN0eC5pbmRleCArIFwiIG9uIG9iamVjdCBzdG9yZSBcIiArIGNvcmVTY2hlbWEubmFtZSArIFwiIGlzIG5vdCBpbmRleGVkXCIpO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9wZW5DdXJzb3IoY3R4LCBjb3JlVGFibGUsIHRyYW5zKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4T3JTdG9yZShjdHgsIGNvcmVUYWJsZS5zY2hlbWEpO1xuICAgICAgICByZXR1cm4gY29yZVRhYmxlLm9wZW5DdXJzb3Ioe1xuICAgICAgICAgICAgdHJhbnM6IHRyYW5zLFxuICAgICAgICAgICAgdmFsdWVzOiAhY3R4LmtleXNPbmx5LFxuICAgICAgICAgICAgcmV2ZXJzZTogY3R4LmRpciA9PT0gJ3ByZXYnLFxuICAgICAgICAgICAgdW5pcXVlOiAhIWN0eC51bmlxdWUsXG4gICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpdGVyKGN0eCwgZm4sIGNvcmVUcmFucywgY29yZVRhYmxlKSB7XG4gICAgICAgIHZhciBmaWx0ZXIgPSBjdHgucmVwbGF5RmlsdGVyID8gY29tYmluZShjdHguZmlsdGVyLCBjdHgucmVwbGF5RmlsdGVyKCkpIDogY3R4LmZpbHRlcjtcbiAgICAgICAgaWYgKCFjdHgub3IpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRlKG9wZW5DdXJzb3IoY3R4LCBjb3JlVGFibGUsIGNvcmVUcmFucyksIGNvbWJpbmUoY3R4LmFsZ29yaXRobSwgZmlsdGVyKSwgZm4sICFjdHgua2V5c09ubHkgJiYgY3R4LnZhbHVlTWFwcGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzZXRfMSA9IHt9O1xuICAgICAgICAgICAgdmFyIHVuaW9uID0gZnVuY3Rpb24gKGl0ZW0sIGN1cnNvciwgYWR2YW5jZSkge1xuICAgICAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihjdXJzb3IsIGFkdmFuY2UsIGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIGN1cnNvci5zdG9wKHJlc3VsdCk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIGN1cnNvci5mYWlsKGVycik7IH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmltYXJ5S2V5ID0gY3Vyc29yLnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSAnJyArIHByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSAnJyArIG5ldyBVaW50OEFycmF5KHByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc093bihzZXRfMSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0XzFba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbihpdGVtLCBjdXJzb3IsIGFkdmFuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgY3R4Lm9yLl9pdGVyYXRlKHVuaW9uLCBjb3JlVHJhbnMpLFxuICAgICAgICAgICAgICAgIGl0ZXJhdGUob3BlbkN1cnNvcihjdHgsIGNvcmVUYWJsZSwgY29yZVRyYW5zKSwgY3R4LmFsZ29yaXRobSwgdW5pb24sICFjdHgua2V5c09ubHkgJiYgY3R4LnZhbHVlTWFwcGVyKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXRlcmF0ZShjdXJzb3JQcm9taXNlLCBmaWx0ZXIsIGZuLCB2YWx1ZU1hcHBlcikge1xuICAgICAgICB2YXIgbWFwcGVkRm4gPSB2YWx1ZU1hcHBlciA/IGZ1bmN0aW9uICh4LCBjLCBhKSB7IHJldHVybiBmbih2YWx1ZU1hcHBlcih4KSwgYywgYSk7IH0gOiBmbjtcbiAgICAgICAgdmFyIHdyYXBwZWRGbiA9IHdyYXAobWFwcGVkRm4pO1xuICAgICAgICByZXR1cm4gY3Vyc29yUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChjdXJzb3IpIHtcbiAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yLnN0YXJ0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjdXJzb3IuY29udGludWUoKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGN1cnNvciwgZnVuY3Rpb24gKGFkdmFuY2VyKSB7IHJldHVybiBjID0gYWR2YW5jZXI7IH0sIGZ1bmN0aW9uICh2YWwpIHsgY3Vyc29yLnN0b3AodmFsKTsgYyA9IG5vcDsgfSwgZnVuY3Rpb24gKGUpIHsgY3Vyc29yLmZhaWwoZSk7IGMgPSBub3A7IH0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlZEZuKGN1cnNvci52YWx1ZSwgY3Vyc29yLCBmdW5jdGlvbiAoYWR2YW5jZXIpIHsgcmV0dXJuIGMgPSBhZHZhbmNlcjsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGMoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIFByb3BNb2RTeW1ib2wgPSBTeW1ib2woKTtcbiAgICB2YXIgUHJvcE1vZGlmaWNhdGlvbiA9ICAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQcm9wTW9kaWZpY2F0aW9uKHNwZWMpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgc3BlYyk7XG4gICAgICAgIH1cbiAgICAgICAgUHJvcE1vZGlmaWNhdGlvbi5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWRkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVybSA9IHRoaXMuYWRkO1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHRlcm0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIChpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10pLCB0cnVlKSwgdGVybSwgdHJ1ZSkuc29ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlcm0gPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKE51bWJlcih2YWx1ZSkgfHwgMCkgKyB0ZXJtO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVybSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpICsgdGVybTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoX2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQoMCkgKyB0ZXJtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHRlcm0gXCIuY29uY2F0KHRlcm0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnJlbW92ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnRyYWhlbmRfMSA9IHRoaXMucmVtb3ZlO1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHN1YnRyYWhlbmRfMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAhc3VidHJhaGVuZF8xLmluY2x1ZGVzKGl0ZW0pOyB9KS5zb3J0KCkgOiBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdWJ0cmFoZW5kXzEgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKSAtIHN1YnRyYWhlbmRfMTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN1YnRyYWhlbmRfMSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpIC0gc3VidHJhaGVuZF8xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChfYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCgwKSAtIHN1YnRyYWhlbmRfMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBzdWJ0cmFoZW5kIFwiLmNvbmNhdChzdWJ0cmFoZW5kXzEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmVmaXhUb1JlcGxhY2UgPSAoX2EgPSB0aGlzLnJlcGxhY2VQcmVmaXgpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXTtcbiAgICAgICAgICAgIGlmIChwcmVmaXhUb1JlcGxhY2UgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5zdGFydHNXaXRoKHByZWZpeFRvUmVwbGFjZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlUHJlZml4WzFdICsgdmFsdWUuc3Vic3RyaW5nKHByZWZpeFRvUmVwbGFjZS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUHJvcE1vZGlmaWNhdGlvbjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIENvbGxlY3Rpb24gPSAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29sbGVjdGlvbigpIHtcbiAgICAgICAgfVxuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChmbiwgY2IpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgICByZXR1cm4gY3R4LmVycm9yID9cbiAgICAgICAgICAgICAgICBjdHgudGFibGUuX3RyYW5zKG51bGwsIHJlamVjdGlvbi5iaW5kKG51bGwsIGN0eC5lcnJvcikpIDpcbiAgICAgICAgICAgICAgICBjdHgudGFibGUuX3RyYW5zKCdyZWFkb25seScsIGZuKS50aGVuKGNiKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5lcnJvciA/XG4gICAgICAgICAgICAgICAgY3R4LnRhYmxlLl90cmFucyhudWxsLCByZWplY3Rpb24uYmluZChudWxsLCBjdHguZXJyb3IpKSA6XG4gICAgICAgICAgICAgICAgY3R4LnRhYmxlLl90cmFucygncmVhZHdyaXRlJywgZm4sIFwibG9ja2VkXCIpO1xuICAgICAgICB9O1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5fYWRkQWxnb3JpdGhtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgY3R4LmFsZ29yaXRobSA9IGNvbWJpbmUoY3R4LmFsZ29yaXRobSwgZm4pO1xuICAgICAgICB9O1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5faXRlcmF0ZSA9IGZ1bmN0aW9uIChmbiwgY29yZVRyYW5zKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlcih0aGlzLl9jdHgsIGZuLCBjb3JlVHJhbnMsIHRoaXMuX2N0eC50YWJsZS5jb3JlKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgICAgIHZhciBydiA9IE9iamVjdC5jcmVhdGUodGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpLCBjdHggPSBPYmplY3QuY3JlYXRlKHRoaXMuX2N0eCk7XG4gICAgICAgICAgICBpZiAocHJvcHMpXG4gICAgICAgICAgICAgICAgZXh0ZW5kKGN0eCwgcHJvcHMpO1xuICAgICAgICAgICAgcnYuX2N0eCA9IGN0eDtcbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUucmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fY3R4LnZhbHVlTWFwcGVyID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQoZnVuY3Rpb24gKHRyYW5zKSB7IHJldHVybiBpdGVyKGN0eCwgZm4sIHRyYW5zLCBjdHgudGFibGUuY29yZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkKGZ1bmN0aW9uICh0cmFucykge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSBfdGhpcy5fY3R4O1xuICAgICAgICAgICAgICAgIHZhciBjb3JlVGFibGUgPSBjdHgudGFibGUuY29yZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQbGFpbktleVJhbmdlKGN0eCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmVUYWJsZS5jb3VudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBnZXRJbmRleE9yU3RvcmUoY3R4LCBjb3JlVGFibGUuc2NoZW1hKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvdW50KSB7IHJldHVybiBNYXRoLm1pbihjb3VudCwgY3R4LmxpbWl0KTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlcihjdHgsIGZ1bmN0aW9uICgpIHsgKytjb3VudDsgcmV0dXJuIGZhbHNlOyB9LCB0cmFucywgY29yZVRhYmxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gY291bnQ7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLnRoZW4oY2IpO1xuICAgICAgICB9O1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5zb3J0QnkgPSBmdW5jdGlvbiAoa2V5UGF0aCwgY2IpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IGtleVBhdGguc3BsaXQoJy4nKS5yZXZlcnNlKCksIGxhc3RQYXJ0ID0gcGFydHNbMF0sIGxhc3RJbmRleCA9IHBhcnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXR2YWwob2JqLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXR2YWwob2JqW3BhcnRzW2ldXSwgaSAtIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmpbbGFzdFBhcnRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9yZGVyID0gdGhpcy5fY3R4LmRpciA9PT0gXCJuZXh0XCIgPyAxIDogLTE7XG4gICAgICAgICAgICBmdW5jdGlvbiBzb3J0ZXIoYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBhVmFsID0gZ2V0dmFsKGEsIGxhc3RJbmRleCksIGJWYWwgPSBnZXR2YWwoYiwgbGFzdEluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYVZhbCA8IGJWYWwgPyAtb3JkZXIgOiBhVmFsID4gYlZhbCA/IG9yZGVyIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5zb3J0KHNvcnRlcik7XG4gICAgICAgICAgICB9KS50aGVuKGNiKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkKGZ1bmN0aW9uICh0cmFucykge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSBfdGhpcy5fY3R4O1xuICAgICAgICAgICAgICAgIGlmIChjdHguZGlyID09PSAnbmV4dCcgJiYgaXNQbGFpbktleVJhbmdlKGN0eCwgdHJ1ZSkgJiYgY3R4LmxpbWl0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVNYXBwZXJfMSA9IGN0eC52YWx1ZU1hcHBlcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhPclN0b3JlKGN0eCwgY3R4LnRhYmxlLmNvcmUuc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zOiB0cmFucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0OiBjdHgubGltaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gX2EucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlTWFwcGVyXzEgPyByZXN1bHQubWFwKHZhbHVlTWFwcGVyXzEpIDogcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhXzEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXIoY3R4LCBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gYV8xLnB1c2goaXRlbSk7IH0sIHRyYW5zLCBjdHgudGFibGUuY29yZSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBhXzE7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGNiKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPD0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGN0eC5vZmZzZXQgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGlzUGxhaW5LZXlSYW5nZShjdHgpKSB7XG4gICAgICAgICAgICAgICAgYWRkUmVwbGF5RmlsdGVyKGN0eCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXRMZWZ0ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldExlZnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLW9mZnNldExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmFkdmFuY2Uob2Zmc2V0TGVmdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZFJlcGxheUZpbHRlcihjdHgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldExlZnQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiAoLS1vZmZzZXRMZWZ0IDwgMCk7IH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUubGltaXQgPSBmdW5jdGlvbiAobnVtUm93cykge1xuICAgICAgICAgICAgdGhpcy5fY3R4LmxpbWl0ID0gTWF0aC5taW4odGhpcy5fY3R4LmxpbWl0LCBudW1Sb3dzKTtcbiAgICAgICAgICAgIGFkZFJlcGxheUZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93c0xlZnQgPSBudW1Sb3dzO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgtLXJvd3NMZWZ0IDw9IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm93c0xlZnQgPj0gMDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUudW50aWwgPSBmdW5jdGlvbiAoZmlsdGVyRnVuY3Rpb24sIGJJbmNsdWRlU3RvcEVudHJ5KSB7XG4gICAgICAgICAgICBhZGRGaWx0ZXIodGhpcy5fY3R4LCBmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlckZ1bmN0aW9uKGN1cnNvci52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJJbmNsdWRlU3RvcEVudHJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZmlyc3QgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbWl0KDEpLnRvQXJyYXkoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFbMF07IH0pLnRoZW4oY2IpO1xuICAgICAgICB9O1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmlyc3QoY2IpO1xuICAgICAgICB9O1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoZmlsdGVyRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGFkZEZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyRnVuY3Rpb24oY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWRkTWF0Y2hGaWx0ZXIodGhpcy5fY3R4LCBmaWx0ZXJGdW5jdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZpbHRlcik7XG4gICAgICAgIH07XG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKGluZGV4TmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMuX2N0eC50YWJsZSwgaW5kZXhOYW1lLCB0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2N0eC5kaXIgPSAodGhpcy5fY3R4LmRpciA9PT0gXCJwcmV2XCIgPyBcIm5leHRcIiA6IFwicHJldlwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vbmRpcmVjdGlvbmNoYW5nZSlcbiAgICAgICAgICAgICAgICB0aGlzLl9vbmRpcmVjdGlvbmNoYW5nZSh0aGlzLl9jdHguZGlyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5kZXNjID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpO1xuICAgICAgICB9O1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5lYWNoS2V5ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodmFsLCBjdXJzb3IpIHsgY2IoY3Vyc29yLmtleSwgY3Vyc29yKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmVhY2hVbmlxdWVLZXkgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHRoaXMuX2N0eC51bmlxdWUgPSBcInVuaXF1ZVwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaEtleShjYik7XG4gICAgICAgIH07XG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmVhY2hQcmltYXJ5S2V5ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodmFsLCBjdXJzb3IpIHsgY2IoY3Vyc29yLnByaW1hcnlLZXksIGN1cnNvcik7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuICAgICAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGl0ZW0sIGN1cnNvcikge1xuICAgICAgICAgICAgICAgIGEucHVzaChjdXJzb3Iua2V5KTtcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfSkudGhlbihjYik7XG4gICAgICAgIH07XG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnByaW1hcnlLZXlzID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgaWYgKGN0eC5kaXIgPT09ICduZXh0JyAmJiBpc1BsYWluS2V5UmFuZ2UoY3R4LCB0cnVlKSAmJiBjdHgubGltaXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQoZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4T3JTdG9yZShjdHgsIGN0eC50YWJsZS5jb3JlLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgudGFibGUuY29yZS5xdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQ6IGN0eC5saW1pdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBjdHgucmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF9hLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KS50aGVuKGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5rZXlzT25seSA9ICFjdHguaXNNYXRjaDtcbiAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpdGVtLCBjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBhLnB1c2goY3Vyc29yLnByaW1hcnlLZXkpO1xuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9KS50aGVuKGNiKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUudW5pcXVlS2V5cyA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgdGhpcy5fY3R4LnVuaXF1ZSA9IFwidW5pcXVlXCI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXlzKGNiKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZmlyc3RLZXkgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbWl0KDEpLmtleXMoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFbMF07IH0pLnRoZW4oY2IpO1xuICAgICAgICB9O1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5sYXN0S2V5ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmlyc3RLZXkoY2IpO1xuICAgICAgICB9O1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5kaXN0aW5jdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHgsIGlkeCA9IGN0eC5pbmRleCAmJiBjdHgudGFibGUuc2NoZW1hLmlkeEJ5TmFtZVtjdHguaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFpZHggfHwgIWlkeC5tdWx0aSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIHZhciBzZXQgPSB7fTtcbiAgICAgICAgICAgIGFkZEZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RyS2V5ID0gY3Vyc29yLnByaW1hcnlLZXkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBoYXNPd24oc2V0LCBzdHJLZXkpO1xuICAgICAgICAgICAgICAgIHNldFtzdHJLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWZvdW5kO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUubW9kaWZ5ID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlKGZ1bmN0aW9uICh0cmFucykge1xuICAgICAgICAgICAgICAgIHZhciBtb2RpZnllcjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNoYW5nZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZ5ZXIgPSBjaGFuZ2VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGhzID0ga2V5cyhjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bUtleXMgPSBrZXlQYXRocy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmeWVyID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbnl0aGluZ01vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUtleXM7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoID0ga2V5UGF0aHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGNoYW5nZXNba2V5UGF0aF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdWYWwgPSBnZXRCeUtleVBhdGgoaXRlbSwga2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFByb3BNb2RpZmljYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKGl0ZW0sIGtleVBhdGgsIHZhbC5leGVjdXRlKG9yaWdWYWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW55dGhpbmdNb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9yaWdWYWwgIT09IHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgoaXRlbSwga2V5UGF0aCwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW55dGhpbmdNb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFueXRoaW5nTW9kaWZpZWQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjb3JlVGFibGUgPSBjdHgudGFibGUuY29yZTtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBjb3JlVGFibGUuc2NoZW1hLnByaW1hcnlLZXksIG91dGJvdW5kID0gX2Eub3V0Ym91bmQsIGV4dHJhY3RLZXkgPSBfYS5leHRyYWN0S2V5O1xuICAgICAgICAgICAgICAgIHZhciBsaW1pdCA9IF90aGlzLmRiLl9vcHRpb25zLm1vZGlmeUNodW5rU2l6ZSB8fCAyMDA7XG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsRmFpbHVyZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgc3VjY2Vzc0NvdW50ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgZmFpbGVkS2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBhcHBseU11dGF0ZVJlc3VsdCA9IGZ1bmN0aW9uIChleHBlY3RlZENvdW50LCByZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZhaWx1cmVzID0gcmVzLmZhaWx1cmVzLCBudW1GYWlsdXJlcyA9IHJlcy5udW1GYWlsdXJlcztcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NvdW50ICs9IGV4cGVjdGVkQ291bnQgLSBudW1GYWlsdXJlcztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGtleXMoZmFpbHVyZXMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsRmFpbHVyZXMucHVzaChmYWlsdXJlc1twb3NdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNsb25lKCkucHJpbWFyeUtleXMoKS50aGVuKGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjcml0ZXJpYSA9IGlzUGxhaW5LZXlSYW5nZShjdHgpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGltaXQgPT09IEluZmluaXR5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGNoYW5nZXMgIT09ICdmdW5jdGlvbicgfHwgY2hhbmdlcyA9PT0gZGVsZXRlQ2FsbGJhY2spICYmIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBjdHguaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0Q2h1bmsgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSBNYXRoLm1pbihsaW1pdCwga2V5cy5sZW5ndGggLSBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmVUYWJsZS5nZXRNYW55KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5czoga2V5cy5zbGljZShvZmZzZXQsIG9mZnNldCArIGNvdW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogXCJpbW11dGFibGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkZFZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwdXRWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHV0S2V5cyA9IG91dGJvdW5kID8gW10gOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxldGVLZXlzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnVmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdHhfMSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkZWVwQ2xvbmUob3JpZ1ZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1LZXk6IGtleXNbb2Zmc2V0ICsgaV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGlmeWVyLmNhbGwoY3R4XzEsIGN0eF8xLnZhbHVlLCBjdHhfMSkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4XzEudmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUtleXMucHVzaChrZXlzW29mZnNldCArIGldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFvdXRib3VuZCAmJiBjbXAoZXh0cmFjdEtleShvcmlnVmFsdWUpLCBleHRyYWN0S2V5KGN0eF8xLnZhbHVlKSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVLZXlzLnB1c2goa2V5c1tvZmZzZXQgKyBpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVmFsdWVzLnB1c2goY3R4XzEudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHV0VmFsdWVzLnB1c2goY3R4XzEudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRib3VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHV0S2V5cy5wdXNoKGtleXNbb2Zmc2V0ICsgaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYWRkVmFsdWVzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZVRhYmxlLm11dGF0ZSh7IHRyYW5zOiB0cmFucywgdHlwZTogJ2FkZCcsIHZhbHVlczogYWRkVmFsdWVzIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwb3MgaW4gcmVzLmZhaWx1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlS2V5cy5zcGxpY2UocGFyc2VJbnQocG9zKSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseU11dGF0ZVJlc3VsdChhZGRWYWx1ZXMubGVuZ3RoLCByZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiAocHV0VmFsdWVzLmxlbmd0aCA+IDAgfHwgKGNyaXRlcmlhICYmIHR5cGVvZiBjaGFuZ2VzID09PSAnb2JqZWN0JykpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVUYWJsZS5tdXRhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnM6IHRyYW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3B1dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBwdXRLZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBwdXRWYWx1ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcml0ZXJpYTogY3JpdGVyaWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VTcGVjOiB0eXBlb2YgY2hhbmdlcyAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGNoYW5nZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FkZGl0aW9uYWxDaHVuazogb2Zmc2V0ID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIGFwcGx5TXV0YXRlUmVzdWx0KHB1dFZhbHVlcy5sZW5ndGgsIHJlcyk7IH0pOyB9KS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIChkZWxldGVLZXlzLmxlbmd0aCA+IDAgfHwgKGNyaXRlcmlhICYmIGNoYW5nZXMgPT09IGRlbGV0ZUNhbGxiYWNrKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZVRhYmxlLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGVsZXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IGRlbGV0ZUtleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcml0ZXJpYTogY3JpdGVyaWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FkZGl0aW9uYWxDaHVuazogb2Zmc2V0ID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIGFwcGx5TXV0YXRlUmVzdWx0KGRlbGV0ZUtleXMubGVuZ3RoLCByZXMpOyB9KTsgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmxlbmd0aCA+IG9mZnNldCArIGNvdW50ICYmIG5leHRDaHVuayhvZmZzZXQgKyBsaW1pdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHRDaHVuaygwKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbEZhaWx1cmVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1vZGlmeUVycm9yKFwiRXJyb3IgbW9kaWZ5aW5nIG9uZSBvciBtb3JlIG9iamVjdHNcIiwgdG90YWxGYWlsdXJlcywgc3VjY2Vzc0NvdW50LCBmYWlsZWRLZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eCwgcmFuZ2UgPSBjdHgucmFuZ2U7XG4gICAgICAgICAgICBpZiAoaXNQbGFpbktleVJhbmdlKGN0eCkgJiZcbiAgICAgICAgICAgICAgICAoY3R4LmlzUHJpbUtleSB8fCByYW5nZS50eXBlID09PSAzICkpXG4gICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93cml0ZShmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByaW1hcnlLZXkgPSBjdHgudGFibGUuY29yZS5zY2hlbWEucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvcmVSYW5nZSA9IHJhbmdlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnRhYmxlLmNvcmUuY291bnQoeyB0cmFuczogdHJhbnMsIHF1ZXJ5OiB7IGluZGV4OiBwcmltYXJ5S2V5LCByYW5nZTogY29yZVJhbmdlIH0gfSkudGhlbihmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgudGFibGUuY29yZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdkZWxldGVSYW5nZScsIHJhbmdlOiBjb3JlUmFuZ2UgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFpbHVyZXMgPSBfYS5mYWlsdXJlczsgX2EubGFzdFJlc3VsdDsgX2EucmVzdWx0czsgdmFyIG51bUZhaWx1cmVzID0gX2EubnVtRmFpbHVyZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bUZhaWx1cmVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTW9kaWZ5RXJyb3IoXCJDb3VsZCBub3QgZGVsZXRlIHNvbWUgdmFsdWVzXCIsIE9iamVjdC5rZXlzKGZhaWx1cmVzKS5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gZmFpbHVyZXNbcG9zXTsgfSksIGNvdW50IC0gbnVtRmFpbHVyZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3VudCAtIG51bUZhaWx1cmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kaWZ5KGRlbGV0ZUNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvbGxlY3Rpb247XG4gICAgfSgpKTtcbiAgICB2YXIgZGVsZXRlQ2FsbGJhY2sgPSBmdW5jdGlvbiAodmFsdWUsIGN0eCkgeyByZXR1cm4gY3R4LnZhbHVlID0gbnVsbDsgfTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbGxlY3Rpb25Db25zdHJ1Y3RvcihkYikge1xuICAgICAgICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3IoQ29sbGVjdGlvbi5wcm90b3R5cGUsIGZ1bmN0aW9uIENvbGxlY3Rpb24od2hlcmVDbGF1c2UsIGtleVJhbmdlR2VuZXJhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgICAgICB2YXIga2V5UmFuZ2UgPSBBbnlSYW5nZSwgZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGtleVJhbmdlR2VuZXJhdG9yKVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGtleVJhbmdlID0ga2V5UmFuZ2VHZW5lcmF0b3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHdoZXJlQ3R4ID0gd2hlcmVDbGF1c2UuX2N0eDtcbiAgICAgICAgICAgIHZhciB0YWJsZSA9IHdoZXJlQ3R4LnRhYmxlO1xuICAgICAgICAgICAgdmFyIHJlYWRpbmdIb29rID0gdGFibGUuaG9vay5yZWFkaW5nLmZpcmU7XG4gICAgICAgICAgICB0aGlzLl9jdHggPSB7XG4gICAgICAgICAgICAgICAgdGFibGU6IHRhYmxlLFxuICAgICAgICAgICAgICAgIGluZGV4OiB3aGVyZUN0eC5pbmRleCxcbiAgICAgICAgICAgICAgICBpc1ByaW1LZXk6ICghd2hlcmVDdHguaW5kZXggfHwgKHRhYmxlLnNjaGVtYS5wcmltS2V5LmtleVBhdGggJiYgd2hlcmVDdHguaW5kZXggPT09IHRhYmxlLnNjaGVtYS5wcmltS2V5Lm5hbWUpKSxcbiAgICAgICAgICAgICAgICByYW5nZToga2V5UmFuZ2UsXG4gICAgICAgICAgICAgICAga2V5c09ubHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRpcjogXCJuZXh0XCIsXG4gICAgICAgICAgICAgICAgdW5pcXVlOiBcIlwiLFxuICAgICAgICAgICAgICAgIGFsZ29yaXRobTogbnVsbCxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgcmVwbGF5RmlsdGVyOiBudWxsLFxuICAgICAgICAgICAgICAgIGp1c3RMaW1pdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc01hdGNoOiBudWxsLFxuICAgICAgICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgICAgICAgICBsaW1pdDogSW5maW5pdHksXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIG9yOiB3aGVyZUN0eC5vcixcbiAgICAgICAgICAgICAgICB2YWx1ZU1hcHBlcjogcmVhZGluZ0hvb2sgIT09IG1pcnJvciA/IHJlYWRpbmdIb29rIDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2ltcGxlQ29tcGFyZShhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA9PT0gYiA/IDAgOiAxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaW1wbGVDb21wYXJlUmV2ZXJzZShhLCBiKSB7XG4gICAgICAgIHJldHVybiBhID4gYiA/IC0xIDogYSA9PT0gYiA/IDAgOiAxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZhaWwoY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UsIGVyciwgVCkge1xuICAgICAgICB2YXIgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlIGluc3RhbmNlb2YgV2hlcmVDbGF1c2UgP1xuICAgICAgICAgICAgbmV3IGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlLkNvbGxlY3Rpb24oY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UpIDpcbiAgICAgICAgICAgIGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlO1xuICAgICAgICBjb2xsZWN0aW9uLl9jdHguZXJyb3IgPSBUID8gbmV3IFQoZXJyKSA6IG5ldyBUeXBlRXJyb3IoZXJyKTtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVtcHR5Q29sbGVjdGlvbih3aGVyZUNsYXVzZSkge1xuICAgICAgICByZXR1cm4gbmV3IHdoZXJlQ2xhdXNlLkNvbGxlY3Rpb24od2hlcmVDbGF1c2UsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJhbmdlRXF1YWwoXCJcIik7IH0pLmxpbWl0KDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cHBlckZhY3RvcnkoZGlyKSB7XG4gICAgICAgIHJldHVybiBkaXIgPT09IFwibmV4dFwiID9cbiAgICAgICAgICAgIGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRvVXBwZXJDYXNlKCk7IH0gOlxuICAgICAgICAgICAgZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudG9Mb3dlckNhc2UoKTsgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbG93ZXJGYWN0b3J5KGRpcikge1xuICAgICAgICByZXR1cm4gZGlyID09PSBcIm5leHRcIiA/XG4gICAgICAgICAgICBmdW5jdGlvbiAocykgeyByZXR1cm4gcy50b0xvd2VyQ2FzZSgpOyB9IDpcbiAgICAgICAgICAgIGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRvVXBwZXJDYXNlKCk7IH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5leHRDYXNpbmcoa2V5LCBsb3dlcktleSwgdXBwZXJOZWVkbGUsIGxvd2VyTmVlZGxlLCBjbXAsIGRpcikge1xuICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oa2V5Lmxlbmd0aCwgbG93ZXJOZWVkbGUubGVuZ3RoKTtcbiAgICAgICAgdmFyIGxscCA9IC0xO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbHdyS2V5Q2hhciA9IGxvd2VyS2V5W2ldO1xuICAgICAgICAgICAgaWYgKGx3cktleUNoYXIgIT09IGxvd2VyTmVlZGxlW2ldKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNtcChrZXlbaV0sIHVwcGVyTmVlZGxlW2ldKSA8IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXkuc3Vic3RyKDAsIGkpICsgdXBwZXJOZWVkbGVbaV0gKyB1cHBlck5lZWRsZS5zdWJzdHIoaSArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChjbXAoa2V5W2ldLCBsb3dlck5lZWRsZVtpXSkgPCAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5LnN1YnN0cigwLCBpKSArIGxvd2VyTmVlZGxlW2ldICsgdXBwZXJOZWVkbGUuc3Vic3RyKGkgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAobGxwID49IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXkuc3Vic3RyKDAsIGxscCkgKyBsb3dlcktleVtsbHBdICsgdXBwZXJOZWVkbGUuc3Vic3RyKGxscCArIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNtcChrZXlbaV0sIGx3cktleUNoYXIpIDwgMClcbiAgICAgICAgICAgICAgICBsbHAgPSBpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCBsb3dlck5lZWRsZS5sZW5ndGggJiYgZGlyID09PSBcIm5leHRcIilcbiAgICAgICAgICAgIHJldHVybiBrZXkgKyB1cHBlck5lZWRsZS5zdWJzdHIoa2V5Lmxlbmd0aCk7XG4gICAgICAgIGlmIChsZW5ndGggPCBrZXkubGVuZ3RoICYmIGRpciA9PT0gXCJwcmV2XCIpXG4gICAgICAgICAgICByZXR1cm4ga2V5LnN1YnN0cigwLCB1cHBlck5lZWRsZS5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gKGxscCA8IDAgPyBudWxsIDoga2V5LnN1YnN0cigwLCBsbHApICsgbG93ZXJOZWVkbGVbbGxwXSArIHVwcGVyTmVlZGxlLnN1YnN0cihsbHAgKyAxKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZElnbm9yZUNhc2VBbGdvcml0aG0od2hlcmVDbGF1c2UsIG1hdGNoLCBuZWVkbGVzLCBzdWZmaXgpIHtcbiAgICAgICAgdmFyIHVwcGVyLCBsb3dlciwgY29tcGFyZSwgdXBwZXJOZWVkbGVzLCBsb3dlck5lZWRsZXMsIGRpcmVjdGlvbiwgbmV4dEtleVN1ZmZpeCwgbmVlZGxlc0xlbiA9IG5lZWRsZXMubGVuZ3RoO1xuICAgICAgICBpZiAoIW5lZWRsZXMuZXZlcnkoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHR5cGVvZiBzID09PSAnc3RyaW5nJzsgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsKHdoZXJlQ2xhdXNlLCBTVFJJTkdfRVhQRUNURUQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGluaXREaXJlY3Rpb24oZGlyKSB7XG4gICAgICAgICAgICB1cHBlciA9IHVwcGVyRmFjdG9yeShkaXIpO1xuICAgICAgICAgICAgbG93ZXIgPSBsb3dlckZhY3RvcnkoZGlyKTtcbiAgICAgICAgICAgIGNvbXBhcmUgPSAoZGlyID09PSBcIm5leHRcIiA/IHNpbXBsZUNvbXBhcmUgOiBzaW1wbGVDb21wYXJlUmV2ZXJzZSk7XG4gICAgICAgICAgICB2YXIgbmVlZGxlQm91bmRzID0gbmVlZGxlcy5tYXAoZnVuY3Rpb24gKG5lZWRsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGxvd2VyOiBsb3dlcihuZWVkbGUpLCB1cHBlcjogdXBwZXIobmVlZGxlKSB9O1xuICAgICAgICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlKGEubG93ZXIsIGIubG93ZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1cHBlck5lZWRsZXMgPSBuZWVkbGVCb3VuZHMubWFwKGZ1bmN0aW9uIChuYikgeyByZXR1cm4gbmIudXBwZXI7IH0pO1xuICAgICAgICAgICAgbG93ZXJOZWVkbGVzID0gbmVlZGxlQm91bmRzLm1hcChmdW5jdGlvbiAobmIpIHsgcmV0dXJuIG5iLmxvd2VyOyB9KTtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IGRpcjtcbiAgICAgICAgICAgIG5leHRLZXlTdWZmaXggPSAoZGlyID09PSBcIm5leHRcIiA/IFwiXCIgOiBzdWZmaXgpO1xuICAgICAgICB9XG4gICAgICAgIGluaXREaXJlY3Rpb24oXCJuZXh0XCIpO1xuICAgICAgICB2YXIgYyA9IG5ldyB3aGVyZUNsYXVzZS5Db2xsZWN0aW9uKHdoZXJlQ2xhdXNlLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVSYW5nZSh1cHBlck5lZWRsZXNbMF0sIGxvd2VyTmVlZGxlc1tuZWVkbGVzTGVuIC0gMV0gKyBzdWZmaXgpOyB9KTtcbiAgICAgICAgYy5fb25kaXJlY3Rpb25jaGFuZ2UgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBpbml0RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBmaXJzdFBvc3NpYmxlTmVlZGxlID0gMDtcbiAgICAgICAgYy5fYWRkQWxnb3JpdGhtKGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBjdXJzb3Iua2V5O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHZhciBsb3dlcktleSA9IGxvd2VyKGtleSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gobG93ZXJLZXksIGxvd2VyTmVlZGxlcywgZmlyc3RQb3NzaWJsZU5lZWRsZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBsb3dlc3RQb3NzaWJsZUNhc2luZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGZpcnN0UG9zc2libGVOZWVkbGU7IGkgPCBuZWVkbGVzTGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhc2luZyA9IG5leHRDYXNpbmcoa2V5LCBsb3dlcktleSwgdXBwZXJOZWVkbGVzW2ldLCBsb3dlck5lZWRsZXNbaV0sIGNvbXBhcmUsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXNpbmcgPT09IG51bGwgJiYgbG93ZXN0UG9zc2libGVDYXNpbmcgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFBvc3NpYmxlTmVlZGxlID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvd2VzdFBvc3NpYmxlQ2FzaW5nID09PSBudWxsIHx8IGNvbXBhcmUobG93ZXN0UG9zc2libGVDYXNpbmcsIGNhc2luZykgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RQb3NzaWJsZUNhc2luZyA9IGNhc2luZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobG93ZXN0UG9zc2libGVDYXNpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShmdW5jdGlvbiAoKSB7IGN1cnNvci5jb250aW51ZShsb3dlc3RQb3NzaWJsZUNhc2luZyArIG5leHRLZXlTdWZmaXgpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSYW5nZShsb3dlciwgdXBwZXIsIGxvd2VyT3BlbiwgdXBwZXJPcGVuKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAyICxcbiAgICAgICAgICAgIGxvd2VyOiBsb3dlcixcbiAgICAgICAgICAgIHVwcGVyOiB1cHBlcixcbiAgICAgICAgICAgIGxvd2VyT3BlbjogbG93ZXJPcGVuLFxuICAgICAgICAgICAgdXBwZXJPcGVuOiB1cHBlck9wZW5cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmFuZ2VFcXVhbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogMSAsXG4gICAgICAgICAgICBsb3dlcjogdmFsdWUsXG4gICAgICAgICAgICB1cHBlcjogdmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgV2hlcmVDbGF1c2UgPSAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gV2hlcmVDbGF1c2UoKSB7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdoZXJlQ2xhdXNlLnByb3RvdHlwZSwgXCJDb2xsZWN0aW9uXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdHgudGFibGUuZGIuQ29sbGVjdGlvbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmJldHdlZW4gPSBmdW5jdGlvbiAobG93ZXIsIHVwcGVyLCBpbmNsdWRlTG93ZXIsIGluY2x1ZGVVcHBlcikge1xuICAgICAgICAgICAgaW5jbHVkZUxvd2VyID0gaW5jbHVkZUxvd2VyICE9PSBmYWxzZTtcbiAgICAgICAgICAgIGluY2x1ZGVVcHBlciA9IGluY2x1ZGVVcHBlciA9PT0gdHJ1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLl9jbXAobG93ZXIsIHVwcGVyKSA+IDApIHx8XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLl9jbXAobG93ZXIsIHVwcGVyKSA9PT0gMCAmJiAoaW5jbHVkZUxvd2VyIHx8IGluY2x1ZGVVcHBlcikgJiYgIShpbmNsdWRlTG93ZXIgJiYgaW5jbHVkZVVwcGVyKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlUmFuZ2UobG93ZXIsIHVwcGVyLCAhaW5jbHVkZUxvd2VyLCAhaW5jbHVkZVVwcGVyKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmFuZ2VFcXVhbCh2YWx1ZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuYWJvdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZVJhbmdlKHZhbHVlLCB1bmRlZmluZWQsIHRydWUpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmFib3ZlT3JFcXVhbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlUmFuZ2UodmFsdWUsIHVuZGVmaW5lZCwgZmFsc2UpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmJlbG93ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVSYW5nZSh1bmRlZmluZWQsIHZhbHVlLCBmYWxzZSwgdHJ1ZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuYmVsb3dPckVxdWFsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVSYW5nZSh1bmRlZmluZWQsIHZhbHVlKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5zdGFydHNXaXRoID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIFNUUklOR19FWFBFQ1RFRCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iZXR3ZWVuKHN0ciwgc3RyICsgbWF4U3RyaW5nLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLnN0YXJ0c1dpdGhJZ25vcmVDYXNlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgaWYgKHN0ciA9PT0gXCJcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydHNXaXRoKHN0cik7XG4gICAgICAgICAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCBmdW5jdGlvbiAoeCwgYSkgeyByZXR1cm4geC5pbmRleE9mKGFbMF0pID09PSAwOyB9LCBbc3RyXSwgbWF4U3RyaW5nKTtcbiAgICAgICAgfTtcbiAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmVxdWFsc0lnbm9yZUNhc2UgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCBmdW5jdGlvbiAoeCwgYSkgeyByZXR1cm4geCA9PT0gYVswXTsgfSwgW3N0cl0sIFwiXCIpO1xuICAgICAgICB9O1xuICAgICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuYW55T2ZJZ25vcmVDYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCBmdW5jdGlvbiAoeCwgYSkgeyByZXR1cm4gYS5pbmRleE9mKHgpICE9PSAtMTsgfSwgc2V0LCBcIlwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLnN0YXJ0c1dpdGhBbnlPZklnbm9yZUNhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHNldC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsIGZ1bmN0aW9uICh4LCBhKSB7IHJldHVybiBhLnNvbWUoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIHguaW5kZXhPZihuKSA9PT0gMDsgfSk7IH0sIHNldCwgbWF4U3RyaW5nKTtcbiAgICAgICAgfTtcbiAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmFueU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgY29tcGFyZSA9IHRoaXMuX2NtcDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc2V0LnNvcnQoY29tcGFyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG4gICAgICAgICAgICB2YXIgYyA9IG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlUmFuZ2Uoc2V0WzBdLCBzZXRbc2V0Lmxlbmd0aCAtIDFdKTsgfSk7XG4gICAgICAgICAgICBjLl9vbmRpcmVjdGlvbmNoYW5nZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjb21wYXJlID0gKGRpcmVjdGlvbiA9PT0gXCJuZXh0XCIgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYXNjZW5kaW5nIDpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Rlc2NlbmRpbmcpO1xuICAgICAgICAgICAgICAgIHNldC5zb3J0KGNvbXBhcmUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIGMuX2FkZEFsZ29yaXRobShmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGN1cnNvci5rZXk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoa2V5LCBzZXRbaV0pID4gMCkge1xuICAgICAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBzZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGtleSwgc2V0W2ldKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoZnVuY3Rpb24gKCkgeyBjdXJzb3IuY29udGludWUoc2V0W2ldKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9O1xuICAgICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUubm90RXF1YWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluQW55UmFuZ2UoW1ttaW5LZXksIHZhbHVlXSwgW3ZhbHVlLCB0aGlzLmRiLl9tYXhLZXldXSwgeyBpbmNsdWRlTG93ZXJzOiBmYWxzZSwgaW5jbHVkZVVwcGVyczogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5ub25lT2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHNldC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHNldC5zb3J0KHRoaXMuX2FzY2VuZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByYW5nZXMgPSBzZXQucmVkdWNlKGZ1bmN0aW9uIChyZXMsIHZhbCkgeyByZXR1cm4gcmVzID9cbiAgICAgICAgICAgICAgICByZXMuY29uY2F0KFtbcmVzW3Jlcy5sZW5ndGggLSAxXVsxXSwgdmFsXV0pIDpcbiAgICAgICAgICAgICAgICBbW21pbktleSwgdmFsXV07IH0sIG51bGwpO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goW3NldFtzZXQubGVuZ3RoIC0gMV0sIHRoaXMuZGIuX21heEtleV0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5BbnlSYW5nZShyYW5nZXMsIHsgaW5jbHVkZUxvd2VyczogZmFsc2UsIGluY2x1ZGVVcHBlcnM6IGZhbHNlIH0pO1xuICAgICAgICB9O1xuICAgICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuaW5BbnlSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY21wID0gdGhpcy5fY21wLCBhc2NlbmRpbmcgPSB0aGlzLl9hc2NlbmRpbmcsIGRlc2NlbmRpbmcgPSB0aGlzLl9kZXNjZW5kaW5nLCBtaW4gPSB0aGlzLl9taW4sIG1heCA9IHRoaXMuX21heDtcbiAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG4gICAgICAgICAgICBpZiAoIXJhbmdlcy5ldmVyeShmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VbMF0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICByYW5nZVsxXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIGFzY2VuZGluZyhyYW5nZVswXSwgcmFuZ2VbMV0pIDw9IDA7XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIFwiRmlyc3QgYXJndW1lbnQgdG8gaW5BbnlSYW5nZSgpIG11c3QgYmUgYW4gQXJyYXkgb2YgdHdvLXZhbHVlIEFycmF5cyBbbG93ZXIsdXBwZXJdIHdoZXJlIHVwcGVyIG11c3Qgbm90IGJlIGxvd2VyIHRoYW4gbG93ZXJcIiwgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGluY2x1ZGVMb3dlcnMgPSAhb3B0aW9ucyB8fCBvcHRpb25zLmluY2x1ZGVMb3dlcnMgIT09IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGluY2x1ZGVVcHBlcnMgPSBvcHRpb25zICYmIG9wdGlvbnMuaW5jbHVkZVVwcGVycyA9PT0gdHJ1ZTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFJhbmdlKHJhbmdlcywgbmV3UmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDAsIGwgPSByYW5nZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNtcChuZXdSYW5nZVswXSwgcmFuZ2VbMV0pIDwgMCAmJiBjbXAobmV3UmFuZ2VbMV0sIHJhbmdlWzBdKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlWzBdID0gbWluKHJhbmdlWzBdLCBuZXdSYW5nZVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZVsxXSA9IG1heChyYW5nZVsxXSwgbmV3UmFuZ2VbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGwpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKG5ld1JhbmdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNvcnREaXJlY3Rpb24gPSBhc2NlbmRpbmc7XG4gICAgICAgICAgICBmdW5jdGlvbiByYW5nZVNvcnRlcihhLCBiKSB7IHJldHVybiBzb3J0RGlyZWN0aW9uKGFbMF0sIGJbMF0pOyB9XG4gICAgICAgICAgICB2YXIgc2V0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzZXQgPSByYW5nZXMucmVkdWNlKGFkZFJhbmdlLCBbXSk7XG4gICAgICAgICAgICAgICAgc2V0LnNvcnQocmFuZ2VTb3J0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJhbmdlUG9zID0gMDtcbiAgICAgICAgICAgIHZhciBrZXlJc0JleW9uZEN1cnJlbnRFbnRyeSA9IGluY2x1ZGVVcHBlcnMgP1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGFzY2VuZGluZyhrZXksIHNldFtyYW5nZVBvc11bMV0pID4gMDsgfSA6XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gYXNjZW5kaW5nKGtleSwgc2V0W3JhbmdlUG9zXVsxXSkgPj0gMDsgfTtcbiAgICAgICAgICAgIHZhciBrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeSA9IGluY2x1ZGVMb3dlcnMgP1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGRlc2NlbmRpbmcoa2V5LCBzZXRbcmFuZ2VQb3NdWzBdKSA+IDA7IH0gOlxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGRlc2NlbmRpbmcoa2V5LCBzZXRbcmFuZ2VQb3NdWzBdKSA+PSAwOyB9O1xuICAgICAgICAgICAgZnVuY3Rpb24ga2V5V2l0aGluQ3VycmVudFJhbmdlKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAha2V5SXNCZXlvbmRDdXJyZW50RW50cnkoa2V5KSAmJiAha2V5SXNCZWZvcmVDdXJyZW50RW50cnkoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGVja0tleSA9IGtleUlzQmV5b25kQ3VycmVudEVudHJ5O1xuICAgICAgICAgICAgdmFyIGMgPSBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZVJhbmdlKHNldFswXVswXSwgc2V0W3NldC5sZW5ndGggLSAxXVsxXSwgIWluY2x1ZGVMb3dlcnMsICFpbmNsdWRlVXBwZXJzKTsgfSk7XG4gICAgICAgICAgICBjLl9vbmRpcmVjdGlvbmNoYW5nZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAgICAgICBjaGVja0tleSA9IGtleUlzQmV5b25kQ3VycmVudEVudHJ5O1xuICAgICAgICAgICAgICAgICAgICBzb3J0RGlyZWN0aW9uID0gYXNjZW5kaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tLZXkgPSBrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgc29ydERpcmVjdGlvbiA9IGRlc2NlbmRpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldC5zb3J0KHJhbmdlU29ydGVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjLl9hZGRBbGdvcml0aG0oZnVuY3Rpb24gKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBjdXJzb3Iua2V5O1xuICAgICAgICAgICAgICAgIHdoaWxlIChjaGVja0tleShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICsrcmFuZ2VQb3M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZVBvcyA9PT0gc2V0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2V5V2l0aGluQ3VycmVudFJhbmdlKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLl9jbXAoa2V5LCBzZXRbcmFuZ2VQb3NdWzFdKSA9PT0gMCB8fCBfdGhpcy5fY21wKGtleSwgc2V0W3JhbmdlUG9zXVswXSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29ydERpcmVjdGlvbiA9PT0gYXNjZW5kaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShzZXRbcmFuZ2VQb3NdWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoc2V0W3JhbmdlUG9zXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfTtcbiAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLnN0YXJ0c1dpdGhBbnlPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAoIXNldC5ldmVyeShmdW5jdGlvbiAocykgeyByZXR1cm4gdHlwZW9mIHMgPT09ICdzdHJpbmcnOyB9KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIFwic3RhcnRzV2l0aEFueU9mKCkgb25seSB3b3JrcyB3aXRoIHN0cmluZ3NcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5BbnlSYW5nZShzZXQubWFwKGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIFtzdHIsIHN0ciArIG1heFN0cmluZ107IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFdoZXJlQ2xhdXNlO1xuICAgIH0oKSk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVXaGVyZUNsYXVzZUNvbnN0cnVjdG9yKGRiKSB7XG4gICAgICAgIHJldHVybiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcihXaGVyZUNsYXVzZS5wcm90b3R5cGUsIGZ1bmN0aW9uIFdoZXJlQ2xhdXNlKHRhYmxlLCBpbmRleCwgb3JDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgICAgICB0aGlzLl9jdHggPSB7XG4gICAgICAgICAgICAgICAgdGFibGU6IHRhYmxlLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCA9PT0gXCI6aWRcIiA/IG51bGwgOiBpbmRleCxcbiAgICAgICAgICAgICAgICBvcjogb3JDb2xsZWN0aW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fY21wID0gdGhpcy5fYXNjZW5kaW5nID0gY21wO1xuICAgICAgICAgICAgdGhpcy5fZGVzY2VuZGluZyA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBjbXAoYiwgYSk7IH07XG4gICAgICAgICAgICB0aGlzLl9tYXggPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gY21wKGEsIGIpID4gMCA/IGEgOiBiOyB9O1xuICAgICAgICAgICAgdGhpcy5fbWluID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGNtcChhLCBiKSA8IDAgPyBhIDogYjsgfTtcbiAgICAgICAgICAgIHRoaXMuX0lEQktleVJhbmdlID0gZGIuX2RlcHMuSURCS2V5UmFuZ2U7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX0lEQktleVJhbmdlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCkge1xuICAgICAgICByZXR1cm4gd3JhcChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgICAgIHJlamVjdChldmVudC50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbilcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHZhciBERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSA9ICdzdG9yYWdlbXV0YXRlZCc7XG4gICAgdmFyIFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSA9ICd4LXN0b3JhZ2VtdXRhdGVkLTEnO1xuICAgIHZhciBnbG9iYWxFdmVudHMgPSBFdmVudHMobnVsbCwgREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUpO1xuXG4gICAgdmFyIFRyYW5zYWN0aW9uID0gIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRyYW5zYWN0aW9uKCkge1xuICAgICAgICB9XG4gICAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5fbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFzc2VydCghUFNELmdsb2JhbCk7XG4gICAgICAgICAgICArK3RoaXMuX3JlY3Vsb2NrO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlY3Vsb2NrID09PSAxICYmICFQU0QuZ2xvYmFsKVxuICAgICAgICAgICAgICAgIFBTRC5sb2NrT3duZXJGb3IgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5fdW5sb2NrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXNzZXJ0KCFQU0QuZ2xvYmFsKTtcbiAgICAgICAgICAgIGlmICgtLXRoaXMuX3JlY3Vsb2NrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFQU0QuZ2xvYmFsKVxuICAgICAgICAgICAgICAgICAgICBQU0QubG9ja093bmVyRm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5fYmxvY2tlZEZ1bmNzLmxlbmd0aCA+IDAgJiYgIXRoaXMuX2xvY2tlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbkFuZFBTRCA9IHRoaXMuX2Jsb2NrZWRGdW5jcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlUFNEKGZuQW5kUFNEWzFdLCBmbkFuZFBTRFswXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuX2xvY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWN1bG9jayAmJiBQU0QubG9ja093bmVyRm9yICE9PSB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGlkYnRyYW5zKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm1vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB2YXIgaWRiZGIgPSB0aGlzLmRiLmlkYmRiO1xuICAgICAgICAgICAgdmFyIGRiT3BlbkVycm9yID0gdGhpcy5kYi5fc3RhdGUuZGJPcGVuRXJyb3I7XG4gICAgICAgICAgICBhc3NlcnQoIXRoaXMuaWRidHJhbnMpO1xuICAgICAgICAgICAgaWYgKCFpZGJ0cmFucyAmJiAhaWRiZGIpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRiT3BlbkVycm9yICYmIGRiT3BlbkVycm9yLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkRhdGFiYXNlQ2xvc2VkRXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKGRiT3BlbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk1pc3NpbmdBUElFcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSShkYk9wZW5FcnJvci5tZXNzYWdlLCBkYk9wZW5FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5PcGVuRmFpbGVkKGRiT3BlbkVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlRyYW5zYWN0aW9uSW5hY3RpdmUoKTtcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLl9jb21wbGV0aW9uLl9zdGF0ZSA9PT0gbnVsbCk7XG4gICAgICAgICAgICBpZGJ0cmFucyA9IHRoaXMuaWRidHJhbnMgPSBpZGJ0cmFucyB8fFxuICAgICAgICAgICAgICAgICh0aGlzLmRiLmNvcmVcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmRiLmNvcmUudHJhbnNhY3Rpb24odGhpcy5zdG9yZU5hbWVzLCB0aGlzLm1vZGUsIHsgZHVyYWJpbGl0eTogdGhpcy5jaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHkgfSlcbiAgICAgICAgICAgICAgICAgICAgOiBpZGJkYi50cmFuc2FjdGlvbih0aGlzLnN0b3JlTmFtZXMsIHRoaXMubW9kZSwgeyBkdXJhYmlsaXR5OiB0aGlzLmNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSB9KSk7XG4gICAgICAgICAgICBpZGJ0cmFucy5vbmVycm9yID0gd3JhcChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldik7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlamVjdChpZGJ0cmFucy5lcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlkYnRyYW5zLm9uYWJvcnQgPSB3cmFwKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmUgJiYgX3RoaXMuX3JlamVjdChuZXcgZXhjZXB0aW9ucy5BYm9ydChpZGJ0cmFucy5lcnJvcikpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF90aGlzLm9uKFwiYWJvcnRcIikuZmlyZShldik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlkYnRyYW5zLm9uY29tcGxldGUgPSB3cmFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIGlmICgnbXV0YXRlZFBhcnRzJyBpbiBpZGJ0cmFucykge1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxFdmVudHMuc3RvcmFnZW11dGF0ZWQuZmlyZShpZGJ0cmFuc1tcIm11dGF0ZWRQYXJ0c1wiXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9wcm9taXNlID0gZnVuY3Rpb24gKG1vZGUsIGZuLCBiV3JpdGVMb2NrKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdyZWFkd3JpdGUnICYmIHRoaXMubW9kZSAhPT0gJ3JlYWR3cml0ZScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5SZWFkT25seShcIlRyYW5zYWN0aW9uIGlzIHJlYWRvbmx5XCIpKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5UcmFuc2FjdGlvbkluYWN0aXZlKCkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xvY2tlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYmxvY2tlZEZ1bmNzLnB1c2goW2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcHJvbWlzZShtb2RlLCBmbiwgYldyaXRlTG9jaykudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgUFNEXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiV3JpdGVMb2NrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnYgPSBmbihyZXNvbHZlLCByZWplY3QsIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydiAmJiBydi50aGVuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ2LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHAuZmluYWxseShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fdW5sb2NrKCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICBwLl9saWIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwID0gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBydiA9IGZuKHJlc29sdmUsIHJlamVjdCwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocnYgJiYgcnYudGhlbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ2LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwLl9saWIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuX3Jvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5fcm9vdCgpIDogdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLndhaXRGb3IgPSBmdW5jdGlvbiAocHJvbWlzZUxpa2UpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gdGhpcy5fcm9vdCgpO1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBEZXhpZVByb21pc2UucmVzb2x2ZShwcm9taXNlTGlrZSk7XG4gICAgICAgICAgICBpZiAocm9vdC5fd2FpdGluZ0Zvcikge1xuICAgICAgICAgICAgICAgIHJvb3QuX3dhaXRpbmdGb3IgPSByb290Ll93YWl0aW5nRm9yLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvbWlzZTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb290Ll93YWl0aW5nRm9yID0gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICByb290Ll93YWl0aW5nUXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSByb290LmlkYnRyYW5zLm9iamVjdFN0b3JlKHJvb3Quc3RvcmVOYW1lc1swXSk7XG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uIHNwaW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICsrcm9vdC5fc3BpbkNvdW50O1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocm9vdC5fd2FpdGluZ1F1ZXVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIChyb290Ll93YWl0aW5nUXVldWUuc2hpZnQoKSkoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvb3QuX3dhaXRpbmdGb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZS5nZXQoLUluZmluaXR5KS5vbnN1Y2Nlc3MgPSBzcGluO1xuICAgICAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VycmVudFdhaXRQcm9taXNlID0gcm9vdC5fd2FpdGluZ0ZvcjtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcm9vdC5fd2FpdGluZ1F1ZXVlLnB1c2god3JhcChyZXNvbHZlLmJpbmQobnVsbCwgcmVzKSkpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiByb290Ll93YWl0aW5nUXVldWUucHVzaCh3cmFwKHJlamVjdC5iaW5kKG51bGwsIGVycikpKTsgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb290Ll93YWl0aW5nRm9yID09PSBjdXJyZW50V2FpdFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QuX3dhaXRpbmdGb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZGJ0cmFucylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pZGJ0cmFucy5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdChuZXcgZXhjZXB0aW9ucy5BYm9ydCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLnRhYmxlID0gZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuICAgICAgICAgICAgdmFyIG1lbW9pemVkVGFibGVzID0gKHRoaXMuX21lbW9pemVkVGFibGVzIHx8ICh0aGlzLl9tZW1vaXplZFRhYmxlcyA9IHt9KSk7XG4gICAgICAgICAgICBpZiAoaGFzT3duKG1lbW9pemVkVGFibGVzLCB0YWJsZU5hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBtZW1vaXplZFRhYmxlc1t0YWJsZU5hbWVdO1xuICAgICAgICAgICAgdmFyIHRhYmxlU2NoZW1hID0gdGhpcy5zY2hlbWFbdGFibGVOYW1lXTtcbiAgICAgICAgICAgIGlmICghdGFibGVTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5Ob3RGb3VuZChcIlRhYmxlIFwiICsgdGFibGVOYW1lICsgXCIgbm90IHBhcnQgb2YgdHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb25Cb3VuZFRhYmxlID0gbmV3IHRoaXMuZGIuVGFibGUodGFibGVOYW1lLCB0YWJsZVNjaGVtYSwgdGhpcyk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbkJvdW5kVGFibGUuY29yZSA9IHRoaXMuZGIuY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgbWVtb2l6ZWRUYWJsZXNbdGFibGVOYW1lXSA9IHRyYW5zYWN0aW9uQm91bmRUYWJsZTtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbkJvdW5kVGFibGU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvbjtcbiAgICB9KCkpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVHJhbnNhY3Rpb25Db25zdHJ1Y3RvcihkYikge1xuICAgICAgICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3IoVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBmdW5jdGlvbiBUcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYnNjaGVtYSwgY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5LCBwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICAgICAgdGhpcy5zdG9yZU5hbWVzID0gc3RvcmVOYW1lcztcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hID0gZGJzY2hlbWE7XG4gICAgICAgICAgICB0aGlzLmNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSA9IGNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eTtcbiAgICAgICAgICAgIHRoaXMuaWRidHJhbnMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5vbiA9IEV2ZW50cyh0aGlzLCBcImNvbXBsZXRlXCIsIFwiZXJyb3JcIiwgXCJhYm9ydFwiKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9yZWN1bG9jayA9IDA7XG4gICAgICAgICAgICB0aGlzLl9ibG9ja2VkRnVuY3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3dhaXRpbmdGb3IgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fd2FpdGluZ1F1ZXVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3NwaW5Db3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0aW9uID0gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRpb24udGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX3RoaXMub24uY29tcGxldGUuZmlyZSgpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2FzQWN0aXZlID0gX3RoaXMuYWN0aXZlO1xuICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF90aGlzLm9uLmVycm9yLmZpcmUoZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMucGFyZW50ID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGFyZW50Ll9yZWplY3QoZSkgOlxuICAgICAgICAgICAgICAgICAgICB3YXNBY3RpdmUgJiYgX3RoaXMuaWRidHJhbnMgJiYgX3RoaXMuaWRidHJhbnMuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUluZGV4U3BlYyhuYW1lLCBrZXlQYXRoLCB1bmlxdWUsIG11bHRpLCBhdXRvLCBjb21wb3VuZCwgaXNQcmltS2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAga2V5UGF0aDoga2V5UGF0aCxcbiAgICAgICAgICAgIHVuaXF1ZTogdW5pcXVlLFxuICAgICAgICAgICAgbXVsdGk6IG11bHRpLFxuICAgICAgICAgICAgYXV0bzogYXV0byxcbiAgICAgICAgICAgIGNvbXBvdW5kOiBjb21wb3VuZCxcbiAgICAgICAgICAgIHNyYzogKHVuaXF1ZSAmJiAhaXNQcmltS2V5ID8gJyYnIDogJycpICsgKG11bHRpID8gJyonIDogJycpICsgKGF1dG8gPyBcIisrXCIgOiBcIlwiKSArIG5hbWVGcm9tS2V5UGF0aChrZXlQYXRoKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBuYW1lRnJvbUtleVBhdGgoa2V5UGF0aCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID9cbiAgICAgICAgICAgIGtleVBhdGggOlxuICAgICAgICAgICAga2V5UGF0aCA/ICgnWycgKyBbXS5qb2luLmNhbGwoa2V5UGF0aCwgJysnKSArICddJykgOiBcIlwiO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRhYmxlU2NoZW1hKG5hbWUsIHByaW1LZXksIGluZGV4ZXMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBwcmltS2V5OiBwcmltS2V5LFxuICAgICAgICAgICAgaW5kZXhlczogaW5kZXhlcyxcbiAgICAgICAgICAgIG1hcHBlZENsYXNzOiBudWxsLFxuICAgICAgICAgICAgaWR4QnlOYW1lOiBhcnJheVRvT2JqZWN0KGluZGV4ZXMsIGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gW2luZGV4Lm5hbWUsIGluZGV4XTsgfSlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzYWZhcmlNdWx0aVN0b3JlRml4KHN0b3JlTmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIHN0b3JlTmFtZXMubGVuZ3RoID09PSAxID8gc3RvcmVOYW1lc1swXSA6IHN0b3JlTmFtZXM7XG4gICAgfVxuICAgIHZhciBnZXRNYXhLZXkgPSBmdW5jdGlvbiAoSWRiS2V5UmFuZ2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIElkYktleVJhbmdlLm9ubHkoW1tdXSk7XG4gICAgICAgICAgICBnZXRNYXhLZXkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbW11dOyB9O1xuICAgICAgICAgICAgcmV0dXJuIFtbXV07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGdldE1heEtleSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1heFN0cmluZzsgfTtcbiAgICAgICAgICAgIHJldHVybiBtYXhTdHJpbmc7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpIHtcbiAgICAgICAgaWYgKGtleVBhdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRTaW5nbGVQYXRoS2V5RXh0cmFjdG9yKGtleVBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpOyB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFNpbmdsZVBhdGhLZXlFeHRyYWN0b3Ioa2V5UGF0aCkge1xuICAgICAgICB2YXIgc3BsaXQgPSBrZXlQYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgIGlmIChzcGxpdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmpba2V5UGF0aF07IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gZ2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCk7IH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcnJheWlmeShhcnJheUxpa2UpIHtcbiAgICAgICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoYXJyYXlMaWtlKTtcbiAgICB9XG4gICAgdmFyIF9pZF9jb3VudGVyID0gMDtcbiAgICBmdW5jdGlvbiBnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCkge1xuICAgICAgICByZXR1cm4ga2V5UGF0aCA9PSBudWxsID9cbiAgICAgICAgICAgIFwiOmlkXCIgOlxuICAgICAgICAgICAgdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID9cbiAgICAgICAgICAgICAgICBrZXlQYXRoIDpcbiAgICAgICAgICAgICAgICBcIltcIi5jb25jYXQoa2V5UGF0aC5qb2luKCcrJyksIFwiXVwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlREJDb3JlKGRiLCBJZGJLZXlSYW5nZSwgdG1wVHJhbnMpIHtcbiAgICAgICAgZnVuY3Rpb24gZXh0cmFjdFNjaGVtYShkYiwgdHJhbnMpIHtcbiAgICAgICAgICAgIHZhciB0YWJsZXMgPSBhcnJheWlmeShkYi5vYmplY3RTdG9yZU5hbWVzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGRiLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlczogdGFibGVzLm1hcChmdW5jdGlvbiAodGFibGUpIHsgcmV0dXJuIHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlKTsgfSkubWFwKGZ1bmN0aW9uIChzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBzdG9yZS5rZXlQYXRoLCBhdXRvSW5jcmVtZW50ID0gc3RvcmUuYXV0b0luY3JlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21wb3VuZCA9IGlzQXJyYXkoa2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0Ym91bmQgPSBrZXlQYXRoID09IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhCeUtleVBhdGggPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogc3RvcmUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5S2V5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJpbWFyeUtleTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0Ym91bmQ6IG91dGJvdW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZDogY29tcG91bmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGg6IGtleVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9JbmNyZW1lbnQ6IGF1dG9JbmNyZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdEtleTogZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleGVzOiBhcnJheWlmeShzdG9yZS5pbmRleE5hbWVzKS5tYXAoZnVuY3Rpb24gKGluZGV4TmFtZSkgeyByZXR1cm4gc3RvcmUuaW5kZXgoaW5kZXhOYW1lKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBpbmRleC5uYW1lLCB1bmlxdWUgPSBpbmRleC51bmlxdWUsIG11bHRpRW50cnkgPSBpbmRleC5tdWx0aUVudHJ5LCBrZXlQYXRoID0gaW5kZXgua2V5UGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBvdW5kID0gaXNBcnJheShrZXlQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZDogY29tcG91bmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXRoOiBrZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlOiB1bmlxdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aUVudHJ5OiBtdWx0aUVudHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdEtleTogZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4QnlLZXlQYXRoW2dldEtleVBhdGhBbGlhcyhrZXlQYXRoKV0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SW5kZXhCeUtleVBhdGg6IGZ1bmN0aW9uIChrZXlQYXRoKSB7IHJldHVybiBpbmRleEJ5S2V5UGF0aFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhCeUtleVBhdGhbXCI6aWRcIl0gPSByZXN1bHQucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleEJ5S2V5UGF0aFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldID0gcmVzdWx0LnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGFzR2V0QWxsOiB0YWJsZXMubGVuZ3RoID4gMCAmJiAoJ2dldEFsbCcgaW4gdHJhbnMub2JqZWN0U3RvcmUodGFibGVzWzBdKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgISh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhLyhDaHJvbWVcXC98RWRnZVxcLykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIFtdLmNvbmNhdChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9TYWZhcmlcXC8oXFxkKikvKSlbMV0gPCA2MDQpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VJREJLZXlSYW5nZShyYW5nZSkge1xuICAgICAgICAgICAgaWYgKHJhbmdlLnR5cGUgPT09IDMgKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHJhbmdlLnR5cGUgPT09IDQgKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG5ldmVyIHR5cGUgdG8gSURCS2V5UmFuZ2VcIik7XG4gICAgICAgICAgICB2YXIgbG93ZXIgPSByYW5nZS5sb3dlciwgdXBwZXIgPSByYW5nZS51cHBlciwgbG93ZXJPcGVuID0gcmFuZ2UubG93ZXJPcGVuLCB1cHBlck9wZW4gPSByYW5nZS51cHBlck9wZW47XG4gICAgICAgICAgICB2YXIgaWRiUmFuZ2UgPSBsb3dlciA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICB1cHBlciA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgbnVsbCA6XG4gICAgICAgICAgICAgICAgICAgIElkYktleVJhbmdlLnVwcGVyQm91bmQodXBwZXIsICEhdXBwZXJPcGVuKSA6XG4gICAgICAgICAgICAgICAgdXBwZXIgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgIElkYktleVJhbmdlLmxvd2VyQm91bmQobG93ZXIsICEhbG93ZXJPcGVuKSA6XG4gICAgICAgICAgICAgICAgICAgIElkYktleVJhbmdlLmJvdW5kKGxvd2VyLCB1cHBlciwgISFsb3dlck9wZW4sICEhdXBwZXJPcGVuKTtcbiAgICAgICAgICAgIHJldHVybiBpZGJSYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVEYkNvcmVUYWJsZSh0YWJsZVNjaGVtYSkge1xuICAgICAgICAgICAgdmFyIHRhYmxlTmFtZSA9IHRhYmxlU2NoZW1hLm5hbWU7XG4gICAgICAgICAgICBmdW5jdGlvbiBtdXRhdGUoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnMgPSBfYS50cmFucywgdHlwZSA9IF9hLnR5cGUsIGtleXMgPSBfYS5rZXlzLCB2YWx1ZXMgPSBfYS52YWx1ZXMsIHJhbmdlID0gX2EucmFuZ2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRib3VuZCA9IHN0b3JlLmtleVBhdGggPT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzQWRkT3JQdXQgPSB0eXBlID09PSBcInB1dFwiIHx8IHR5cGUgPT09IFwiYWRkXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNBZGRPclB1dCAmJiB0eXBlICE9PSAnZGVsZXRlJyAmJiB0eXBlICE9PSAnZGVsZXRlUmFuZ2UnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvcGVyYXRpb24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IChrZXlzIHx8IHZhbHVlcyB8fCB7IGxlbmd0aDogMSB9KS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlzICYmIHZhbHVlcyAmJiBrZXlzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2l2ZW4ga2V5cyBhcnJheSBtdXN0IGhhdmUgc2FtZSBsZW5ndGggYXMgZ2l2ZW4gdmFsdWVzIGFycmF5LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBudW1GYWlsdXJlczogMCwgZmFpbHVyZXM6IHt9LCByZXN1bHRzOiBbXSwgbGFzdFJlc3VsdDogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmFpbHVyZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bUZhaWx1cmVzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytudW1GYWlsdXJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdkZWxldGVSYW5nZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS50eXBlID09PSA0IClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7IG51bUZhaWx1cmVzOiBudW1GYWlsdXJlcywgZmFpbHVyZXM6IGZhaWx1cmVzLCByZXN1bHRzOiBbXSwgbGFzdFJlc3VsdDogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLnR5cGUgPT09IDMgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSBzdG9yZS5jbGVhcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXFzLnB1c2gocmVxID0gc3RvcmUuZGVsZXRlKG1ha2VJREJLZXlSYW5nZShyYW5nZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IGlzQWRkT3JQdXQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGJvdW5kID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3ZhbHVlcywga2V5c10gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdmFsdWVzLCBudWxsXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2tleXMsIG51bGxdLCBhcmdzMSA9IF9hWzBdLCBhcmdzMiA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWRkT3JQdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSAoYXJnczIgJiYgYXJnczJbaV0gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZVt0eXBlXShhcmdzMVtpXSwgYXJnczJbaV0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlW3R5cGVdKGFyZ3MxW2ldKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGVycm9ySGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSBzdG9yZVt0eXBlXShhcmdzMVtpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGVycm9ySGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0UmVzdWx0ID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMuZm9yRWFjaChmdW5jdGlvbiAocmVxLCBpKSB7IHJldHVybiByZXEuZXJyb3IgIT0gbnVsbCAmJiAoZmFpbHVyZXNbaV0gPSByZXEuZXJyb3IpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bUZhaWx1cmVzOiBudW1GYWlsdXJlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlczogZmFpbHVyZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0czogdHlwZSA9PT0gXCJkZWxldGVcIiA/IGtleXMgOiByZXFzLm1hcChmdW5jdGlvbiAocmVxKSB7IHJldHVybiByZXEucmVzdWx0OyB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UmVzdWx0OiBsYXN0UmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlcihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGRvbmU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBvcGVuQ3Vyc29yKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zID0gX2EudHJhbnMsIHZhbHVlcyA9IF9hLnZhbHVlcywgcXVlcnkgPSBfYS5xdWVyeSwgcmV2ZXJzZSA9IF9hLnJldmVyc2UsIHVuaXF1ZSA9IF9hLnVuaXF1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gd3JhcChyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcXVlcnkuaW5kZXgsIHJhbmdlID0gcXVlcnkucmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBpbmRleC5pc1ByaW1hcnlLZXkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUuaW5kZXgoaW5kZXgubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSByZXZlcnNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwcmV2dW5pcXVlXCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicHJldlwiIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJuZXh0dW5pcXVlXCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibmV4dFwiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gdmFsdWVzIHx8ICEoJ29wZW5LZXlDdXJzb3InIGluIHNvdXJjZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLm9wZW5DdXJzb3IobWFrZUlEQktleVJhbmdlKHJhbmdlKSwgZGlyZWN0aW9uKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2Uub3BlbktleUN1cnNvcihtYWtlSURCS2V5UmFuZ2UocmFuZ2UpLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3IgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5fX19pZCA9ICsrX2lkX2NvdW50ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jdXJzb3JDb250aW51ZSA9IGN1cnNvci5jb250aW51ZS5iaW5kKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleSA9IGN1cnNvci5jb250aW51ZVByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5ID0gX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleS5iaW5kKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2N1cnNvckFkdmFuY2UgPSBjdXJzb3IuYWR2YW5jZS5iaW5kKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9UaHJvd0N1cnNvcklzTm90U3RhcnRlZCA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ3Vyc29yIG5vdCBzdGFydGVkXCIpOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvVGhyb3dDdXJzb3JJc1N0b3BwZWQgPSBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcihcIkN1cnNvciBub3Qgc3RvcHBlZFwiKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci50cmFucyA9IHRyYW5zO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0b3AgPSBjdXJzb3IuY29udGludWUgPSBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5ID0gY3Vyc29yLmFkdmFuY2UgPSBkb1Rocm93Q3Vyc29ySXNOb3RTdGFydGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmZhaWwgPSB3cmFwKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnb3RPbmUgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdvdE9uZS0tID8gX3RoaXMuY29udGludWUoKSA6IF90aGlzLnN0b3AoKTsgfSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpczsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0YXJ0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZXJhdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZUl0ZXJhdGlvbiwgcmVqZWN0SXRlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVJdGVyYXRpb24gPSB3cmFwKHJlc29sdmVJdGVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3RJdGVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZmFpbCA9IHJlamVjdEl0ZXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0b3AgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdG9wID0gY3Vyc29yLmNvbnRpbnVlID0gY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleSA9IGN1cnNvci5hZHZhbmNlID0gZG9UaHJvd0N1cnNvcklzU3RvcHBlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVJdGVyYXRpb24odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBndWFyZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmZhaWwoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdGFydCA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ3Vyc29yIGJlaGluZCBsYXN0IGVudHJ5XCIpOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBndWFyZGVkQ2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGd1YXJkZWRDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSA9IF9jdXJzb3JDb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5ID0gX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuYWR2YW5jZSA9IF9jdXJzb3JBZHZhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGd1YXJkZWRDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRpb25Qcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHF1ZXJ5KGhhc0dldEFsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnMgPSByZXF1ZXN0LnRyYW5zLCB2YWx1ZXMgPSByZXF1ZXN0LnZhbHVlcywgbGltaXQgPSByZXF1ZXN0LmxpbWl0LCBxdWVyeSA9IHJlcXVlc3QucXVlcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9uSW5maW5pdExpbWl0ID0gbGltaXQgPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogbGltaXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBxdWVyeS5pbmRleCwgcmFuZ2UgPSBxdWVyeS5yYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gaW5kZXguaXNQcmltYXJ5S2V5ID8gc3RvcmUgOiBzdG9yZS5pbmRleChpbmRleC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZGJLZXlSYW5nZSA9IG1ha2VJREJLZXlSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGltaXQgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyByZXN1bHQ6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0dldEFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSB2YWx1ZXMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UuZ2V0QWxsKGlkYktleVJhbmdlLCBub25JbmZpbml0TGltaXQpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLmdldEFsbEtleXMoaWRiS2V5UmFuZ2UsIG5vbkluZmluaXRMaW1pdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gcmVzb2x2ZSh7IHJlc3VsdDogZXZlbnQudGFyZ2V0LnJlc3VsdCB9KTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50XzEgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXFfMSA9IHZhbHVlcyB8fCAhKCdvcGVuS2V5Q3Vyc29yJyBpbiBzb3VyY2UpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLm9wZW5DdXJzb3IoaWRiS2V5UmFuZ2UpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLm9wZW5LZXlDdXJzb3IoaWRiS2V5UmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRfMSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcV8xLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gcmVxXzEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnNvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgcmVzdWx0OiByZXN1bHRfMSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0XzEucHVzaCh2YWx1ZXMgPyBjdXJzb3IudmFsdWUgOiBjdXJzb3IucHJpbWFyeUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2NvdW50XzEgPT09IGxpbWl0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyByZXN1bHQ6IHJlc3VsdF8xIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcV8xLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogdGFibGVOYW1lLFxuICAgICAgICAgICAgICAgIHNjaGVtYTogdGFibGVTY2hlbWEsXG4gICAgICAgICAgICAgICAgbXV0YXRlOiBtdXRhdGUsXG4gICAgICAgICAgICAgICAgZ2V0TWFueTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFucyA9IF9hLnRyYW5zLCBrZXlzID0gX2Eua2V5cztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3NIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJlc3VsdFtyZXEuX3Bvc10gPSByZXEucmVzdWx0KSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrY2FsbGJhY2tDb3VudCA9PT0ga2V5Q291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JIYW5kbGVyID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IHN0b3JlLmdldChrZXlzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLl9wb3MgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gc3VjY2Vzc0hhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXJyb3JIYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2tleUNvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlDb3VudCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zID0gX2EudHJhbnMsIGtleSA9IF9hLmtleTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBzdG9yZS5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIHJlc29sdmUoZXZlbnQudGFyZ2V0LnJlc3VsdCk7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeShoYXNHZXRBbGwpLFxuICAgICAgICAgICAgICAgIG9wZW5DdXJzb3I6IG9wZW5DdXJzb3IsXG4gICAgICAgICAgICAgICAgY291bnQ6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcXVlcnkgPSBfYS5xdWVyeSwgdHJhbnMgPSBfYS50cmFucztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcXVlcnkuaW5kZXgsIHJhbmdlID0gcXVlcnkucmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGluZGV4LmlzUHJpbWFyeUtleSA/IHN0b3JlIDogc3RvcmUuaW5kZXgoaW5kZXgubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWRiS2V5UmFuZ2UgPSBtYWtlSURCS2V5UmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IGlkYktleVJhbmdlID8gc291cmNlLmNvdW50KGlkYktleVJhbmdlKSA6IHNvdXJjZS5jb3VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZnVuY3Rpb24gKGV2KSB7IHJldHVybiByZXNvbHZlKGV2LnRhcmdldC5yZXN1bHQpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gZXh0cmFjdFNjaGVtYShkYiwgdG1wVHJhbnMpLCBzY2hlbWEgPSBfYS5zY2hlbWEsIGhhc0dldEFsbCA9IF9hLmhhc0dldEFsbDtcbiAgICAgICAgdmFyIHRhYmxlcyA9IHNjaGVtYS50YWJsZXMubWFwKGZ1bmN0aW9uICh0YWJsZVNjaGVtYSkgeyByZXR1cm4gY3JlYXRlRGJDb3JlVGFibGUodGFibGVTY2hlbWEpOyB9KTtcbiAgICAgICAgdmFyIHRhYmxlTWFwID0ge307XG4gICAgICAgIHRhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZSkgeyByZXR1cm4gdGFibGVNYXBbdGFibGUubmFtZV0gPSB0YWJsZTsgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFjazogXCJkYmNvcmVcIixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBkYi50cmFuc2FjdGlvbi5iaW5kKGRiKSxcbiAgICAgICAgICAgIHRhYmxlOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YWJsZU1hcFtuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGFibGUgJ1wiLmNvbmNhdChuYW1lLCBcIicgbm90IGZvdW5kXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVNYXBbbmFtZV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTUlOX0tFWTogLUluZmluaXR5LFxuICAgICAgICAgICAgTUFYX0tFWTogZ2V0TWF4S2V5KElkYktleVJhbmdlKSxcbiAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTWlkZGxld2FyZVN0YWNrKHN0YWNrSW1wbCwgbWlkZGxld2FyZXMpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmVzLnJlZHVjZShmdW5jdGlvbiAoZG93biwgX2EpIHtcbiAgICAgICAgICAgIHZhciBjcmVhdGUgPSBfYS5jcmVhdGU7XG4gICAgICAgICAgICByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBkb3duKSwgY3JlYXRlKGRvd24pKSk7XG4gICAgICAgIH0sIHN0YWNrSW1wbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmVTdGFja3MobWlkZGxld2FyZXMsIGlkYmRiLCBfYSwgdG1wVHJhbnMpIHtcbiAgICAgICAgdmFyIElEQktleVJhbmdlID0gX2EuSURCS2V5UmFuZ2U7IF9hLmluZGV4ZWREQjtcbiAgICAgICAgdmFyIGRiY29yZSA9IGNyZWF0ZU1pZGRsZXdhcmVTdGFjayhjcmVhdGVEQkNvcmUoaWRiZGIsIElEQktleVJhbmdlLCB0bXBUcmFucyksIG1pZGRsZXdhcmVzLmRiY29yZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYmNvcmU6IGRiY29yZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MoZGIsIHRtcFRyYW5zKSB7XG4gICAgICAgIHZhciBpZGJkYiA9IHRtcFRyYW5zLmRiO1xuICAgICAgICB2YXIgc3RhY2tzID0gY3JlYXRlTWlkZGxld2FyZVN0YWNrcyhkYi5fbWlkZGxld2FyZXMsIGlkYmRiLCBkYi5fZGVwcywgdG1wVHJhbnMpO1xuICAgICAgICBkYi5jb3JlID0gc3RhY2tzLmRiY29yZTtcbiAgICAgICAgZGIudGFibGVzLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlKSB7XG4gICAgICAgICAgICB2YXIgdGFibGVOYW1lID0gdGFibGUubmFtZTtcbiAgICAgICAgICAgIGlmIChkYi5jb3JlLnNjaGVtYS50YWJsZXMuc29tZShmdW5jdGlvbiAodGJsKSB7IHJldHVybiB0YmwubmFtZSA9PT0gdGFibGVOYW1lOyB9KSkge1xuICAgICAgICAgICAgICAgIHRhYmxlLmNvcmUgPSBkYi5jb3JlLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRiW3RhYmxlTmFtZV0gaW5zdGFuY2VvZiBkYi5UYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBkYlt0YWJsZU5hbWVdLmNvcmUgPSB0YWJsZS5jb3JlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0QXBpT25QbGFjZShkYiwgb2JqcywgdGFibGVOYW1lcywgZGJzY2hlbWEpIHtcbiAgICAgICAgdGFibGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWEgPSBkYnNjaGVtYVt0YWJsZU5hbWVdO1xuICAgICAgICAgICAgb2Jqcy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcERlc2MgPSBnZXRQcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCB0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghcHJvcERlc2MgfHwgKFwidmFsdWVcIiBpbiBwcm9wRGVzYyAmJiBwcm9wRGVzYy52YWx1ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqID09PSBkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGUgfHwgb2JqIGluc3RhbmNlb2YgZGIuVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFByb3Aob2JqLCB0YWJsZU5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudGFibGUodGFibGVOYW1lKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCB0YWJsZU5hbWUsIHsgdmFsdWU6IHZhbHVlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3RhYmxlTmFtZV0gPSBuZXcgZGIuVGFibGUodGFibGVOYW1lLCBzY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVUYWJsZXNBcGkoZGIsIG9ianMpIHtcbiAgICAgICAgb2Jqcy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqW2tleV0gaW5zdGFuY2VvZiBkYi5UYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbG93ZXJWZXJzaW9uRmlyc3QoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5fY2ZnLnZlcnNpb24gLSBiLl9jZmcudmVyc2lvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcnVuVXBncmFkZXJzKGRiLCBvbGRWZXJzaW9uLCBpZGJVcGdyYWRlVHJhbnMsIHJlamVjdCkge1xuICAgICAgICB2YXIgZ2xvYmFsU2NoZW1hID0gZGIuX2RiU2NoZW1hO1xuICAgICAgICBpZiAoaWRiVXBncmFkZVRyYW5zLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJyRtZXRhJykgJiYgIWdsb2JhbFNjaGVtYS4kbWV0YSkge1xuICAgICAgICAgICAgZ2xvYmFsU2NoZW1hLiRtZXRhID0gY3JlYXRlVGFibGVTY2hlbWEoXCIkbWV0YVwiLCBwYXJzZUluZGV4U3ludGF4KFwiXCIpWzBdLCBbXSk7XG4gICAgICAgICAgICBkYi5fc3RvcmVOYW1lcy5wdXNoKCckbWV0YScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFucyA9IGRiLl9jcmVhdGVUcmFuc2FjdGlvbigncmVhZHdyaXRlJywgZGIuX3N0b3JlTmFtZXMsIGdsb2JhbFNjaGVtYSk7XG4gICAgICAgIHRyYW5zLmNyZWF0ZShpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgICB0cmFucy5fY29tcGxldGlvbi5jYXRjaChyZWplY3QpO1xuICAgICAgICB2YXIgcmVqZWN0VHJhbnNhY3Rpb24gPSB0cmFucy5fcmVqZWN0LmJpbmQodHJhbnMpO1xuICAgICAgICB2YXIgdHJhbnNsZXNzID0gUFNELnRyYW5zbGVzcyB8fCBQU0Q7XG4gICAgICAgIG5ld1Njb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFBTRC50cmFucyA9IHRyYW5zO1xuICAgICAgICAgICAgUFNELnRyYW5zbGVzcyA9IHRyYW5zbGVzcztcbiAgICAgICAgICAgIGlmIChvbGRWZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAga2V5cyhnbG9iYWxTY2hlbWEpLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVUYWJsZShpZGJVcGdyYWRlVHJhbnMsIHRhYmxlTmFtZSwgZ2xvYmFsU2NoZW1hW3RhYmxlTmFtZV0ucHJpbUtleSwgZ2xvYmFsU2NoZW1hW3RhYmxlTmFtZV0uaW5kZXhlcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgICAgICAgICAgIERleGllUHJvbWlzZS5mb2xsb3coZnVuY3Rpb24gKCkgeyByZXR1cm4gZGIub24ucG9wdWxhdGUuZmlyZSh0cmFucyk7IH0pLmNhdGNoKHJlamVjdFRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyhkYiwgaWRiVXBncmFkZVRyYW5zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RXhpc3RpbmdWZXJzaW9uKGRiLCB0cmFucywgb2xkVmVyc2lvbilcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG9sZFZlcnNpb24pIHsgcmV0dXJuIHVwZGF0ZVRhYmxlc0FuZEluZGV4ZXMoZGIsIG9sZFZlcnNpb24sIHRyYW5zLCBpZGJVcGdyYWRlVHJhbnMpOyB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0VHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGF0Y2hDdXJyZW50VmVyc2lvbihkYiwgaWRiVXBncmFkZVRyYW5zKSB7XG4gICAgICAgIGNyZWF0ZU1pc3NpbmdUYWJsZXMoZGIuX2RiU2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgICBpZiAoaWRiVXBncmFkZVRyYW5zLmRiLnZlcnNpb24gJSAxMCA9PT0gMCAmJiAhaWRiVXBncmFkZVRyYW5zLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJyRtZXRhJykpIHtcbiAgICAgICAgICAgIGlkYlVwZ3JhZGVUcmFucy5kYi5jcmVhdGVPYmplY3RTdG9yZSgnJG1ldGEnKS5hZGQoTWF0aC5jZWlsKChpZGJVcGdyYWRlVHJhbnMuZGIudmVyc2lvbiAvIDEwKSAtIDEpLCAndmVyc2lvbicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnbG9iYWxTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgZGIuaWRiZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICAgIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBkYi5fZGJTY2hlbWEsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICAgIHZhciBkaWZmID0gZ2V0U2NoZW1hRGlmZihnbG9iYWxTY2hlbWEsIGRiLl9kYlNjaGVtYSk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHRhYmxlQ2hhbmdlKSB7XG4gICAgICAgICAgICBpZiAodGFibGVDaGFuZ2UuY2hhbmdlLmxlbmd0aCB8fCB0YWJsZUNoYW5nZS5yZWNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuYWJsZSB0byBwYXRjaCBpbmRleGVzIG9mIHRhYmxlIFwiLmNvbmNhdCh0YWJsZUNoYW5nZS5uYW1lLCBcIiBiZWNhdXNlIGl0IGhhcyBjaGFuZ2VzIG9uIHRoZSB0eXBlIG9mIGluZGV4IG9yIHByaW1hcnkga2V5LlwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZvaWQgMCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0b3JlID0gaWRiVXBncmFkZVRyYW5zLm9iamVjdFN0b3JlKHRhYmxlQ2hhbmdlLm5hbWUpO1xuICAgICAgICAgICAgdGFibGVDaGFuZ2UuYWRkLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcIkRleGllIHVwZ3JhZGUgcGF0Y2g6IENyZWF0aW5nIG1pc3NpbmcgaW5kZXggXCIuY29uY2F0KHRhYmxlQ2hhbmdlLm5hbWUsIFwiLlwiKS5jb25jYXQoaWR4LnNyYykpO1xuICAgICAgICAgICAgICAgIGFkZEluZGV4KHN0b3JlLCBpZHgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBkaWZmLmNoYW5nZTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciB0YWJsZUNoYW5nZSA9IF9hW19pXTtcbiAgICAgICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMSh0YWJsZUNoYW5nZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlXzEgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlXzEudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RXhpc3RpbmdWZXJzaW9uKGRiLCB0cmFucywgb2xkVmVyc2lvbikge1xuICAgICAgICBpZiAodHJhbnMuc3RvcmVOYW1lcy5pbmNsdWRlcygnJG1ldGEnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zLnRhYmxlKCckbWV0YScpLmdldCgndmVyc2lvbicpLnRoZW4oZnVuY3Rpb24gKG1ldGFWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFWZXJzaW9uICE9IG51bGwgPyBtZXRhVmVyc2lvbiA6IG9sZFZlcnNpb247XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShvbGRWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVUYWJsZXNBbmRJbmRleGVzKGRiLCBvbGRWZXJzaW9uLCB0cmFucywgaWRiVXBncmFkZVRyYW5zKSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB2YXIgdmVyc2lvbnMgPSBkYi5fdmVyc2lvbnM7XG4gICAgICAgIHZhciBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgZGIuaWRiZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICAgIHZhciB2ZXJzVG9SdW4gPSB2ZXJzaW9ucy5maWx0ZXIoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuX2NmZy52ZXJzaW9uID49IG9sZFZlcnNpb247IH0pO1xuICAgICAgICBpZiAodmVyc1RvUnVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmVyc1RvUnVuLmZvckVhY2goZnVuY3Rpb24gKHZlcnNpb24pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRTY2hlbWEgPSBnbG9iYWxTY2hlbWE7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1NjaGVtYSA9IHZlcnNpb24uX2NmZy5kYnNjaGVtYTtcbiAgICAgICAgICAgICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhkYiwgb2xkU2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgICAgICAgICAgIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBuZXdTY2hlbWEsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICAgICAgICAgICAgZ2xvYmFsU2NoZW1hID0gZGIuX2RiU2NoZW1hID0gbmV3U2NoZW1hO1xuICAgICAgICAgICAgICAgIHZhciBkaWZmID0gZ2V0U2NoZW1hRGlmZihvbGRTY2hlbWEsIG5ld1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgZGlmZi5hZGQuZm9yRWFjaChmdW5jdGlvbiAodHVwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlVGFibGUoaWRiVXBncmFkZVRyYW5zLCB0dXBsZVswXSwgdHVwbGVbMV0ucHJpbUtleSwgdHVwbGVbMV0uaW5kZXhlcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGlmZi5jaGFuZ2UuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UucmVjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlVwZ3JhZGUoXCJOb3QgeWV0IHN1cHBvcnQgZm9yIGNoYW5naW5nIHByaW1hcnkga2V5XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlXzEgPSBpZGJVcGdyYWRlVHJhbnMub2JqZWN0U3RvcmUoY2hhbmdlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmFkZC5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHsgcmV0dXJuIGFkZEluZGV4KHN0b3JlXzEsIGlkeCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmNoYW5nZS5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZV8xLmRlbGV0ZUluZGV4KGlkeC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRJbmRleChzdG9yZV8xLCBpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuZGVsLmZvckVhY2goZnVuY3Rpb24gKGlkeE5hbWUpIHsgcmV0dXJuIHN0b3JlXzEuZGVsZXRlSW5kZXgoaWR4TmFtZSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRVcGdyYWRlID0gdmVyc2lvbi5fY2ZnLmNvbnRlbnRVcGdyYWRlO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50VXBncmFkZSAmJiB2ZXJzaW9uLl9jZmcudmVyc2lvbiA+IG9sZFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICB0cmFucy5fbWVtb2l6ZWRUYWJsZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZ3JhZGVTY2hlbWFfMSA9IHNoYWxsb3dDbG9uZShuZXdTY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICBkaWZmLmRlbC5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBncmFkZVNjaGVtYV8xW3RhYmxlXSA9IG9sZFNjaGVtYVt0YWJsZV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVUYWJsZXNBcGkoZGIsIFtkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0QXBpT25QbGFjZShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0sIGtleXModXBncmFkZVNjaGVtYV8xKSwgdXBncmFkZVNjaGVtYV8xKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnMuc2NoZW1hID0gdXBncmFkZVNjaGVtYV8xO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFVwZ3JhZGVJc0FzeW5jXzEgPSBpc0FzeW5jRnVuY3Rpb24oY29udGVudFVwZ3JhZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFVwZ3JhZGVJc0FzeW5jXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVyblZhbHVlXzE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlRm9sbG93ZWQgPSBEZXhpZVByb21pc2UuZm9sbG93KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlXzEgPSBjb250ZW50VXBncmFkZSh0cmFucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWVfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VXBncmFkZUlzQXN5bmNfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVjcmVtZW50b3IgPSBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cy5iaW5kKG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZV8xLnRoZW4oZGVjcmVtZW50b3IsIGRlY3JlbWVudG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHJldHVyblZhbHVlXzEgJiYgdHlwZW9mIHJldHVyblZhbHVlXzEudGhlbiA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgICAgICAgICBEZXhpZVByb21pc2UucmVzb2x2ZShyZXR1cm5WYWx1ZV8xKSA6IHByb21pc2VGb2xsb3dlZC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJldHVyblZhbHVlXzE7IH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZnVuY3Rpb24gKGlkYnRyYW5zKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1NjaGVtYSA9IHZlcnNpb24uX2NmZy5kYnNjaGVtYTtcbiAgICAgICAgICAgICAgICBkZWxldGVSZW1vdmVkVGFibGVzKG5ld1NjaGVtYSwgaWRidHJhbnMpO1xuICAgICAgICAgICAgICAgIHJlbW92ZVRhYmxlc0FwaShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0pO1xuICAgICAgICAgICAgICAgIHNldEFwaU9uUGxhY2UoZGIsIFtkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdLCBkYi5fc3RvcmVOYW1lcywgZGIuX2RiU2NoZW1hKTtcbiAgICAgICAgICAgICAgICB0cmFucy5zY2hlbWEgPSBkYi5fZGJTY2hlbWE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZnVuY3Rpb24gKGlkYnRyYW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRiLmlkYmRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJyRtZXRhJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguY2VpbChkYi5pZGJkYi52ZXJzaW9uIC8gMTApID09PSB2ZXJzaW9uLl9jZmcudmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGIuaWRiZGIuZGVsZXRlT2JqZWN0U3RvcmUoJyRtZXRhJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZGIuX2RiU2NoZW1hLiRtZXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGIuX3N0b3JlTmFtZXMgPSBkYi5fc3RvcmVOYW1lcy5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5hbWUgIT09ICckbWV0YSc7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRidHJhbnMub2JqZWN0U3RvcmUoJyRtZXRhJykucHV0KHZlcnNpb24uX2NmZy52ZXJzaW9uLCAndmVyc2lvbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBydW5RdWV1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBxdWV1ZS5sZW5ndGggPyBEZXhpZVByb21pc2UucmVzb2x2ZShxdWV1ZS5zaGlmdCgpKHRyYW5zLmlkYnRyYW5zKSkudGhlbihydW5RdWV1ZSkgOlxuICAgICAgICAgICAgICAgIERleGllUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1blF1ZXVlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjcmVhdGVNaXNzaW5nVGFibGVzKGdsb2JhbFNjaGVtYSwgaWRiVXBncmFkZVRyYW5zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFNjaGVtYURpZmYob2xkU2NoZW1hLCBuZXdTY2hlbWEpIHtcbiAgICAgICAgdmFyIGRpZmYgPSB7XG4gICAgICAgICAgICBkZWw6IFtdLFxuICAgICAgICAgICAgYWRkOiBbXSxcbiAgICAgICAgICAgIGNoYW5nZTogW11cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRhYmxlO1xuICAgICAgICBmb3IgKHRhYmxlIGluIG9sZFNjaGVtYSkge1xuICAgICAgICAgICAgaWYgKCFuZXdTY2hlbWFbdGFibGVdKVxuICAgICAgICAgICAgICAgIGRpZmYuZGVsLnB1c2godGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodGFibGUgaW4gbmV3U2NoZW1hKSB7XG4gICAgICAgICAgICB2YXIgb2xkRGVmID0gb2xkU2NoZW1hW3RhYmxlXSwgbmV3RGVmID0gbmV3U2NoZW1hW3RhYmxlXTtcbiAgICAgICAgICAgIGlmICghb2xkRGVmKSB7XG4gICAgICAgICAgICAgICAgZGlmZi5hZGQucHVzaChbdGFibGUsIG5ld0RlZl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdGFibGUsXG4gICAgICAgICAgICAgICAgICAgIGRlZjogbmV3RGVmLFxuICAgICAgICAgICAgICAgICAgICByZWNyZWF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGRlbDogW10sXG4gICAgICAgICAgICAgICAgICAgIGFkZDogW10sXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZTogW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICgoXG4gICAgICAgICAgICAgICAgJycgKyAob2xkRGVmLnByaW1LZXkua2V5UGF0aCB8fCAnJykpICE9PSAoJycgKyAobmV3RGVmLnByaW1LZXkua2V5UGF0aCB8fCAnJykpIHx8XG4gICAgICAgICAgICAgICAgICAgIChvbGREZWYucHJpbUtleS5hdXRvICE9PSBuZXdEZWYucHJpbUtleS5hdXRvKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2UucmVjcmVhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkaWZmLmNoYW5nZS5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2xkSW5kZXhlcyA9IG9sZERlZi5pZHhCeU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdJbmRleGVzID0gbmV3RGVmLmlkeEJ5TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkeE5hbWUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaWR4TmFtZSBpbiBvbGRJbmRleGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld0luZGV4ZXNbaWR4TmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmRlbC5wdXNoKGlkeE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaWR4TmFtZSBpbiBuZXdJbmRleGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkSWR4ID0gb2xkSW5kZXhlc1tpZHhOYW1lXSwgbmV3SWR4ID0gbmV3SW5kZXhlc1tpZHhOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb2xkSWR4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5hZGQucHVzaChuZXdJZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkSWR4LnNyYyAhPT0gbmV3SWR4LnNyYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuY2hhbmdlLnB1c2gobmV3SWR4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLmRlbC5sZW5ndGggPiAwIHx8IGNoYW5nZS5hZGQubGVuZ3RoID4gMCB8fCBjaGFuZ2UuY2hhbmdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYuY2hhbmdlLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlVGFibGUoaWRidHJhbnMsIHRhYmxlTmFtZSwgcHJpbUtleSwgaW5kZXhlcykge1xuICAgICAgICB2YXIgc3RvcmUgPSBpZGJ0cmFucy5kYi5jcmVhdGVPYmplY3RTdG9yZSh0YWJsZU5hbWUsIHByaW1LZXkua2V5UGF0aCA/XG4gICAgICAgICAgICB7IGtleVBhdGg6IHByaW1LZXkua2V5UGF0aCwgYXV0b0luY3JlbWVudDogcHJpbUtleS5hdXRvIH0gOlxuICAgICAgICAgICAgeyBhdXRvSW5jcmVtZW50OiBwcmltS2V5LmF1dG8gfSk7XG4gICAgICAgIGluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7IHJldHVybiBhZGRJbmRleChzdG9yZSwgaWR4KTsgfSk7XG4gICAgICAgIHJldHVybiBzdG9yZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTWlzc2luZ1RhYmxlcyhuZXdTY2hlbWEsIGlkYnRyYW5zKSB7XG4gICAgICAgIGtleXMobmV3U2NoZW1hKS5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcbiAgICAgICAgICAgIGlmICghaWRidHJhbnMuZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyh0YWJsZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdEZXhpZTogQ3JlYXRpbmcgbWlzc2luZyB0YWJsZScsIHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgY3JlYXRlVGFibGUoaWRidHJhbnMsIHRhYmxlTmFtZSwgbmV3U2NoZW1hW3RhYmxlTmFtZV0ucHJpbUtleSwgbmV3U2NoZW1hW3RhYmxlTmFtZV0uaW5kZXhlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWxldGVSZW1vdmVkVGFibGVzKG5ld1NjaGVtYSwgaWRidHJhbnMpIHtcbiAgICAgICAgW10uc2xpY2UuY2FsbChpZGJ0cmFucy5kYi5vYmplY3RTdG9yZU5hbWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZU5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXdTY2hlbWFbc3RvcmVOYW1lXSA9PSBudWxsICYmIGlkYnRyYW5zLmRiLmRlbGV0ZU9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRJbmRleChzdG9yZSwgaWR4KSB7XG4gICAgICAgIHN0b3JlLmNyZWF0ZUluZGV4KGlkeC5uYW1lLCBpZHgua2V5UGF0aCwgeyB1bmlxdWU6IGlkeC51bmlxdWUsIG11bHRpRW50cnk6IGlkeC5tdWx0aSB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnVpbGRHbG9iYWxTY2hlbWEoZGIsIGlkYmRiLCB0bXBUcmFucykge1xuICAgICAgICB2YXIgZ2xvYmFsU2NoZW1hID0ge307XG4gICAgICAgIHZhciBkYlN0b3JlTmFtZXMgPSBzbGljZShpZGJkYi5vYmplY3RTdG9yZU5hbWVzLCAwKTtcbiAgICAgICAgZGJTdG9yZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHN0b3JlTmFtZSkge1xuICAgICAgICAgICAgdmFyIHN0b3JlID0gdG1wVHJhbnMub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgICAgICAgIHZhciBrZXlQYXRoID0gc3RvcmUua2V5UGF0aDtcbiAgICAgICAgICAgIHZhciBwcmltS2V5ID0gY3JlYXRlSW5kZXhTcGVjKG5hbWVGcm9tS2V5UGF0aChrZXlQYXRoKSwga2V5UGF0aCB8fCBcIlwiLCB0cnVlLCBmYWxzZSwgISFzdG9yZS5hdXRvSW5jcmVtZW50LCBrZXlQYXRoICYmIHR5cGVvZiBrZXlQYXRoICE9PSBcInN0cmluZ1wiLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBpbmRleGVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0b3JlLmluZGV4TmFtZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgaWRiaW5kZXggPSBzdG9yZS5pbmRleChzdG9yZS5pbmRleE5hbWVzW2pdKTtcbiAgICAgICAgICAgICAgICBrZXlQYXRoID0gaWRiaW5kZXgua2V5UGF0aDtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBjcmVhdGVJbmRleFNwZWMoaWRiaW5kZXgubmFtZSwga2V5UGF0aCwgISFpZGJpbmRleC51bmlxdWUsICEhaWRiaW5kZXgubXVsdGlFbnRyeSwgZmFsc2UsIGtleVBhdGggJiYgdHlwZW9mIGtleVBhdGggIT09IFwic3RyaW5nXCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2xvYmFsU2NoZW1hW3N0b3JlTmFtZV0gPSBjcmVhdGVUYWJsZVNjaGVtYShzdG9yZU5hbWUsIHByaW1LZXksIGluZGV4ZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFNjaGVtYTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZEdsb2JhbFNjaGVtYShkYiwgaWRiZGIsIHRtcFRyYW5zKSB7XG4gICAgICAgIGRiLnZlcm5vID0gaWRiZGIudmVyc2lvbiAvIDEwO1xuICAgICAgICB2YXIgZ2xvYmFsU2NoZW1hID0gZGIuX2RiU2NoZW1hID0gYnVpbGRHbG9iYWxTY2hlbWEoZGIsIGlkYmRiLCB0bXBUcmFucyk7XG4gICAgICAgIGRiLl9zdG9yZU5hbWVzID0gc2xpY2UoaWRiZGIub2JqZWN0U3RvcmVOYW1lcywgMCk7XG4gICAgICAgIHNldEFwaU9uUGxhY2UoZGIsIFtkYi5fYWxsVGFibGVzXSwga2V5cyhnbG9iYWxTY2hlbWEpLCBnbG9iYWxTY2hlbWEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2ZXJpZnlJbnN0YWxsZWRTY2hlbWEoZGIsIHRtcFRyYW5zKSB7XG4gICAgICAgIHZhciBpbnN0YWxsZWRTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgZGIuaWRiZGIsIHRtcFRyYW5zKTtcbiAgICAgICAgdmFyIGRpZmYgPSBnZXRTY2hlbWFEaWZmKGluc3RhbGxlZFNjaGVtYSwgZGIuX2RiU2NoZW1hKTtcbiAgICAgICAgcmV0dXJuICEoZGlmZi5hZGQubGVuZ3RoIHx8IGRpZmYuY2hhbmdlLnNvbWUoZnVuY3Rpb24gKGNoKSB7IHJldHVybiBjaC5hZGQubGVuZ3RoIHx8IGNoLmNoYW5nZS5sZW5ndGg7IH0pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMoZGIsIHNjaGVtYSwgaWRidHJhbnMpIHtcbiAgICAgICAgdmFyIHN0b3JlTmFtZXMgPSBpZGJ0cmFucy5kYi5vYmplY3RTdG9yZU5hbWVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3JlTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBzdG9yZU5hbWUgPSBzdG9yZU5hbWVzW2ldO1xuICAgICAgICAgICAgdmFyIHN0b3JlID0gaWRidHJhbnMub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgICAgICAgIGRiLl9oYXNHZXRBbGwgPSAnZ2V0QWxsJyBpbiBzdG9yZTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RvcmUuaW5kZXhOYW1lcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleE5hbWUgPSBzdG9yZS5pbmRleE5hbWVzW2pdO1xuICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoID0gc3RvcmUuaW5kZXgoaW5kZXhOYW1lKS5rZXlQYXRoO1xuICAgICAgICAgICAgICAgIHZhciBkZXhpZU5hbWUgPSB0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgPyBrZXlQYXRoIDogXCJbXCIgKyBzbGljZShrZXlQYXRoKS5qb2luKCcrJykgKyBcIl1cIjtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hW3N0b3JlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4U3BlYyA9IHNjaGVtYVtzdG9yZU5hbWVdLmlkeEJ5TmFtZVtkZXhpZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhTcGVjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleFNwZWMubmFtZSA9IGluZGV4TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFbc3RvcmVOYW1lXS5pZHhCeU5hbWVbZGV4aWVOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYVtzdG9yZU5hbWVdLmlkeEJ5TmFtZVtpbmRleE5hbWVdID0gaW5kZXhTcGVjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgICAgICAgICAhLyhDaHJvbWVcXC98RWRnZVxcLykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAgICAgICAgIF9nbG9iYWwuV29ya2VyR2xvYmFsU2NvcGUgJiYgX2dsb2JhbCBpbnN0YW5jZW9mIF9nbG9iYWwuV29ya2VyR2xvYmFsU2NvcGUgJiZcbiAgICAgICAgICAgIFtdLmNvbmNhdChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9TYWZhcmlcXC8oXFxkKikvKSlbMV0gPCA2MDQpIHtcbiAgICAgICAgICAgIGRiLl9oYXNHZXRBbGwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUluZGV4U3ludGF4KHByaW1LZXlBbmRJbmRleGVzKSB7XG4gICAgICAgIHJldHVybiBwcmltS2V5QW5kSW5kZXhlcy5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoaW5kZXgsIGluZGV4TnVtKSB7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4LnRyaW0oKTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gaW5kZXgucmVwbGFjZSgvKFsmKl18XFwrXFwrKS9nLCBcIlwiKTtcbiAgICAgICAgICAgIHZhciBrZXlQYXRoID0gL15cXFsvLnRlc3QobmFtZSkgPyBuYW1lLm1hdGNoKC9eXFxbKC4qKVxcXSQvKVsxXS5zcGxpdCgnKycpIDogbmFtZTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbmRleFNwZWMobmFtZSwga2V5UGF0aCB8fCBudWxsLCAvXFwmLy50ZXN0KGluZGV4KSwgL1xcKi8udGVzdChpbmRleCksIC9cXCtcXCsvLnRlc3QoaW5kZXgpLCBpc0FycmF5KGtleVBhdGgpLCBpbmRleE51bSA9PT0gMCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBWZXJzaW9uID0gIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFZlcnNpb24oKSB7XG4gICAgICAgIH1cbiAgICAgICAgVmVyc2lvbi5wcm90b3R5cGUuX3BhcnNlU3RvcmVzU3BlYyA9IGZ1bmN0aW9uIChzdG9yZXMsIG91dFNjaGVtYSkge1xuICAgICAgICAgICAga2V5cyhzdG9yZXMpLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdG9yZXNbdGFibGVOYW1lXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhlcyA9IHBhcnNlSW5kZXhTeW50YXgoc3RvcmVzW3RhYmxlTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJpbUtleSA9IGluZGV4ZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcHJpbUtleS51bmlxdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJpbUtleS5tdWx0aSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIlByaW1hcnkga2V5IGNhbm5vdCBiZSBtdWx0aS12YWx1ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4LmF1dG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiT25seSBwcmltYXJ5IGtleSBjYW4gYmUgbWFya2VkIGFzIGF1dG9JbmNyZW1lbnQgKCsrKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaWR4LmtleVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiSW5kZXggbXVzdCBoYXZlIGEgbmFtZSBhbmQgY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG91dFNjaGVtYVt0YWJsZU5hbWVdID0gY3JlYXRlVGFibGVTY2hlbWEodGFibGVOYW1lLCBwcmltS2V5LCBpbmRleGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgVmVyc2lvbi5wcm90b3R5cGUuc3RvcmVzID0gZnVuY3Rpb24gKHN0b3Jlcykge1xuICAgICAgICAgICAgdmFyIGRiID0gdGhpcy5kYjtcbiAgICAgICAgICAgIHRoaXMuX2NmZy5zdG9yZXNTb3VyY2UgPSB0aGlzLl9jZmcuc3RvcmVzU291cmNlID9cbiAgICAgICAgICAgICAgICBleHRlbmQodGhpcy5fY2ZnLnN0b3Jlc1NvdXJjZSwgc3RvcmVzKSA6XG4gICAgICAgICAgICAgICAgc3RvcmVzO1xuICAgICAgICAgICAgdmFyIHZlcnNpb25zID0gZGIuX3ZlcnNpb25zO1xuICAgICAgICAgICAgdmFyIHN0b3Jlc1NwZWMgPSB7fTtcbiAgICAgICAgICAgIHZhciBkYnNjaGVtYSA9IHt9O1xuICAgICAgICAgICAgdmVyc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgICAgICAgICAgIGV4dGVuZChzdG9yZXNTcGVjLCB2ZXJzaW9uLl9jZmcuc3RvcmVzU291cmNlKTtcbiAgICAgICAgICAgICAgICBkYnNjaGVtYSA9ICh2ZXJzaW9uLl9jZmcuZGJzY2hlbWEgPSB7fSk7XG4gICAgICAgICAgICAgICAgdmVyc2lvbi5fcGFyc2VTdG9yZXNTcGVjKHN0b3Jlc1NwZWMsIGRic2NoZW1hKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGIuX2RiU2NoZW1hID0gZGJzY2hlbWE7XG4gICAgICAgICAgICByZW1vdmVUYWJsZXNBcGkoZGIsIFtkYi5fYWxsVGFibGVzLCBkYiwgZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSk7XG4gICAgICAgICAgICBzZXRBcGlPblBsYWNlKGRiLCBbZGIuX2FsbFRhYmxlcywgZGIsIGRiLlRyYW5zYWN0aW9uLnByb3RvdHlwZSwgdGhpcy5fY2ZnLnRhYmxlc10sIGtleXMoZGJzY2hlbWEpLCBkYnNjaGVtYSk7XG4gICAgICAgICAgICBkYi5fc3RvcmVOYW1lcyA9IGtleXMoZGJzY2hlbWEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIFZlcnNpb24ucHJvdG90eXBlLnVwZ3JhZGUgPSBmdW5jdGlvbiAodXBncmFkZUZ1bmN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9jZmcuY29udGVudFVwZ3JhZGUgPSBwcm9taXNhYmxlQ2hhaW4odGhpcy5fY2ZnLmNvbnRlbnRVcGdyYWRlIHx8IG5vcCwgdXBncmFkZUZ1bmN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVmVyc2lvbjtcbiAgICB9KCkpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVmVyc2lvbkNvbnN0cnVjdG9yKGRiKSB7XG4gICAgICAgIHJldHVybiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcihWZXJzaW9uLnByb3RvdHlwZSwgZnVuY3Rpb24gVmVyc2lvbih2ZXJzaW9uTnVtYmVyKSB7XG4gICAgICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgICAgICB0aGlzLl9jZmcgPSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdmVyc2lvbk51bWJlcixcbiAgICAgICAgICAgICAgICBzdG9yZXNTb3VyY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgZGJzY2hlbWE6IHt9LFxuICAgICAgICAgICAgICAgIHRhYmxlczoge30sXG4gICAgICAgICAgICAgICAgY29udGVudFVwZ3JhZGU6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERiTmFtZXNUYWJsZShpbmRleGVkREIsIElEQktleVJhbmdlKSB7XG4gICAgICAgIHZhciBkYk5hbWVzREIgPSBpbmRleGVkREJbXCJfZGJOYW1lc0RCXCJdO1xuICAgICAgICBpZiAoIWRiTmFtZXNEQikge1xuICAgICAgICAgICAgZGJOYW1lc0RCID0gaW5kZXhlZERCW1wiX2RiTmFtZXNEQlwiXSA9IG5ldyBEZXhpZSQxKERCTkFNRVNfREIsIHtcbiAgICAgICAgICAgICAgICBhZGRvbnM6IFtdLFxuICAgICAgICAgICAgICAgIGluZGV4ZWREQjogaW5kZXhlZERCLFxuICAgICAgICAgICAgICAgIElEQktleVJhbmdlOiBJREJLZXlSYW5nZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGJOYW1lc0RCLnZlcnNpb24oMSkuc3RvcmVzKHsgZGJuYW1lczogXCJuYW1lXCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRiTmFtZXNEQi50YWJsZShcImRibmFtZXNcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc0RhdGFiYXNlc05hdGl2ZShpbmRleGVkREIpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4ZWREQiAmJiB0eXBlb2YgaW5kZXhlZERCLmRhdGFiYXNlcyA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXREYXRhYmFzZU5hbWVzKF9hKSB7XG4gICAgICAgIHZhciBpbmRleGVkREIgPSBfYS5pbmRleGVkREIsIElEQktleVJhbmdlID0gX2EuSURCS2V5UmFuZ2U7XG4gICAgICAgIHJldHVybiBoYXNEYXRhYmFzZXNOYXRpdmUoaW5kZXhlZERCKVxuICAgICAgICAgICAgPyBQcm9taXNlLnJlc29sdmUoaW5kZXhlZERCLmRhdGFiYXNlcygpKS50aGVuKGZ1bmN0aW9uIChpbmZvcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmZvc1xuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpbmZvKSB7IHJldHVybiBpbmZvLm5hbWU7IH0pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5hbWUgIT09IERCTkFNRVNfREI7IH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogZ2V0RGJOYW1lc1RhYmxlKGluZGV4ZWREQiwgSURCS2V5UmFuZ2UpLnRvQ29sbGVjdGlvbigpLnByaW1hcnlLZXlzKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9vbkRhdGFiYXNlQ3JlYXRlZChfYSwgbmFtZSkge1xuICAgICAgICB2YXIgaW5kZXhlZERCID0gX2EuaW5kZXhlZERCLCBJREJLZXlSYW5nZSA9IF9hLklEQktleVJhbmdlO1xuICAgICAgICAhaGFzRGF0YWJhc2VzTmF0aXZlKGluZGV4ZWREQikgJiZcbiAgICAgICAgICAgIG5hbWUgIT09IERCTkFNRVNfREIgJiZcbiAgICAgICAgICAgIGdldERiTmFtZXNUYWJsZShpbmRleGVkREIsIElEQktleVJhbmdlKS5wdXQoeyBuYW1lOiBuYW1lIH0pLmNhdGNoKG5vcCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9vbkRhdGFiYXNlRGVsZXRlZChfYSwgbmFtZSkge1xuICAgICAgICB2YXIgaW5kZXhlZERCID0gX2EuaW5kZXhlZERCLCBJREJLZXlSYW5nZSA9IF9hLklEQktleVJhbmdlO1xuICAgICAgICAhaGFzRGF0YWJhc2VzTmF0aXZlKGluZGV4ZWREQikgJiZcbiAgICAgICAgICAgIG5hbWUgIT09IERCTkFNRVNfREIgJiZcbiAgICAgICAgICAgIGdldERiTmFtZXNUYWJsZShpbmRleGVkREIsIElEQktleVJhbmdlKS5kZWxldGUobmFtZSkuY2F0Y2gobm9wKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2aXAoZm4pIHtcbiAgICAgICAgcmV0dXJuIG5ld1Njb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFBTRC5sZXRUaHJvdWdoID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpZGJSZWFkeSgpIHtcbiAgICAgICAgdmFyIGlzU2FmYXJpID0gIW5hdmlnYXRvci51c2VyQWdlbnREYXRhICYmXG4gICAgICAgICAgICAvU2FmYXJpXFwvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgICAgICAgICAhL0Nocm9tKGV8aXVtKVxcLy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgICAgaWYgKCFpc1NhZmFyaSB8fCAhaW5kZXhlZERCLmRhdGFiYXNlcylcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgdmFyIGludGVydmFsSWQ7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgdmFyIHRyeUlkYiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4ZWREQi5kYXRhYmFzZXMoKS5maW5hbGx5KHJlc29sdmUpOyB9O1xuICAgICAgICAgICAgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKHRyeUlkYiwgMTAwKTtcbiAgICAgICAgICAgIHRyeUlkYigpO1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7IH0pO1xuICAgIH1cblxuICAgIHZhciBfYTtcbiAgICBmdW5jdGlvbiBpc0VtcHR5UmFuZ2Uobm9kZSkge1xuICAgICAgICByZXR1cm4gIShcImZyb21cIiBpbiBub2RlKTtcbiAgICB9XG4gICAgdmFyIFJhbmdlU2V0ID0gZnVuY3Rpb24gKGZyb21PclRyZWUsIHRvKSB7XG4gICAgICAgIGlmICh0aGlzKSB7XG4gICAgICAgICAgICBleHRlbmQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IHsgZDogMSwgZnJvbTogZnJvbU9yVHJlZSwgdG86IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gdG8gOiBmcm9tT3JUcmVlIH0gOiB7IGQ6IDAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcnYgPSBuZXcgUmFuZ2VTZXQoKTtcbiAgICAgICAgICAgIGlmIChmcm9tT3JUcmVlICYmIChcImRcIiBpbiBmcm9tT3JUcmVlKSkge1xuICAgICAgICAgICAgICAgIGV4dGVuZChydiwgZnJvbU9yVHJlZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHByb3BzKFJhbmdlU2V0LnByb3RvdHlwZSwgKF9hID0ge1xuICAgICAgICAgICAgYWRkOiBmdW5jdGlvbiAocmFuZ2VTZXQpIHtcbiAgICAgICAgICAgICAgICBtZXJnZVJhbmdlcyh0aGlzLCByYW5nZVNldCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkS2V5OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgYWRkUmFuZ2UodGhpcywga2V5LCBrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZEtleXM6IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gYWRkUmFuZ2UoX3RoaXMsIGtleSwga2V5KTsgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9hW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRSYW5nZVNldEl0ZXJhdG9yKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBfYSkpO1xuICAgIGZ1bmN0aW9uIGFkZFJhbmdlKHRhcmdldCwgZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIGRpZmYgPSBjbXAoZnJvbSwgdG8pO1xuICAgICAgICBpZiAoaXNOYU4oZGlmZikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChkaWZmID4gMClcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoKTtcbiAgICAgICAgaWYgKGlzRW1wdHlSYW5nZSh0YXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuZCh0YXJnZXQsIHsgZnJvbTogZnJvbSwgdG86IHRvLCBkOiAxIH0pO1xuICAgICAgICB2YXIgbGVmdCA9IHRhcmdldC5sO1xuICAgICAgICB2YXIgcmlnaHQgPSB0YXJnZXQucjtcbiAgICAgICAgaWYgKGNtcCh0bywgdGFyZ2V0LmZyb20pIDwgMCkge1xuICAgICAgICAgICAgbGVmdFxuICAgICAgICAgICAgICAgID8gYWRkUmFuZ2UobGVmdCwgZnJvbSwgdG8pXG4gICAgICAgICAgICAgICAgOiAodGFyZ2V0LmwgPSB7IGZyb206IGZyb20sIHRvOiB0bywgZDogMSwgbDogbnVsbCwgcjogbnVsbCB9KTtcbiAgICAgICAgICAgIHJldHVybiByZWJhbGFuY2UodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY21wKGZyb20sIHRhcmdldC50bykgPiAwKSB7XG4gICAgICAgICAgICByaWdodFxuICAgICAgICAgICAgICAgID8gYWRkUmFuZ2UocmlnaHQsIGZyb20sIHRvKVxuICAgICAgICAgICAgICAgIDogKHRhcmdldC5yID0geyBmcm9tOiBmcm9tLCB0bzogdG8sIGQ6IDEsIGw6IG51bGwsIHI6IG51bGwgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmViYWxhbmNlKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNtcChmcm9tLCB0YXJnZXQuZnJvbSkgPCAwKSB7XG4gICAgICAgICAgICB0YXJnZXQuZnJvbSA9IGZyb207XG4gICAgICAgICAgICB0YXJnZXQubCA9IG51bGw7XG4gICAgICAgICAgICB0YXJnZXQuZCA9IHJpZ2h0ID8gcmlnaHQuZCArIDEgOiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbXAodG8sIHRhcmdldC50bykgPiAwKSB7XG4gICAgICAgICAgICB0YXJnZXQudG8gPSB0bztcbiAgICAgICAgICAgIHRhcmdldC5yID0gbnVsbDtcbiAgICAgICAgICAgIHRhcmdldC5kID0gdGFyZ2V0LmwgPyB0YXJnZXQubC5kICsgMSA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJpZ2h0V2FzQ3V0T2ZmID0gIXRhcmdldC5yO1xuICAgICAgICBpZiAobGVmdCAmJiAhdGFyZ2V0LmwpIHtcbiAgICAgICAgICAgIG1lcmdlUmFuZ2VzKHRhcmdldCwgbGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJpZ2h0ICYmIHJpZ2h0V2FzQ3V0T2ZmKSB7XG4gICAgICAgICAgICBtZXJnZVJhbmdlcyh0YXJnZXQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtZXJnZVJhbmdlcyh0YXJnZXQsIG5ld1NldCkge1xuICAgICAgICBmdW5jdGlvbiBfYWRkUmFuZ2VTZXQodGFyZ2V0LCBfYSkge1xuICAgICAgICAgICAgdmFyIGZyb20gPSBfYS5mcm9tLCB0byA9IF9hLnRvLCBsID0gX2EubCwgciA9IF9hLnI7XG4gICAgICAgICAgICBhZGRSYW5nZSh0YXJnZXQsIGZyb20sIHRvKTtcbiAgICAgICAgICAgIGlmIChsKVxuICAgICAgICAgICAgICAgIF9hZGRSYW5nZVNldCh0YXJnZXQsIGwpO1xuICAgICAgICAgICAgaWYgKHIpXG4gICAgICAgICAgICAgICAgX2FkZFJhbmdlU2V0KHRhcmdldCwgcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VtcHR5UmFuZ2UobmV3U2V0KSlcbiAgICAgICAgICAgIF9hZGRSYW5nZVNldCh0YXJnZXQsIG5ld1NldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJhbmdlc092ZXJsYXAocmFuZ2VTZXQxLCByYW5nZVNldDIpIHtcbiAgICAgICAgdmFyIGkxID0gZ2V0UmFuZ2VTZXRJdGVyYXRvcihyYW5nZVNldDIpO1xuICAgICAgICB2YXIgbmV4dFJlc3VsdDEgPSBpMS5uZXh0KCk7XG4gICAgICAgIGlmIChuZXh0UmVzdWx0MS5kb25lKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgYSA9IG5leHRSZXN1bHQxLnZhbHVlO1xuICAgICAgICB2YXIgaTIgPSBnZXRSYW5nZVNldEl0ZXJhdG9yKHJhbmdlU2V0MSk7XG4gICAgICAgIHZhciBuZXh0UmVzdWx0MiA9IGkyLm5leHQoYS5mcm9tKTtcbiAgICAgICAgdmFyIGIgPSBuZXh0UmVzdWx0Mi52YWx1ZTtcbiAgICAgICAgd2hpbGUgKCFuZXh0UmVzdWx0MS5kb25lICYmICFuZXh0UmVzdWx0Mi5kb25lKSB7XG4gICAgICAgICAgICBpZiAoY21wKGIuZnJvbSwgYS50bykgPD0gMCAmJiBjbXAoYi50bywgYS5mcm9tKSA+PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY21wKGEuZnJvbSwgYi5mcm9tKSA8IDBcbiAgICAgICAgICAgICAgICA/IChhID0gKG5leHRSZXN1bHQxID0gaTEubmV4dChiLmZyb20pKS52YWx1ZSlcbiAgICAgICAgICAgICAgICA6IChiID0gKG5leHRSZXN1bHQyID0gaTIubmV4dChhLmZyb20pKS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSYW5nZVNldEl0ZXJhdG9yKG5vZGUpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gaXNFbXB0eVJhbmdlKG5vZGUpID8gbnVsbCA6IHsgczogMCwgbjogbm9kZSB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlQcm92aWRlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlLnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UHJvdmlkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLm4ubCAmJiBjbXAoa2V5LCBzdGF0ZS5uLmZyb20pIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyB1cDogc3RhdGUsIG46IHN0YXRlLm4ubCwgczogMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLm4ubClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyB1cDogc3RhdGUsIG46IHN0YXRlLm4ubCwgczogMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWtleVByb3ZpZGVkIHx8IGNtcChrZXksIHN0YXRlLm4udG8pIDw9IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBzdGF0ZS5uLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5uLnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUucyA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyB1cDogc3RhdGUsIG46IHN0YXRlLm4uciwgczogMCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS51cDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWJhbGFuY2UodGFyZ2V0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBkaWZmID0gKCgoX2EgPSB0YXJnZXQucikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmQpIHx8IDApIC0gKCgoX2IgPSB0YXJnZXQubCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmQpIHx8IDApO1xuICAgICAgICB2YXIgciA9IGRpZmYgPiAxID8gXCJyXCIgOiBkaWZmIDwgLTEgPyBcImxcIiA6IFwiXCI7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICB2YXIgbCA9IHIgPT09IFwiclwiID8gXCJsXCIgOiBcInJcIjtcbiAgICAgICAgICAgIHZhciByb290Q2xvbmUgPSBfX2Fzc2lnbih7fSwgdGFyZ2V0KTtcbiAgICAgICAgICAgIHZhciBvbGRSb290UmlnaHQgPSB0YXJnZXRbcl07XG4gICAgICAgICAgICB0YXJnZXQuZnJvbSA9IG9sZFJvb3RSaWdodC5mcm9tO1xuICAgICAgICAgICAgdGFyZ2V0LnRvID0gb2xkUm9vdFJpZ2h0LnRvO1xuICAgICAgICAgICAgdGFyZ2V0W3JdID0gb2xkUm9vdFJpZ2h0W3JdO1xuICAgICAgICAgICAgcm9vdENsb25lW3JdID0gb2xkUm9vdFJpZ2h0W2xdO1xuICAgICAgICAgICAgdGFyZ2V0W2xdID0gcm9vdENsb25lO1xuICAgICAgICAgICAgcm9vdENsb25lLmQgPSBjb21wdXRlRGVwdGgocm9vdENsb25lKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuZCA9IGNvbXB1dGVEZXB0aCh0YXJnZXQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wdXRlRGVwdGgoX2EpIHtcbiAgICAgICAgdmFyIHIgPSBfYS5yLCBsID0gX2EubDtcbiAgICAgICAgcmV0dXJuIChyID8gKGwgPyBNYXRoLm1heChyLmQsIGwuZCkgOiByLmQpIDogbCA/IGwuZCA6IDApICsgMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmRPYnNlcnZhYmlsaXR5U2V0KHRhcmdldCwgbmV3U2V0KSB7XG4gICAgICAgIGtleXMobmV3U2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0W3BhcnRdKVxuICAgICAgICAgICAgICAgIG1lcmdlUmFuZ2VzKHRhcmdldFtwYXJ0XSwgbmV3U2V0W3BhcnRdKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0YXJnZXRbcGFydF0gPSBjbG9uZVNpbXBsZU9iamVjdFRyZWUobmV3U2V0W3BhcnRdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2JzU2V0c092ZXJsYXAob3MxLCBvczIpIHtcbiAgICAgICAgcmV0dXJuIG9zMS5hbGwgfHwgb3MyLmFsbCB8fCBPYmplY3Qua2V5cyhvczEpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gb3MyW2tleV0gJiYgcmFuZ2VzT3ZlcmxhcChvczJba2V5XSwgb3MxW2tleV0pOyB9KTtcbiAgICB9XG5cbiAgICB2YXIgY2FjaGUgPSB7fTtcblxuICAgIHZhciB1bnNpZ25hbGVkUGFydHMgPSB7fTtcbiAgICB2YXIgaXNUYXNrRW5xdWV1ZWQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBzaWduYWxTdWJzY3JpYmVyc0xhemlseShwYXJ0LCBvcHRpbWlzdGljKSB7XG4gICAgICAgIGV4dGVuZE9ic2VydmFiaWxpdHlTZXQodW5zaWduYWxlZFBhcnRzLCBwYXJ0KTtcbiAgICAgICAgaWYgKCFpc1Rhc2tFbnF1ZXVlZCkge1xuICAgICAgICAgICAgaXNUYXNrRW5xdWV1ZWQgPSB0cnVlO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaXNUYXNrRW5xdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSB1bnNpZ25hbGVkUGFydHM7XG4gICAgICAgICAgICAgICAgdW5zaWduYWxlZFBhcnRzID0ge307XG4gICAgICAgICAgICAgICAgc2lnbmFsU3Vic2NyaWJlcnNOb3cocGFydHMsIGZhbHNlKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNpZ25hbFN1YnNjcmliZXJzTm93KHVwZGF0ZWRQYXJ0cywgZGVsZXRlQWZmZWN0ZWRDYWNoZUVudHJpZXMpIHtcbiAgICAgICAgaWYgKGRlbGV0ZUFmZmVjdGVkQ2FjaGVFbnRyaWVzID09PSB2b2lkIDApIHsgZGVsZXRlQWZmZWN0ZWRDYWNoZUVudHJpZXMgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgcXVlcmllc1RvU2lnbmFsID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAodXBkYXRlZFBhcnRzLmFsbCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC52YWx1ZXMoY2FjaGUpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciB0YmxDYWNoZSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBjb2xsZWN0VGFibGVTdWJzY3JpYmVycyh0YmxDYWNoZSwgdXBkYXRlZFBhcnRzLCBxdWVyaWVzVG9TaWduYWwsIGRlbGV0ZUFmZmVjdGVkQ2FjaGVFbnRyaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB1cGRhdGVkUGFydHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSAvXmlkYlxcOlxcL1xcLyguKilcXC8oLiopXFwvLy5leGVjKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYk5hbWUgPSBwYXJ0c1sxXSwgdGFibGVOYW1lID0gcGFydHNbMl07XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YmxDYWNoZSA9IGNhY2hlW1wiaWRiOi8vXCIuY29uY2F0KGRiTmFtZSwgXCIvXCIpLmNvbmNhdCh0YWJsZU5hbWUpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRibENhY2hlKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdFRhYmxlU3Vic2NyaWJlcnModGJsQ2FjaGUsIHVwZGF0ZWRQYXJ0cywgcXVlcmllc1RvU2lnbmFsLCBkZWxldGVBZmZlY3RlZENhY2hlRW50cmllcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXJpZXNUb1NpZ25hbC5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXJ5KSB7IHJldHVybiByZXF1ZXJ5KCk7IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb2xsZWN0VGFibGVTdWJzY3JpYmVycyh0YmxDYWNoZSwgdXBkYXRlZFBhcnRzLCBvdXRRdWVyaWVzVG9TaWduYWwsIGRlbGV0ZUFmZmVjdGVkQ2FjaGVFbnRyaWVzKSB7XG4gICAgICAgIHZhciB1cGRhdGVkRW50cnlMaXN0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmVudHJpZXModGJsQ2FjaGUucXVlcmllcy5xdWVyeSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYVtfaV0sIGluZGV4TmFtZSA9IF9iWzBdLCBlbnRyaWVzID0gX2JbMV07XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWRFbnRyaWVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfYyA9IDAsIGVudHJpZXNfMSA9IGVudHJpZXM7IF9jIDwgZW50cmllc18xLmxlbmd0aDsgX2MrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNfMVtfY107XG4gICAgICAgICAgICAgICAgaWYgKG9ic1NldHNPdmVybGFwKHVwZGF0ZWRQYXJ0cywgZW50cnkub2JzU2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBlbnRyeS5zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXJ5KSB7IHJldHVybiBvdXRRdWVyaWVzVG9TaWduYWwuYWRkKHJlcXVlcnkpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVsZXRlQWZmZWN0ZWRDYWNoZUVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRFbnRyaWVzLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWxldGVBZmZlY3RlZENhY2hlRW50cmllcylcbiAgICAgICAgICAgICAgICB1cGRhdGVkRW50cnlMaXN0cy5wdXNoKFtpbmRleE5hbWUsIGZpbHRlcmVkRW50cmllc10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWxldGVBZmZlY3RlZENhY2hlRW50cmllcykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2QgPSAwLCB1cGRhdGVkRW50cnlMaXN0c18xID0gdXBkYXRlZEVudHJ5TGlzdHM7IF9kIDwgdXBkYXRlZEVudHJ5TGlzdHNfMS5sZW5ndGg7IF9kKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgX2UgPSB1cGRhdGVkRW50cnlMaXN0c18xW19kXSwgaW5kZXhOYW1lID0gX2VbMF0sIGZpbHRlcmVkRW50cmllcyA9IF9lWzFdO1xuICAgICAgICAgICAgICAgIHRibENhY2hlLnF1ZXJpZXMucXVlcnlbaW5kZXhOYW1lXSA9IGZpbHRlcmVkRW50cmllcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRleGllT3BlbihkYikge1xuICAgICAgICB2YXIgc3RhdGUgPSBkYi5fc3RhdGU7XG4gICAgICAgIHZhciBpbmRleGVkREIgPSBkYi5fZGVwcy5pbmRleGVkREI7XG4gICAgICAgIGlmIChzdGF0ZS5pc0JlaW5nT3BlbmVkIHx8IGRiLmlkYmRiKVxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RhdGUuZGJPcGVuRXJyb3IgP1xuICAgICAgICAgICAgICAgIHJlamVjdGlvbihzdGF0ZS5kYk9wZW5FcnJvcikgOlxuICAgICAgICAgICAgICAgIGRiOyB9KTtcbiAgICAgICAgc3RhdGUuaXNCZWluZ09wZW5lZCA9IHRydWU7XG4gICAgICAgIHN0YXRlLmRiT3BlbkVycm9yID0gbnVsbDtcbiAgICAgICAgc3RhdGUub3BlbkNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIHZhciBvcGVuQ2FuY2VsbGVyID0gc3RhdGUub3BlbkNhbmNlbGxlcjtcbiAgICAgICAgdmFyIG5hdGl2ZVZlclRvT3BlbiA9IE1hdGgucm91bmQoZGIudmVybm8gKiAxMCk7XG4gICAgICAgIHZhciBzY2hlbWFQYXRjaE1vZGUgPSBmYWxzZTtcbiAgICAgICAgZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxlZCgpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5vcGVuQ2FuY2VsbGVyICE9PSBvcGVuQ2FuY2VsbGVyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCdkYi5vcGVuKCkgd2FzIGNhbmNlbGxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXNvbHZlRGJSZWFkeSA9IHN0YXRlLmRiUmVhZHlSZXNvbHZlLFxuICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gPSBudWxsLCB3YXNDcmVhdGVkID0gZmFsc2U7XG4gICAgICAgIHZhciB0cnlPcGVuREIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIGlmICghaW5kZXhlZERCKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKTtcbiAgICAgICAgICAgIHZhciBkYk5hbWUgPSBkYi5uYW1lO1xuICAgICAgICAgICAgdmFyIHJlcSA9IHN0YXRlLmF1dG9TY2hlbWEgfHwgIW5hdGl2ZVZlclRvT3BlbiA/XG4gICAgICAgICAgICAgICAgaW5kZXhlZERCLm9wZW4oZGJOYW1lKSA6XG4gICAgICAgICAgICAgICAgaW5kZXhlZERCLm9wZW4oZGJOYW1lLCBuYXRpdmVWZXJUb09wZW4pO1xuICAgICAgICAgICAgaWYgKCFyZXEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSSgpO1xuICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgIHJlcS5vbmJsb2NrZWQgPSB3cmFwKGRiLl9maXJlT25CbG9ja2VkKTtcbiAgICAgICAgICAgIHJlcS5vbnVwZ3JhZGVuZWVkZWQgPSB3cmFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uID0gcmVxLnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5hdXRvU2NoZW1hICYmICFkYi5fb3B0aW9ucy5hbGxvd0VtcHR5REIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBwcmV2ZW50RGVmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5yZXN1bHQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHJlcSA9IGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShkYk5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBkZWxyZXEub25zdWNjZXNzID0gZGVscmVxLm9uZXJyb3IgPSB3cmFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgZXhjZXB0aW9ucy5Ob1N1Y2hEYXRhYmFzZShcIkRhdGFiYXNlIFwiLmNvbmNhdChkYk5hbWUsIFwiIGRvZXNudCBleGlzdFwiKSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbi5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbGRWZXIgPSBlLm9sZFZlcnNpb24gPiBNYXRoLnBvdygyLCA2MikgPyAwIDogZS5vbGRWZXJzaW9uO1xuICAgICAgICAgICAgICAgICAgICB3YXNDcmVhdGVkID0gb2xkVmVyIDwgMTtcbiAgICAgICAgICAgICAgICAgICAgZGIuaWRiZGIgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hUGF0Y2hNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaEN1cnJlbnRWZXJzaW9uKGRiLCB1cGdyYWRlVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJ1blVwZ3JhZGVycyhkYiwgb2xkVmVyIC8gMTAsIHVwZ3JhZGVUcmFuc2FjdGlvbiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGlkYmRiID0gZGIuaWRiZGIgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3RTdG9yZU5hbWVzID0gc2xpY2UoaWRiZGIub2JqZWN0U3RvcmVOYW1lcyk7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdFN0b3JlTmFtZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXBUcmFucyA9IGlkYmRiLnRyYW5zYWN0aW9uKHNhZmFyaU11bHRpU3RvcmVGaXgob2JqZWN0U3RvcmVOYW1lcyksICdyZWFkb25seScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmF1dG9TY2hlbWEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZEdsb2JhbFNjaGVtYShkYiwgaWRiZGIsIHRtcFRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBkYi5fZGJTY2hlbWEsIHRtcFRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZlcmlmeUluc3RhbGxlZFNjaGVtYShkYiwgdG1wVHJhbnMpICYmICFzY2hlbWFQYXRjaE1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRGV4aWUgU2NoZW1hRGlmZjogU2NoZW1hIHdhcyBleHRlbmRlZCB3aXRob3V0IGluY3JlYXNpbmcgdGhlIG51bWJlciBwYXNzZWQgdG8gZGIudmVyc2lvbigpLiBEZXhpZSB3aWxsIGFkZCBtaXNzaW5nIHBhcnRzIGFuZCBpbmNyZW1lbnQgbmF0aXZlIHZlcnNpb24gbnVtYmVyIHRvIHdvcmthcm91bmQgdGhpcy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkYmRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZVZlclRvT3BlbiA9IGlkYmRiLnZlcnNpb24gKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFQYXRjaE1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0cnlPcGVuREIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCB0bXBUcmFucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zLnB1c2goZGIpO1xuICAgICAgICAgICAgICAgIGlkYmRiLm9udmVyc2lvbmNoYW5nZSA9IHdyYXAoZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnZjRmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkYi5vbihcInZlcnNpb25jaGFuZ2VcIikuZmlyZShldik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWRiZGIub25jbG9zZSA9IHdyYXAoZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIGRiLm9uKFwiY2xvc2VcIikuZmlyZShldik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHdhc0NyZWF0ZWQpXG4gICAgICAgICAgICAgICAgICAgIF9vbkRhdGFiYXNlQ3JlYXRlZChkYi5fZGVwcywgZGJOYW1lKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlVua25vd25FcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuUFIxMzk4X21heExvb3AgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5QUjEzOThfbWF4TG9vcC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXhpZTogV29ya2Fyb3VuZCBmb3IgQ2hyb21lIFVua25vd25FcnJvciBvbiBvcGVuKCknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlPcGVuREIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiVmVyc2lvbkVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYXRpdmVWZXJUb09wZW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVWZXJUb09wZW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeU9wZW5EQigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfSk7IH07XG4gICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmFjZShbXG4gICAgICAgICAgICBvcGVuQ2FuY2VsbGVyLFxuICAgICAgICAgICAgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnID8gRGV4aWVQcm9taXNlLnJlc29sdmUoKSA6IGlkYlJlYWR5KCkpLnRoZW4odHJ5T3BlbkRCKVxuICAgICAgICBdKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkID0gW107XG4gICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUodmlwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRiLm9uLnJlYWR5LmZpcmUoZGIudmlwKTsgfSkpLnRoZW4oZnVuY3Rpb24gZmlyZVJlbWFpbmRlcnMoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbWFpbmRlcnNfMSA9IHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkLnJlZHVjZShwcm9taXNhYmxlQ2hhaW4sIG5vcCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkID0gW107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZSh2aXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVtYWluZGVyc18xKGRiLnZpcCk7IH0pKS50aGVuKGZpcmVSZW1haW5kZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUub3BlbkNhbmNlbGxlciA9PT0gb3BlbkNhbmNlbGxlcikge1xuICAgICAgICAgICAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc0JlaW5nT3BlbmVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHN0YXRlLmRiT3BlbkVycm9yID0gZXJyO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gJiYgdXBncmFkZVRyYW5zYWN0aW9uLmFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgICAgICAgaWYgKG9wZW5DYW5jZWxsZXIgPT09IHN0YXRlLm9wZW5DYW5jZWxsZXIpIHtcbiAgICAgICAgICAgICAgICBkYi5fY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZXJyKTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZURiUmVhZHkoKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAod2FzQ3JlYXRlZCkge1xuICAgICAgICAgICAgICAgIHZhciBldmVyeXRoaW5nXzEgPSB7fTtcbiAgICAgICAgICAgICAgICBkYi50YWJsZXMuZm9yRWFjaChmdW5jdGlvbiAodGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFibGUuc2NoZW1hLmluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4Lm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlcnl0aGluZ18xW1wiaWRiOi8vXCIuY29uY2F0KGRiLm5hbWUsIFwiL1wiKS5jb25jYXQodGFibGUubmFtZSwgXCIvXCIpLmNvbmNhdChpZHgubmFtZSldID0gbmV3IFJhbmdlU2V0KC1JbmZpbml0eSwgW1tbXV1dKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZXJ5dGhpbmdfMVtcImlkYjovL1wiLmNvbmNhdChkYi5uYW1lLCBcIi9cIikuY29uY2F0KHRhYmxlLm5hbWUsIFwiL1wiKV0gPSBldmVyeXRoaW5nXzFbXCJpZGI6Ly9cIi5jb25jYXQoZGIubmFtZSwgXCIvXCIpLmNvbmNhdCh0YWJsZS5uYW1lLCBcIi86ZGVsc1wiKV0gPSBuZXcgUmFuZ2VTZXQoLUluZmluaXR5LCBbW1tdXV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSkuZmlyZShldmVyeXRoaW5nXzEpO1xuICAgICAgICAgICAgICAgIHNpZ25hbFN1YnNjcmliZXJzTm93KGV2ZXJ5dGhpbmdfMSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGI7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGF3YWl0SXRlcmF0b3IoaXRlcmF0b3IpIHtcbiAgICAgICAgdmFyIGNhbGxOZXh0ID0gZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gaXRlcmF0b3IubmV4dChyZXN1bHQpOyB9LCBkb1Rocm93ID0gZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBpdGVyYXRvci50aHJvdyhlcnJvcik7IH0sIG9uU3VjY2VzcyA9IHN0ZXAoY2FsbE5leHQpLCBvbkVycm9yID0gc3RlcChkb1Rocm93KTtcbiAgICAgICAgZnVuY3Rpb24gc3RlcChnZXROZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gZ2V0TmV4dCh2YWwpLCB2YWx1ZSA9IG5leHQudmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQuZG9uZSA/IHZhbHVlIDpcbiAgICAgICAgICAgICAgICAgICAgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUudGhlbiAhPT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FycmF5KHZhbHVlKSA/IFByb21pc2UuYWxsKHZhbHVlKS50aGVuKG9uU3VjY2Vzcywgb25FcnJvcikgOiBvblN1Y2Nlc3ModmFsdWUpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGVwKGNhbGxOZXh0KSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dHJhY3RUcmFuc2FjdGlvbkFyZ3MobW9kZSwgX3RhYmxlQXJnc18sIHNjb3BlRnVuYykge1xuICAgICAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChpIDwgMilcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIlRvbyBmZXcgYXJndW1lbnRzXCIpO1xuICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShpIC0gMSk7XG4gICAgICAgIHdoaWxlICgtLWkpXG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgc2NvcGVGdW5jID0gYXJncy5wb3AoKTtcbiAgICAgICAgdmFyIHRhYmxlcyA9IGZsYXR0ZW4oYXJncyk7XG4gICAgICAgIHJldHVybiBbbW9kZSwgdGFibGVzLCBzY29wZUZ1bmNdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnRlclRyYW5zYWN0aW9uU2NvcGUoZGIsIG1vZGUsIHN0b3JlTmFtZXMsIHBhcmVudFRyYW5zYWN0aW9uLCBzY29wZUZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNsZXNzID0gUFNELnRyYW5zbGVzcyB8fCBQU0Q7XG4gICAgICAgICAgICB2YXIgdHJhbnMgPSBkYi5fY3JlYXRlVHJhbnNhY3Rpb24obW9kZSwgc3RvcmVOYW1lcywgZGIuX2RiU2NoZW1hLCBwYXJlbnRUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICB0cmFucy5leHBsaWNpdCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgem9uZVByb3BzID0ge1xuICAgICAgICAgICAgICAgIHRyYW5zOiB0cmFucyxcbiAgICAgICAgICAgICAgICB0cmFuc2xlc3M6IHRyYW5zbGVzc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIHRyYW5zLmlkYnRyYW5zID0gcGFyZW50VHJhbnNhY3Rpb24uaWRidHJhbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0cmFucy5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnMuaWRidHJhbnMuX2V4cGxpY2l0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGIuX3N0YXRlLlBSMTM5OF9tYXhMb29wID0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleC5uYW1lID09PSBlcnJuYW1lcy5JbnZhbGlkU3RhdGUgJiYgZGIuaXNPcGVuKCkgJiYgLS1kYi5fc3RhdGUuUFIxMzk4X21heExvb3AgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RleGllOiBOZWVkIHRvIHJlb3BlbiBkYicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoeyBkaXNhYmxlQXV0b09wZW46IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRiLm9wZW4oKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVudGVyVHJhbnNhY3Rpb25TY29wZShkYiwgbW9kZSwgc3RvcmVOYW1lcywgbnVsbCwgc2NvcGVGdW5jKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNjb3BlRnVuY0lzQXN5bmMgPSBpc0FzeW5jRnVuY3Rpb24oc2NvcGVGdW5jKTtcbiAgICAgICAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG4gICAgICAgICAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgIHZhciBwcm9taXNlRm9sbG93ZWQgPSBEZXhpZVByb21pc2UuZm9sbG93KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHNjb3BlRnVuYy5jYWxsKHRyYW5zLCB0cmFucyk7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVjcmVtZW50b3IgPSBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cy5iaW5kKG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUudGhlbihkZWNyZW1lbnRvciwgZGVjcmVtZW50b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiByZXR1cm5WYWx1ZS5uZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiByZXR1cm5WYWx1ZS50aHJvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBhd2FpdEl0ZXJhdG9yKHJldHVyblZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHpvbmVQcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gKHJldHVyblZhbHVlICYmIHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICBEZXhpZVByb21pc2UucmVzb2x2ZShyZXR1cm5WYWx1ZSkudGhlbihmdW5jdGlvbiAoeCkgeyByZXR1cm4gdHJhbnMuYWN0aXZlID9cbiAgICAgICAgICAgICAgICAgICAgeFxuICAgICAgICAgICAgICAgICAgICA6IHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5QcmVtYXR1cmVDb21taXQoXCJUcmFuc2FjdGlvbiBjb21taXR0ZWQgdG9vIGVhcmx5LiBTZWUgaHR0cDovL2JpdC5seS8ya2Rja01uXCIpKTsgfSlcbiAgICAgICAgICAgICAgICA6IHByb21pc2VGb2xsb3dlZC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJldHVyblZhbHVlOyB9KSkudGhlbihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgdHJhbnMuX3Jlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnMuX2NvbXBsZXRpb24udGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB4OyB9KTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdHJhbnMuX3JlamVjdChlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhZChhLCB2YWx1ZSwgY291bnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGlzQXJyYXkoYSkgPyBhLnNsaWNlKCkgOiBbYV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlVmlydHVhbEluZGV4TWlkZGxld2FyZShkb3duKSB7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZG93biksIHsgdGFibGU6IGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBkb3duLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIHNjaGVtYSA9IHRhYmxlLnNjaGVtYTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhMb29rdXAgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgYWxsVmlydHVhbEluZGV4ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhZGRWaXJ0dWFsSW5kZXhlcyhrZXlQYXRoLCBrZXlUYWlsLCBsb3dMZXZlbEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoQWxpYXMgPSBnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleExpc3QgPSAoaW5kZXhMb29rdXBba2V5UGF0aEFsaWFzXSA9IGluZGV4TG9va3VwW2tleVBhdGhBbGlhc10gfHwgW10pO1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5TGVuZ3RoID0ga2V5UGF0aCA9PSBudWxsID8gMCA6IHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyA/IDEgOiBrZXlQYXRoLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzVmlydHVhbCA9IGtleVRhaWwgPiAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmlydHVhbEluZGV4ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGxvd0xldmVsSW5kZXgpLCB7IG5hbWU6IGlzVmlydHVhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJcIi5jb25jYXQoa2V5UGF0aEFsaWFzLCBcIih2aXJ0dWFsLWZyb206XCIpLmNvbmNhdChsb3dMZXZlbEluZGV4Lm5hbWUsIFwiKVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbG93TGV2ZWxJbmRleC5uYW1lLCBsb3dMZXZlbEluZGV4OiBsb3dMZXZlbEluZGV4LCBpc1ZpcnR1YWw6IGlzVmlydHVhbCwga2V5VGFpbDoga2V5VGFpbCwga2V5TGVuZ3RoOiBrZXlMZW5ndGgsIGV4dHJhY3RLZXk6IGdldEtleUV4dHJhY3RvcihrZXlQYXRoKSwgdW5pcXVlOiAhaXNWaXJ0dWFsICYmIGxvd0xldmVsSW5kZXgudW5pcXVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBpbmRleExpc3QucHVzaCh2aXJ0dWFsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZpcnR1YWxJbmRleC5pc1ByaW1hcnlLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbFZpcnR1YWxJbmRleGVzLnB1c2godmlydHVhbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5TGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpcnR1YWxLZXlQYXRoID0ga2V5TGVuZ3RoID09PSAyID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXRoWzBdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXRoLnNsaWNlKDAsIGtleUxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkVmlydHVhbEluZGV4ZXModmlydHVhbEtleVBhdGgsIGtleVRhaWwgKyAxLCBsb3dMZXZlbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbmRleExpc3Quc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5rZXlUYWlsIC0gYi5rZXlUYWlsOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpcnR1YWxJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHByaW1hcnlLZXkgPSBhZGRWaXJ0dWFsSW5kZXhlcyhzY2hlbWEucHJpbWFyeUtleS5rZXlQYXRoLCAwLCBzY2hlbWEucHJpbWFyeUtleSk7XG4gICAgICAgICAgICAgICAgaW5kZXhMb29rdXBbXCI6aWRcIl0gPSBbcHJpbWFyeUtleV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHNjaGVtYS5pbmRleGVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGFkZFZpcnR1YWxJbmRleGVzKGluZGV4LmtleVBhdGgsIDAsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZmluZEJlc3RJbmRleChrZXlQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBpbmRleExvb2t1cFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICYmIHJlc3VsdFswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdHJhbnNsYXRlUmFuZ2UocmFuZ2UsIGtleVRhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHJhbmdlLnR5cGUgPT09IDEgID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyICA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyOiBwYWQocmFuZ2UubG93ZXIsIHJhbmdlLmxvd2VyT3BlbiA/IGRvd24uTUFYX0tFWSA6IGRvd24uTUlOX0tFWSwga2V5VGFpbCksXG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlck9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cHBlcjogcGFkKHJhbmdlLnVwcGVyLCByYW5nZS51cHBlck9wZW4gPyBkb3duLk1JTl9LRVkgOiBkb3duLk1BWF9LRVksIGtleVRhaWwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJPcGVuOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVJlcXVlc3QocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHJlcS5xdWVyeS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4LmlzVmlydHVhbCA/IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXEpLCB7IHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4Lmxvd0xldmVsSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHRyYW5zbGF0ZVJhbmdlKHJlcS5xdWVyeS5yYW5nZSwgaW5kZXgua2V5VGFpbClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gfSkgOiByZXE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGFibGUpLCB7IHNjaGVtYTogX19hc3NpZ24oX19hc3NpZ24oe30sIHNjaGVtYSksIHsgcHJpbWFyeUtleTogcHJpbWFyeUtleSwgaW5kZXhlczogYWxsVmlydHVhbEluZGV4ZXMsIGdldEluZGV4QnlLZXlQYXRoOiBmaW5kQmVzdEluZGV4IH0pLCBjb3VudDogZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLmNvdW50KHRyYW5zbGF0ZVJlcXVlc3QocmVxKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHF1ZXJ5OiBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUucXVlcnkodHJhbnNsYXRlUmVxdWVzdChyZXEpKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgb3BlbkN1cnNvcjogZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gcmVxLnF1ZXJ5LmluZGV4LCBrZXlUYWlsID0gX2Eua2V5VGFpbCwgaXNWaXJ0dWFsID0gX2EuaXNWaXJ0dWFsLCBrZXlMZW5ndGggPSBfYS5rZXlMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmlydHVhbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUub3BlbkN1cnNvcihyZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlVmlydHVhbEN1cnNvcihjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBfY29udGludWUoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSAhPSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShwYWQoa2V5LCByZXEucmV2ZXJzZSA/IGRvd24uTUFYX0tFWSA6IGRvd24uTUlOX0tFWSwga2V5VGFpbCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS51bmlxdWUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShjdXJzb3Iua2V5LnNsaWNlKDAsIGtleUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChyZXEucmV2ZXJzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGRvd24uTUlOX0tFWVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGRvd24uTUFYX0tFWSwga2V5VGFpbCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpcnR1YWxDdXJzb3IgPSBPYmplY3QuY3JlYXRlKGN1cnNvciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTogeyB2YWx1ZTogX2NvbnRpbnVlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlUHJpbWFyeUtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChrZXksIHByaW1hcnlLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5KHBhZChrZXksIGRvd24uTUFYX0tFWSwga2V5VGFpbCksIHByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5S2V5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yLnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGN1cnNvci5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleUxlbmd0aCA9PT0gMSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVswXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleS5zbGljZSgwLCBrZXlMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXJ0dWFsQ3Vyc29yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLm9wZW5DdXJzb3IodHJhbnNsYXRlUmVxdWVzdChyZXEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjdXJzb3IpIHsgcmV0dXJuIGN1cnNvciAmJiBjcmVhdGVWaXJ0dWFsQ3Vyc29yKGN1cnNvcik7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9IH0pO1xuICAgIH1cbiAgICB2YXIgdmlydHVhbEluZGV4TWlkZGxld2FyZSA9IHtcbiAgICAgICAgc3RhY2s6IFwiZGJjb3JlXCIsXG4gICAgICAgIG5hbWU6IFwiVmlydHVhbEluZGV4TWlkZGxld2FyZVwiLFxuICAgICAgICBsZXZlbDogMSxcbiAgICAgICAgY3JlYXRlOiBjcmVhdGVWaXJ0dWFsSW5kZXhNaWRkbGV3YXJlXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldE9iamVjdERpZmYoYSwgYiwgcnYsIHByZngpIHtcbiAgICAgICAgcnYgPSBydiB8fCB7fTtcbiAgICAgICAgcHJmeCA9IHByZnggfHwgJyc7XG4gICAgICAgIGtleXMoYSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd24oYiwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBydltwcmZ4ICsgcHJvcF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYXAgPSBhW3Byb3BdLCBicCA9IGJbcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGJwID09PSAnb2JqZWN0JyAmJiBhcCAmJiBicCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXBUeXBlTmFtZSA9IHRvU3RyaW5nVGFnKGFwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJwVHlwZU5hbWUgPSB0b1N0cmluZ1RhZyhicCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcFR5cGVOYW1lICE9PSBicFR5cGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydltwcmZ4ICsgcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFwVHlwZU5hbWUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRPYmplY3REaWZmKGFwLCBicCwgcnYsIHByZnggKyBwcm9wICsgJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhcCAhPT0gYnApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXAgIT09IGJwKVxuICAgICAgICAgICAgICAgICAgICBydltwcmZ4ICsgcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAga2V5cyhiKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBpZiAoIWhhc093bihhLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RWZmZWN0aXZlS2V5cyhwcmltYXJ5S2V5LCByZXEpIHtcbiAgICAgICAgaWYgKHJlcS50eXBlID09PSAnZGVsZXRlJylcbiAgICAgICAgICAgIHJldHVybiByZXEua2V5cztcbiAgICAgICAgcmV0dXJuIHJlcS5rZXlzIHx8IHJlcS52YWx1ZXMubWFwKHByaW1hcnlLZXkuZXh0cmFjdEtleSk7XG4gICAgfVxuXG4gICAgdmFyIGhvb2tzTWlkZGxld2FyZSA9IHtcbiAgICAgICAgc3RhY2s6IFwiZGJjb3JlXCIsXG4gICAgICAgIG5hbWU6IFwiSG9va3NNaWRkbGV3YXJlXCIsXG4gICAgICAgIGxldmVsOiAyLFxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIChkb3duQ29yZSkgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBkb3duQ29yZSksIHsgdGFibGU6IGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG93blRhYmxlID0gZG93bkNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJpbWFyeUtleSA9IGRvd25UYWJsZS5zY2hlbWEucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICB2YXIgdGFibGVNaWRkbGV3YXJlID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGRvd25UYWJsZSksIHsgbXV0YXRlOiBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHhUcmFucyA9IFBTRC50cmFucztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IGR4VHJhbnMudGFibGUodGFibGVOYW1lKS5ob29rLCBkZWxldGluZyA9IF9hLmRlbGV0aW5nLCBjcmVhdGluZyA9IF9hLmNyZWF0aW5nLCB1cGRhdGluZyA9IF9hLnVwZGF0aW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChyZXEudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FkZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjcmVhdGluZy5maXJlID09PSBub3ApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkZFB1dE9yRGVsZXRlKHJlcSk7IH0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3B1dCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjcmVhdGluZy5maXJlID09PSBub3AgJiYgdXBkYXRpbmcuZmlyZSA9PT0gbm9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkeFRyYW5zLl9wcm9taXNlKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBhZGRQdXRPckRlbGV0ZShyZXEpOyB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsZXRpbmcuZmlyZSA9PT0gbm9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkeFRyYW5zLl9wcm9taXNlKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBhZGRQdXRPckRlbGV0ZShyZXEpOyB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkZWxldGVSYW5nZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGluZy5maXJlID09PSBub3ApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlbGV0ZVJhbmdlKHJlcSk7IH0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvd25UYWJsZS5tdXRhdGUocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFB1dE9yRGVsZXRlKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeFRyYW5zID0gUFNELnRyYW5zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gcmVxLmtleXMgfHwgZ2V0RWZmZWN0aXZlS2V5cyhwcmltYXJ5S2V5LCByZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgha2V5cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5cyBtaXNzaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IHJlcS50eXBlID09PSAnYWRkJyB8fCByZXEudHlwZSA9PT0gJ3B1dCcgPyBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVxKSwgeyBrZXlzOiBrZXlzIH0pIDogX19hc3NpZ24oe30sIHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS50eXBlICE9PSAnZGVsZXRlJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnZhbHVlcyA9IF9fc3ByZWFkQXJyYXkoW10sIHJlcS52YWx1ZXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEua2V5cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmtleXMgPSBfX3NwcmVhZEFycmF5KFtdLCByZXEua2V5cywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEV4aXN0aW5nVmFsdWVzKGRvd25UYWJsZSwgcmVxLCBrZXlzKS50aGVuKGZ1bmN0aW9uIChleGlzdGluZ1ZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dHMgPSBrZXlzLm1hcChmdW5jdGlvbiAoa2V5LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IGV4aXN0aW5nVmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IHsgb25lcnJvcjogbnVsbCwgb25zdWNjZXNzOiBudWxsIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnR5cGUgPT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRpbmcuZmlyZS5jYWxsKGN0eCwga2V5LCBleGlzdGluZ1ZhbHVlLCBkeFRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcS50eXBlID09PSAnYWRkJyB8fCBleGlzdGluZ1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2VuZXJhdGVkUHJpbWFyeUtleSA9IGNyZWF0aW5nLmZpcmUuY2FsbChjdHgsIGtleSwgcmVxLnZhbHVlc1tpXSwgZHhUcmFucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSBudWxsICYmIGdlbmVyYXRlZFByaW1hcnlLZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBnZW5lcmF0ZWRQcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEua2V5c1tpXSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmltYXJ5S2V5Lm91dGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgocmVxLnZhbHVlc1tpXSwgcHJpbWFyeUtleS5rZXlQYXRoLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdERpZmYgPSBnZXRPYmplY3REaWZmKGV4aXN0aW5nVmFsdWUsIHJlcS52YWx1ZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRpdGlvbmFsQ2hhbmdlc18xID0gdXBkYXRpbmcuZmlyZS5jYWxsKGN0eCwgb2JqZWN0RGlmZiwga2V5LCBleGlzdGluZ1ZhbHVlLCBkeFRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbENoYW5nZXNfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdGVkVmFsdWVfMSA9IHJlcS52YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGFkZGl0aW9uYWxDaGFuZ2VzXzEpLmZvckVhY2goZnVuY3Rpb24gKGtleVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd24ocmVxdWVzdGVkVmFsdWVfMSwga2V5UGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRWYWx1ZV8xW2tleVBhdGhdID0gYWRkaXRpb25hbENoYW5nZXNfMVtrZXlQYXRoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChyZXF1ZXN0ZWRWYWx1ZV8xLCBrZXlQYXRoLCBhZGRpdGlvbmFsQ2hhbmdlc18xW2tleVBhdGhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUubXV0YXRlKHJlcSkudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWlsdXJlcyA9IF9hLmZhaWx1cmVzLCByZXN1bHRzID0gX2EucmVzdWx0cywgbnVtRmFpbHVyZXMgPSBfYS5udW1GYWlsdXJlcywgbGFzdFJlc3VsdCA9IF9hLmxhc3RSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJpbUtleSA9IHJlc3VsdHMgPyByZXN1bHRzW2ldIDoga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY29udGV4dHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByaW1LZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgub25lcnJvciAmJiBjdHgub25lcnJvcihmYWlsdXJlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgub25zdWNjZXNzICYmIGN0eC5vbnN1Y2Nlc3MocmVxLnR5cGUgPT09ICdwdXQnICYmIGV4aXN0aW5nVmFsdWVzW2ldID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS52YWx1ZXNbaV0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGZhaWx1cmVzOiBmYWlsdXJlcywgcmVzdWx0czogcmVzdWx0cywgbnVtRmFpbHVyZXM6IG51bUZhaWx1cmVzLCBsYXN0UmVzdWx0OiBsYXN0UmVzdWx0IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dHMuZm9yRWFjaChmdW5jdGlvbiAoY3R4KSB7IHJldHVybiBjdHgub25lcnJvciAmJiBjdHgub25lcnJvcihlcnJvcik7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZWxldGVSYW5nZShyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlTmV4dENodW5rKHJlcS50cmFucywgcmVxLnJhbmdlLCAxMDAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZWxldGVOZXh0Q2h1bmsodHJhbnMsIHJhbmdlLCBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUucXVlcnkoeyB0cmFuczogdHJhbnMsIHZhbHVlczogZmFsc2UsIHF1ZXJ5OiB7IGluZGV4OiBwcmltYXJ5S2V5LCByYW5nZTogcmFuZ2UgfSwgbGltaXQ6IGxpbWl0IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gX2EucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkUHV0T3JEZWxldGUoeyB0eXBlOiAnZGVsZXRlJywga2V5czogcmVzdWx0LCB0cmFuczogdHJhbnMgfSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzLm51bUZhaWx1cmVzID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoIDwgbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBmYWlsdXJlczogW10sIG51bUZhaWx1cmVzOiAwLCBsYXN0UmVzdWx0OiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWxldGVOZXh0Q2h1bmsodHJhbnMsIF9fYXNzaWduKF9fYXNzaWduKHt9LCByYW5nZSksIHsgbG93ZXI6IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0sIGxvd2VyT3BlbjogdHJ1ZSB9KSwgbGltaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVNaWRkbGV3YXJlO1xuICAgICAgICAgICAgfSB9KSk7IH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGdldEV4aXN0aW5nVmFsdWVzKHRhYmxlLCByZXEsIGVmZmVjdGl2ZUtleXMpIHtcbiAgICAgICAgcmV0dXJuIHJlcS50eXBlID09PSBcImFkZFwiXG4gICAgICAgICAgICA/IFByb21pc2UucmVzb2x2ZShbXSlcbiAgICAgICAgICAgIDogdGFibGUuZ2V0TWFueSh7IHRyYW5zOiByZXEudHJhbnMsIGtleXM6IGVmZmVjdGl2ZUtleXMsIGNhY2hlOiBcImltbXV0YWJsZVwiIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEZyb21UcmFuc2FjdGlvbkNhY2hlKGtleXMsIGNhY2hlLCBjbG9uZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChjYWNoZS5rZXlzLmxlbmd0aCA8IGtleXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgY2FjaGUua2V5cy5sZW5ndGggJiYgaiA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoY21wKGNhY2hlLmtleXNbaV0sIGtleXNbal0pICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjbG9uZSA/IGRlZXBDbG9uZShjYWNoZS52YWx1ZXNbaV0pIDogY2FjaGUudmFsdWVzW2ldKTtcbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0ga2V5cy5sZW5ndGggPyByZXN1bHQgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNhY2hlRXhpc3RpbmdWYWx1ZXNNaWRkbGV3YXJlID0ge1xuICAgICAgICBzdGFjazogXCJkYmNvcmVcIixcbiAgICAgICAgbGV2ZWw6IC0xLFxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIChjb3JlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRhYmxlOiBmdW5jdGlvbiAodGFibGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IGNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCB0YWJsZSksIHsgZ2V0TWFueTogZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVxLmNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5nZXRNYW55KHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBnZXRGcm9tVHJhbnNhY3Rpb25DYWNoZShyZXEua2V5cywgcmVxLnRyYW5zW1wiX2NhY2hlXCJdLCByZXEuY2FjaGUgPT09IFwiY2xvbmVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUoY2FjaGVkUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLmdldE1hbnkocmVxKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnRyYW5zW1wiX2NhY2hlXCJdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5czogcmVxLmtleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHJlcS5jYWNoZSA9PT0gXCJjbG9uZVwiID8gZGVlcENsb25lKHJlcykgOiByZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBtdXRhdGU6IGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnR5cGUgIT09IFwiYWRkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS50cmFuc1tcIl9jYWNoZVwiXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLm11dGF0ZShyZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNDYWNoYWJsZUNvbnRleHQoY3R4LCB0YWJsZSkge1xuICAgICAgICByZXR1cm4gKGN0eC50cmFucy5tb2RlID09PSAncmVhZG9ubHknICYmXG4gICAgICAgICAgICAhIWN0eC5zdWJzY3IgJiZcbiAgICAgICAgICAgICFjdHgudHJhbnMuZXhwbGljaXQgJiZcbiAgICAgICAgICAgIGN0eC50cmFucy5kYi5fb3B0aW9ucy5jYWNoZSAhPT0gJ2Rpc2FibGVkJyAmJlxuICAgICAgICAgICAgIXRhYmxlLnNjaGVtYS5wcmltYXJ5S2V5Lm91dGJvdW5kKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0NhY2hhYmxlUmVxdWVzdCh0eXBlLCByZXEpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdxdWVyeSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcS52YWx1ZXMgJiYgIXJlcS51bmlxdWU7XG4gICAgICAgICAgICBjYXNlICdnZXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgJ2dldE1hbnknOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgJ2NvdW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlICdvcGVuQ3Vyc29yJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgb2JzZXJ2YWJpbGl0eU1pZGRsZXdhcmUgPSB7XG4gICAgICAgIHN0YWNrOiBcImRiY29yZVwiLFxuICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgbmFtZTogXCJPYnNlcnZhYmlsaXR5XCIsXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGNvcmUpIHtcbiAgICAgICAgICAgIHZhciBkYk5hbWUgPSBjb3JlLnNjaGVtYS5uYW1lO1xuICAgICAgICAgICAgdmFyIEZVTExfUkFOR0UgPSBuZXcgUmFuZ2VTZXQoY29yZS5NSU5fS0VZLCBjb3JlLk1BWF9LRVkpO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBjb3JlKSwgeyB0cmFuc2FjdGlvbjogZnVuY3Rpb24gKHN0b3JlcywgbW9kZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoUFNELnN1YnNjciAmJiBtb2RlICE9PSAncmVhZG9ubHknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5SZWFkT25seShcIlJlYWR3cml0ZSB0cmFuc2FjdGlvbiBpbiBsaXZlUXVlcnkgY29udGV4dC4gUXVlcmllciBzb3VyY2U6IFwiLmNvbmNhdChQU0QucXVlcmllcikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLnRyYW5zYWN0aW9uKHN0b3JlcywgbW9kZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSwgdGFibGU6IGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2NoZW1hID0gdGFibGUuc2NoZW1hO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJpbWFyeUtleSA9IHNjaGVtYS5wcmltYXJ5S2V5LCBpbmRleGVzID0gc2NoZW1hLmluZGV4ZXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleHRyYWN0S2V5ID0gcHJpbWFyeUtleS5leHRyYWN0S2V5LCBvdXRib3VuZCA9IHByaW1hcnlLZXkub3V0Ym91bmQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleGVzV2l0aEF1dG9JbmNQSyA9IHByaW1hcnlLZXkuYXV0b0luY3JlbWVudCAmJiBpbmRleGVzLmZpbHRlcihmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIGluZGV4LmNvbXBvdW5kICYmIGluZGV4LmtleVBhdGguaW5jbHVkZXMocHJpbWFyeUtleS5rZXlQYXRoKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZUNsb25lID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRhYmxlKSwgeyBtdXRhdGU6IGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnMgPSByZXEudHJhbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0ZWRQYXJ0cyA9IHJlcS5tdXRhdGVkUGFydHMgfHwgKHJlcS5tdXRhdGVkUGFydHMgPSB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdldFJhbmdlU2V0ID0gZnVuY3Rpb24gKGluZGV4TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydCA9IFwiaWRiOi8vXCIuY29uY2F0KGRiTmFtZSwgXCIvXCIpLmNvbmNhdCh0YWJsZU5hbWUsIFwiL1wiKS5jb25jYXQoaW5kZXhOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChtdXRhdGVkUGFydHNbcGFydF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtdXRhdGVkUGFydHNbcGFydF0gPSBuZXcgUmFuZ2VTZXQoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBrUmFuZ2VTZXQgPSBnZXRSYW5nZVNldChcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsc1JhbmdlU2V0ID0gZ2V0UmFuZ2VTZXQoXCI6ZGVsc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHJlcS50eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IHJlcS50eXBlID09PSBcImRlbGV0ZVJhbmdlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbcmVxLnJhbmdlXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJlcS50eXBlID09PSBcImRlbGV0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFtyZXEua2V5c11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVxLnZhbHVlcy5sZW5ndGggPCA1MFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gW2dldEVmZmVjdGl2ZUtleXMocHJpbWFyeUtleSwgcmVxKS5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7IHJldHVybiBpZDsgfSksIHJlcS52YWx1ZXNdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbXSwga2V5cyA9IF9hWzBdLCBuZXdPYmpzID0gX2FbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZENhY2hlID0gcmVxLnRyYW5zW1wiX2NhY2hlXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGtleXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkS2V5cyhrZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZE9ianMgPSB0eXBlID09PSAnZGVsZXRlJyB8fCBrZXlzLmxlbmd0aCA9PT0gbmV3T2Jqcy5sZW5ndGggPyBnZXRGcm9tVHJhbnNhY3Rpb25DYWNoZShrZXlzLCBvbGRDYWNoZSkgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9sZE9ianMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGRLZXlzKGtleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGRPYmpzIHx8IG5ld09ianMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrQWZmZWN0ZWRJbmRleGVzKGdldFJhbmdlU2V0LCBzY2hlbWEsIG9sZE9ianMsIG5ld09ianMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0geyBmcm9tOiBrZXlzLmxvd2VyLCB0bzoga2V5cy51cHBlciB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGQocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGQoRlVMTF9SQU5HRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGQoRlVMTF9SQU5HRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYS5pbmRleGVzLmZvckVhY2goZnVuY3Rpb24gKGlkeCkgeyByZXR1cm4gZ2V0UmFuZ2VTZXQoaWR4Lm5hbWUpLmFkZChGVUxMX1JBTkdFKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5tdXRhdGUocmVxKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleXMgJiYgKHJlcS50eXBlID09PSAnYWRkJyB8fCByZXEudHlwZSA9PT0gJ3B1dCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa1JhbmdlU2V0LmFkZEtleXMocmVzLnJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ZXNXaXRoQXV0b0luY1BLKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhlc1dpdGhBdXRvSW5jUEsuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHhWYWxzID0gcmVxLnZhbHVlcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGlkeC5leHRyYWN0S2V5KHYpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBrUG9zID0gaWR4LmtleVBhdGguZmluZEluZGV4KGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBwcm9wID09PSBwcmltYXJ5S2V5LmtleVBhdGg7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMucmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChwaykgeyByZXR1cm4gaWR4VmFsc1twa1Bvc10gPSBwazsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFJhbmdlU2V0KGlkeC5uYW1lKS5hZGRLZXlzKGlkeFZhbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zLm11dGF0ZWRQYXJ0cyA9IGV4dGVuZE9ic2VydmFiaWxpdHlTZXQodHJhbnMubXV0YXRlZFBhcnRzIHx8IHt9LCBtdXRhdGVkUGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdldFJhbmdlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9kID0gX2EucXVlcnksIGluZGV4ID0gX2QuaW5kZXgsIHJhbmdlID0gX2QucmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBSYW5nZVNldCgoX2IgPSByYW5nZS5sb3dlcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY29yZS5NSU5fS0VZLCAoX2MgPSByYW5nZS51cHBlcikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogY29yZS5NQVhfS0VZKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFkU3Vic2NyaWJlcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIChyZXEpIHsgcmV0dXJuIFtwcmltYXJ5S2V5LCBuZXcgUmFuZ2VTZXQocmVxLmtleSldOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TWFueTogZnVuY3Rpb24gKHJlcSkgeyByZXR1cm4gW3ByaW1hcnlLZXksIG5ldyBSYW5nZVNldCgpLmFkZEtleXMocmVxLmtleXMpXTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiBnZXRSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBnZXRSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5DdXJzb3I6IGdldFJhbmdlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBrZXlzKHJlYWRTdWJzY3JpYmVycykuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZUNsb25lW21ldGhvZF0gPSBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1YnNjciA9IFBTRC5zdWJzY3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzTGl2ZVF1ZXJ5ID0gISFzdWJzY3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hhYmxlID0gaXNDYWNoYWJsZUNvbnRleHQoUFNELCB0YWJsZSkgJiYgaXNDYWNoYWJsZVJlcXVlc3QobWV0aG9kLCByZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYnNTZXQgPSBjYWNoYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJlcS5vYnNTZXQgPSB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHN1YnNjcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNMaXZlUXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdldFJhbmdlU2V0ID0gZnVuY3Rpb24gKGluZGV4TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBcImlkYjovL1wiLmNvbmNhdChkYk5hbWUsIFwiL1wiKS5jb25jYXQodGFibGVOYW1lLCBcIi9cIikuY29uY2F0KGluZGV4TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG9ic1NldFtwYXJ0XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvYnNTZXRbcGFydF0gPSBuZXcgUmFuZ2VTZXQoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGtSYW5nZVNldF8xID0gZ2V0UmFuZ2VTZXQoXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxzUmFuZ2VTZXRfMSA9IGdldFJhbmdlU2V0KFwiOmRlbHNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IHJlYWRTdWJzY3JpYmVyc1ttZXRob2RdKHJlcSksIHF1ZXJpZWRJbmRleCA9IF9hWzBdLCBxdWVyaWVkUmFuZ2VzID0gX2FbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09ICdxdWVyeScgJiYgcXVlcmllZEluZGV4LmlzUHJpbWFyeUtleSAmJiAhcmVxLnZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0XzEuYWRkKHF1ZXJpZWRSYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0UmFuZ2VTZXQocXVlcmllZEluZGV4Lm5hbWUgfHwgXCJcIikuYWRkKHF1ZXJpZWRSYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcXVlcmllZEluZGV4LmlzUHJpbWFyeUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJjb3VudFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0XzEuYWRkKEZVTExfUkFOR0UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXNQcm9taXNlXzEgPSBtZXRob2QgPT09IFwicXVlcnlcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRib3VuZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEudmFsdWVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLnF1ZXJ5KF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXEpLCB7IHZhbHVlczogZmFsc2UgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZVttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicXVlcnlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dGJvdW5kICYmIHJlcS52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5c1Byb21pc2VfMS50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0aW5nS2V5cyA9IF9hLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldF8xLmFkZEtleXMocmVzdWx0aW5nS2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcEtleXMgPSByZXEudmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXMucmVzdWx0Lm1hcChleHRyYWN0S2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVzLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEudmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldF8xLmFkZEtleXMocEtleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0XzEuYWRkS2V5cyhwS2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWV0aG9kID09PSBcIm9wZW5DdXJzb3JcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvcl8xID0gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdhbnRWYWx1ZXNfMSA9IHJlcS52YWx1ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGN1cnNvcl8xICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShjdXJzb3JfMSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldF8xLmFkZEtleShjdXJzb3JfMS5wcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yXzEua2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBrZXkgPSBjdXJzb3JfMS5wcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldF8xLmFkZEtleShwa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YW50VmFsdWVzXzEgJiYgcGtSYW5nZVNldF8xLmFkZEtleShjdXJzb3JfMS5wcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZVttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlQ2xvbmU7XG4gICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHRyYWNrQWZmZWN0ZWRJbmRleGVzKGdldFJhbmdlU2V0LCBzY2hlbWEsIG9sZE9ianMsIG5ld09ianMpIHtcbiAgICAgICAgZnVuY3Rpb24gYWRkQWZmZWN0ZWRJbmRleChpeCkge1xuICAgICAgICAgICAgdmFyIHJhbmdlU2V0ID0gZ2V0UmFuZ2VTZXQoaXgubmFtZSB8fCBcIlwiKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGV4dHJhY3RLZXkob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAhPSBudWxsID8gaXguZXh0cmFjdEtleShvYmopIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhZGRLZXlPcktleXMgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBpeC5tdWx0aUVudHJ5ICYmIGlzQXJyYXkoa2V5KVxuICAgICAgICAgICAgICAgID8ga2V5LmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gcmFuZ2VTZXQuYWRkS2V5KGtleSk7IH0pXG4gICAgICAgICAgICAgICAgOiByYW5nZVNldC5hZGRLZXkoa2V5KTsgfTtcbiAgICAgICAgICAgIChvbGRPYmpzIHx8IG5ld09ianMpLmZvckVhY2goZnVuY3Rpb24gKF8sIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkS2V5ID0gb2xkT2JqcyAmJiBleHRyYWN0S2V5KG9sZE9ianNbaV0pO1xuICAgICAgICAgICAgICAgIHZhciBuZXdLZXkgPSBuZXdPYmpzICYmIGV4dHJhY3RLZXkobmV3T2Jqc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGNtcChvbGRLZXksIG5ld0tleSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZEtleSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkS2V5T3JLZXlzKG9sZEtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdLZXkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEtleU9yS2V5cyhuZXdLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNjaGVtYS5pbmRleGVzLmZvckVhY2goYWRkQWZmZWN0ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRqdXN0T3B0aW1pc3RpY0Zyb21GYWlsdXJlcyh0YmxDYWNoZSwgcmVxLCByZXMpIHtcbiAgICAgICAgaWYgKHJlcy5udW1GYWlsdXJlcyA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiByZXE7XG4gICAgICAgIGlmIChyZXEudHlwZSA9PT0gJ2RlbGV0ZVJhbmdlJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG51bUJ1bGtPcHMgPSByZXEua2V5c1xuICAgICAgICAgICAgPyByZXEua2V5cy5sZW5ndGhcbiAgICAgICAgICAgIDogJ3ZhbHVlcycgaW4gcmVxICYmIHJlcS52YWx1ZXNcbiAgICAgICAgICAgICAgICA/IHJlcS52YWx1ZXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgOiAxO1xuICAgICAgICBpZiAocmVzLm51bUZhaWx1cmVzID09PSBudW1CdWxrT3BzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xvbmUgPSBfX2Fzc2lnbih7fSwgcmVxKTtcbiAgICAgICAgaWYgKGlzQXJyYXkoY2xvbmUua2V5cykpIHtcbiAgICAgICAgICAgIGNsb25lLmtleXMgPSBjbG9uZS5rZXlzLmZpbHRlcihmdW5jdGlvbiAoXywgaSkgeyByZXR1cm4gIShpIGluIHJlcy5mYWlsdXJlcyk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICgndmFsdWVzJyBpbiBjbG9uZSAmJiBpc0FycmF5KGNsb25lLnZhbHVlcykpIHtcbiAgICAgICAgICAgIGNsb25lLnZhbHVlcyA9IGNsb25lLnZhbHVlcy5maWx0ZXIoZnVuY3Rpb24gKF8sIGkpIHsgcmV0dXJuICEoaSBpbiByZXMuZmFpbHVyZXMpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBYm92ZUxvd2VyKGtleSwgcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlLmxvd2VyID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgOiByYW5nZS5sb3dlck9wZW5cbiAgICAgICAgICAgICAgICA/IGNtcChrZXksIHJhbmdlLmxvd2VyKSA+IDBcbiAgICAgICAgICAgICAgICA6IGNtcChrZXksIHJhbmdlLmxvd2VyKSA+PSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0JlbG93VXBwZXIoa2V5LCByYW5nZSkge1xuICAgICAgICByZXR1cm4gcmFuZ2UudXBwZXIgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICA6IHJhbmdlLnVwcGVyT3BlblxuICAgICAgICAgICAgICAgID8gY21wKGtleSwgcmFuZ2UudXBwZXIpIDwgMFxuICAgICAgICAgICAgICAgIDogY21wKGtleSwgcmFuZ2UudXBwZXIpIDw9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzV2l0aGluUmFuZ2Uoa2V5LCByYW5nZSkge1xuICAgICAgICByZXR1cm4gaXNBYm92ZUxvd2VyKGtleSwgcmFuZ2UpICYmIGlzQmVsb3dVcHBlcihrZXksIHJhbmdlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseU9wdGltaXN0aWNPcHMocmVzdWx0LCByZXEsIG9wcywgdGFibGUsIGNhY2hlRW50cnksIGltbXV0YWJsZSkge1xuICAgICAgICBpZiAoIW9wcyB8fCBvcHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgdmFyIGluZGV4ID0gcmVxLnF1ZXJ5LmluZGV4O1xuICAgICAgICB2YXIgbXVsdGlFbnRyeSA9IGluZGV4Lm11bHRpRW50cnk7XG4gICAgICAgIHZhciBxdWVyeVJhbmdlID0gcmVxLnF1ZXJ5LnJhbmdlO1xuICAgICAgICB2YXIgcHJpbWFyeUtleSA9IHRhYmxlLnNjaGVtYS5wcmltYXJ5S2V5O1xuICAgICAgICB2YXIgZXh0cmFjdFByaW1LZXkgPSBwcmltYXJ5S2V5LmV4dHJhY3RLZXk7XG4gICAgICAgIHZhciBleHRyYWN0SW5kZXggPSBpbmRleC5leHRyYWN0S2V5O1xuICAgICAgICB2YXIgZXh0cmFjdExvd0xldmVsSW5kZXggPSAoaW5kZXgubG93TGV2ZWxJbmRleCB8fCBpbmRleCkuZXh0cmFjdEtleTtcbiAgICAgICAgdmFyIGZpbmFsUmVzdWx0ID0gb3BzLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBvcCkge1xuICAgICAgICAgICAgdmFyIG1vZGlmZWRSZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICB2YXIgaW5jbHVkZWRWYWx1ZXMgPSBvcC50eXBlID09PSAnYWRkJyB8fCBvcC50eXBlID09PSAncHV0J1xuICAgICAgICAgICAgICAgID8gb3AudmFsdWVzLmZpbHRlcihmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gZXh0cmFjdEluZGV4KHYpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXVsdGlFbnRyeSAmJiBpc0FycmF5KGtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8ga2V5LnNvbWUoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGlzV2l0aGluUmFuZ2UoaywgcXVlcnlSYW5nZSk7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGlzV2l0aGluUmFuZ2Uoa2V5LCBxdWVyeVJhbmdlKTtcbiAgICAgICAgICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IGRlZXBDbG9uZSh2KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltbXV0YWJsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUodik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FkZCc6XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmZWRSZXN1bHQgPSByZXN1bHQuY29uY2F0KHJlcS52YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gaW5jbHVkZWRWYWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaW5jbHVkZWRWYWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBleHRyYWN0UHJpbUtleSh2KTsgfSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdwdXQnOlxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5U2V0XzEgPSBuZXcgUmFuZ2VTZXQoKS5hZGRLZXlzKG9wLnZhbHVlcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGV4dHJhY3RQcmltS2V5KHYpOyB9KSk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmZWRSZXN1bHQgPSByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSByZXEudmFsdWVzID8gZXh0cmFjdFByaW1LZXkoaXRlbSkgOiBpdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFyYW5nZXNPdmVybGFwKG5ldyBSYW5nZVNldChrZXkpLCBrZXlTZXRfMSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHJlcS52YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gaW5jbHVkZWRWYWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaW5jbHVkZWRWYWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBleHRyYWN0UHJpbUtleSh2KTsgfSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5c1RvRGVsZXRlXzEgPSBuZXcgUmFuZ2VTZXQoKS5hZGRLZXlzKG9wLmtleXMpO1xuICAgICAgICAgICAgICAgICAgICBtb2RpZmVkUmVzdWx0ID0gcmVzdWx0LmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IHJlcS52YWx1ZXMgPyBleHRyYWN0UHJpbUtleShpdGVtKSA6IGl0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXJhbmdlc092ZXJsYXAobmV3IFJhbmdlU2V0KGtleSksIGtleXNUb0RlbGV0ZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZVJhbmdlJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlXzEgPSBvcC5yYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZlZFJlc3VsdCA9IHJlc3VsdC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuICFpc1dpdGhpblJhbmdlKGV4dHJhY3RQcmltS2V5KGl0ZW0pLCByYW5nZV8xKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vZGlmZWRSZXN1bHQ7XG4gICAgICAgIH0sIHJlc3VsdCk7XG4gICAgICAgIGlmIChmaW5hbFJlc3VsdCA9PT0gcmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgZmluYWxSZXN1bHQuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGNtcChleHRyYWN0TG93TGV2ZWxJbmRleChhKSwgZXh0cmFjdExvd0xldmVsSW5kZXgoYikpIHx8XG4gICAgICAgICAgICAgICAgY21wKGV4dHJhY3RQcmltS2V5KGEpLCBleHRyYWN0UHJpbUtleShiKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVxLmxpbWl0ICYmIHJlcS5saW1pdCA8IEluZmluaXR5KSB7XG4gICAgICAgICAgICBpZiAoZmluYWxSZXN1bHQubGVuZ3RoID4gcmVxLmxpbWl0KSB7XG4gICAgICAgICAgICAgICAgZmluYWxSZXN1bHQubGVuZ3RoID0gcmVxLmxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gcmVxLmxpbWl0ICYmIGZpbmFsUmVzdWx0Lmxlbmd0aCA8IHJlcS5saW1pdCkge1xuICAgICAgICAgICAgICAgIGNhY2hlRW50cnkuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbW11dGFibGUgPyBPYmplY3QuZnJlZXplKGZpbmFsUmVzdWx0KSA6IGZpbmFsUmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFyZVJhbmdlc0VxdWFsKHIxLCByMikge1xuICAgICAgICByZXR1cm4gKGNtcChyMS5sb3dlciwgcjIubG93ZXIpID09PSAwICYmXG4gICAgICAgICAgICBjbXAocjEudXBwZXIsIHIyLnVwcGVyKSA9PT0gMCAmJlxuICAgICAgICAgICAgISFyMS5sb3dlck9wZW4gPT09ICEhcjIubG93ZXJPcGVuICYmXG4gICAgICAgICAgICAhIXIxLnVwcGVyT3BlbiA9PT0gISFyMi51cHBlck9wZW4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXBhcmVMb3dlcnMobG93ZXIxLCBsb3dlcjIsIGxvd2VyT3BlbjEsIGxvd2VyT3BlbjIpIHtcbiAgICAgICAgaWYgKGxvd2VyMSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGxvd2VyMiAhPT0gdW5kZWZpbmVkID8gLTEgOiAwO1xuICAgICAgICBpZiAobG93ZXIyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgdmFyIGMgPSBjbXAobG93ZXIxLCBsb3dlcjIpO1xuICAgICAgICBpZiAoYyA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGxvd2VyT3BlbjEgJiYgbG93ZXJPcGVuMilcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGlmIChsb3dlck9wZW4xKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgaWYgKGxvd2VyT3BlbjIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wYXJlVXBwZXJzKHVwcGVyMSwgdXBwZXIyLCB1cHBlck9wZW4xLCB1cHBlck9wZW4yKSB7XG4gICAgICAgIGlmICh1cHBlcjEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB1cHBlcjIgIT09IHVuZGVmaW5lZCA/IDEgOiAwO1xuICAgICAgICBpZiAodXBwZXIyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIHZhciBjID0gY21wKHVwcGVyMSwgdXBwZXIyKTtcbiAgICAgICAgaWYgKGMgPT09IDApIHtcbiAgICAgICAgICAgIGlmICh1cHBlck9wZW4xICYmIHVwcGVyT3BlbjIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBpZiAodXBwZXJPcGVuMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBpZiAodXBwZXJPcGVuMilcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNTdXBlclJhbmdlKHIxLCByMikge1xuICAgICAgICByZXR1cm4gKGNvbXBhcmVMb3dlcnMocjEubG93ZXIsIHIyLmxvd2VyLCByMS5sb3dlck9wZW4sIHIyLmxvd2VyT3BlbikgPD0gMCAmJlxuICAgICAgICAgICAgY29tcGFyZVVwcGVycyhyMS51cHBlciwgcjIudXBwZXIsIHIxLnVwcGVyT3BlbiwgcjIudXBwZXJPcGVuKSA+PSAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kQ29tcGF0aWJsZVF1ZXJ5KGRiTmFtZSwgdGFibGVOYW1lLCB0eXBlLCByZXEpIHtcbiAgICAgICAgdmFyIHRibENhY2hlID0gY2FjaGVbXCJpZGI6Ly9cIi5jb25jYXQoZGJOYW1lLCBcIi9cIikuY29uY2F0KHRhYmxlTmFtZSldO1xuICAgICAgICBpZiAoIXRibENhY2hlKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB2YXIgcXVlcmllcyA9IHRibENhY2hlLnF1ZXJpZXNbdHlwZV07XG4gICAgICAgIGlmICghcXVlcmllcylcbiAgICAgICAgICAgIHJldHVybiBbbnVsbCwgZmFsc2UsIHRibENhY2hlLCBudWxsXTtcbiAgICAgICAgdmFyIGluZGV4TmFtZSA9IHJlcS5xdWVyeSA/IHJlcS5xdWVyeS5pbmRleC5uYW1lIDogbnVsbDtcbiAgICAgICAgdmFyIGVudHJpZXMgPSBxdWVyaWVzW2luZGV4TmFtZSB8fCAnJ107XG4gICAgICAgIGlmICghZW50cmllcylcbiAgICAgICAgICAgIHJldHVybiBbbnVsbCwgZmFsc2UsIHRibENhY2hlLCBudWxsXTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdxdWVyeSc6XG4gICAgICAgICAgICAgICAgdmFyIGVxdWFsRW50cnkgPSBlbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS5yZXEubGltaXQgPT09IHJlcS5saW1pdCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkucmVxLnZhbHVlcyA9PT0gcmVxLnZhbHVlcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYXJlUmFuZ2VzRXF1YWwoZW50cnkucmVxLnF1ZXJ5LnJhbmdlLCByZXEucXVlcnkucmFuZ2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChlcXVhbEVudHJ5KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgZXF1YWxFbnRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YmxDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXMsXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgdmFyIHN1cGVyRW50cnkgPSBlbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW1pdCA9ICdsaW1pdCcgaW4gZW50cnkucmVxID8gZW50cnkucmVxLmxpbWl0IDogSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobGltaXQgPj0gcmVxLmxpbWl0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAocmVxLnZhbHVlcyA/IGVudHJ5LnJlcS52YWx1ZXMgOiB0cnVlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTdXBlclJhbmdlKGVudHJ5LnJlcS5xdWVyeS5yYW5nZSwgcmVxLnF1ZXJ5LnJhbmdlKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzdXBlckVudHJ5LCBmYWxzZSwgdGJsQ2FjaGUsIGVudHJpZXNdO1xuICAgICAgICAgICAgY2FzZSAnY291bnQnOlxuICAgICAgICAgICAgICAgIHZhciBjb3VudFF1ZXJ5ID0gZW50cmllcy5maW5kKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJlUmFuZ2VzRXF1YWwoZW50cnkucmVxLnF1ZXJ5LnJhbmdlLCByZXEucXVlcnkucmFuZ2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbY291bnRRdWVyeSwgISFjb3VudFF1ZXJ5LCB0YmxDYWNoZSwgZW50cmllc107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdWJzY3JpYmVUb0NhY2hlRW50cnkoY2FjaGVFbnRyeSwgY29udGFpbmVyLCByZXF1ZXJ5LCBzaWduYWwpIHtcbiAgICAgICAgY2FjaGVFbnRyeS5zdWJzY3JpYmVycy5hZGQocmVxdWVyeSk7XG4gICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FjaGVFbnRyeS5zdWJzY3JpYmVycy5kZWxldGUocmVxdWVyeSk7XG4gICAgICAgICAgICBpZiAoY2FjaGVFbnRyeS5zdWJzY3JpYmVycy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZW5xdWVGb3JEZWxldGlvbihjYWNoZUVudHJ5LCBjb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5xdWVGb3JEZWxldGlvbihjYWNoZUVudHJ5LCBjb250YWluZXIpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoY2FjaGVFbnRyeS5zdWJzY3JpYmVycy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsQXJyYXlJdGVtKGNvbnRhaW5lciwgY2FjaGVFbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDMwMDApO1xuICAgIH1cblxuICAgIHZhciBjYWNoZU1pZGRsZXdhcmUgPSB7XG4gICAgICAgIHN0YWNrOiAnZGJjb3JlJyxcbiAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgIG5hbWU6ICdDYWNoZScsXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGNvcmUpIHtcbiAgICAgICAgICAgIHZhciBkYk5hbWUgPSBjb3JlLnNjaGVtYS5uYW1lO1xuICAgICAgICAgICAgdmFyIGNvcmVNVyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBjb3JlKSwgeyB0cmFuc2FjdGlvbjogZnVuY3Rpb24gKHN0b3JlcywgbW9kZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWRidHJhbnMgPSBjb3JlLnRyYW5zYWN0aW9uKHN0b3JlcywgbW9kZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSAncmVhZHdyaXRlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFjXzEgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2lnbmFsID0gYWNfMS5zaWduYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAod2FzQ29tbWl0dGVkKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNfMS5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSAncmVhZHdyaXRlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWZmZWN0ZWRTdWJzY3JpYmVyc18xID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHN0b3Jlc18xID0gc3RvcmVzOyBfaSA8IHN0b3Jlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlTmFtZSA9IHN0b3Jlc18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YmxDYWNoZSA9IGNhY2hlW1wiaWRiOi8vXCIuY29uY2F0KGRiTmFtZSwgXCIvXCIpLmNvbmNhdChzdG9yZU5hbWUpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YmxDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IGNvcmUudGFibGUoc3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3BzID0gdGJsQ2FjaGUub3B0aW1pc3RpY09wcy5maWx0ZXIoZnVuY3Rpb24gKG9wKSB7IHJldHVybiBvcC50cmFucyA9PT0gaWRidHJhbnM7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZGJ0cmFucy5fZXhwbGljaXQgJiYgd2FzQ29tbWl0dGVkICYmIGlkYnRyYW5zLm11dGF0ZWRQYXJ0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIF9iID0gT2JqZWN0LnZhbHVlcyh0YmxDYWNoZS5xdWVyaWVzLnF1ZXJ5KTsgX2EgPCBfYi5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyaWVzID0gX2JbX2FdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2MgPSAwLCBfZCA9IGVudHJpZXMuc2xpY2UoKTsgX2MgPCBfZC5sZW5ndGg7IF9jKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBfZFtfY107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ic1NldHNPdmVybGFwKGVudHJ5Lm9ic1NldCwgaWRidHJhbnMubXV0YXRlZFBhcnRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxBcnJheUl0ZW0oZW50cmllcywgZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXJ5KSB7IHJldHVybiBhZmZlY3RlZFN1YnNjcmliZXJzXzEuYWRkKHJlcXVlcnkpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGJsQ2FjaGUub3B0aW1pc3RpY09wcyA9IHRibENhY2hlLm9wdGltaXN0aWNPcHMuZmlsdGVyKGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gb3AudHJhbnMgIT09IGlkYnRyYW5zOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2UgPSAwLCBfZiA9IE9iamVjdC52YWx1ZXModGJsQ2FjaGUucXVlcmllcy5xdWVyeSk7IF9lIDwgX2YubGVuZ3RoOyBfZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW50cmllcyA9IF9mW19lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9nID0gMCwgX2ggPSBlbnRyaWVzLnNsaWNlKCk7IF9nIDwgX2gubGVuZ3RoOyBfZysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2hbX2ddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5yZXMgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGJ0cmFucy5tdXRhdGVkUGFydHNcbiAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdhc0NvbW1pdHRlZCAmJiAhZW50cnkuZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmVlemVSZXN1bHRzID0gT2JqZWN0LmlzRnJvemVuKGVudHJ5LnJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kUmVzID0gYXBwbHlPcHRpbWlzdGljT3BzKGVudHJ5LnJlcywgZW50cnkucmVxLCBvcHMsIHRhYmxlLCBlbnRyeSwgZnJlZXplUmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxBcnJheUl0ZW0oZW50cmllcywgZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlcnkpIHsgcmV0dXJuIGFmZmVjdGVkU3Vic2NyaWJlcnNfMS5hZGQocmVxdWVyeSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobW9kUmVzICE9PSBlbnRyeS5yZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5yZXMgPSBtb2RSZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkucHJvbWlzZSA9IERleGllUHJvbWlzZS5yZXNvbHZlKHsgcmVzdWx0OiBtb2RSZXMgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxBcnJheUl0ZW0oZW50cmllcywgZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkuc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVyeSkgeyByZXR1cm4gYWZmZWN0ZWRTdWJzY3JpYmVyc18xLmFkZChyZXF1ZXJ5KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRTdWJzY3JpYmVyc18xLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlcnkpIHsgcmV0dXJuIHJlcXVlcnkoKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkYnRyYW5zLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZW5kVHJhbnNhY3Rpb24oZmFsc2UpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBzaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkYnRyYW5zLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZW5kVHJhbnNhY3Rpb24oZmFsc2UpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBzaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkYnRyYW5zLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgZW5kVHJhbnNhY3Rpb24odHJ1ZSksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IHNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZGJ0cmFucztcbiAgICAgICAgICAgICAgICB9LCB0YWJsZTogZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG93blRhYmxlID0gY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJpbUtleSA9IGRvd25UYWJsZS5zY2hlbWEucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlTVcgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZG93blRhYmxlKSwgeyBtdXRhdGU6IGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnMgPSBQU0QudHJhbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByaW1LZXkub3V0Ym91bmQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnMuZGIuX29wdGlvbnMuY2FjaGUgPT09ICdkaXNhYmxlZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnMuZXhwbGljaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvd25UYWJsZS5tdXRhdGUocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRibENhY2hlID0gY2FjaGVbXCJpZGI6Ly9cIi5jb25jYXQoZGJOYW1lLCBcIi9cIikuY29uY2F0KHRhYmxlTmFtZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGJsQ2FjaGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUubXV0YXRlKHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBkb3duVGFibGUubXV0YXRlKHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyZXEudHlwZSA9PT0gJ2FkZCcgfHwgcmVxLnR5cGUgPT09ICdwdXQnKSAmJiAocmVxLnZhbHVlcy5sZW5ndGggPj0gNTAgfHwgZ2V0RWZmZWN0aXZlS2V5cyhwcmltS2V5LCByZXEpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5ID09IG51bGw7IH0pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcVdpdGhSZXNvbHZlZEtleXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVxKSwgeyB2YWx1ZXM6IHJlcS52YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZVdpdGhLZXkgPSAoKF9hID0gcHJpbUtleS5rZXlQYXRoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoJy4nKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZGVlcENsb25lKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBfX2Fzc2lnbih7fSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgodmFsdWVXaXRoS2V5LCBwcmltS2V5LmtleVBhdGgsIHJlcy5yZXN1bHRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlV2l0aEtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGp1c3RlZFJlcSA9IGFkanVzdE9wdGltaXN0aWNGcm9tRmFpbHVyZXModGJsQ2FjaGUsIHJlcVdpdGhSZXNvbHZlZEtleXMsIHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YmxDYWNoZS5vcHRpbWlzdGljT3BzLnB1c2goYWRqdXN0ZWRSZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxLm11dGF0ZWRQYXJ0cyAmJiBzaWduYWxTdWJzY3JpYmVyc0xhemlseShyZXEubXV0YXRlZFBhcnRzKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGJsQ2FjaGUub3B0aW1pc3RpY09wcy5wdXNoKHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5tdXRhdGVkUGFydHMgJiYgc2lnbmFsU3Vic2NyaWJlcnNMYXppbHkocmVxLm11dGF0ZWRQYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzLm51bUZhaWx1cmVzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbEFycmF5SXRlbSh0YmxDYWNoZS5vcHRpbWlzdGljT3BzLCByZXEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGp1c3RlZFJlcSA9IGFkanVzdE9wdGltaXN0aWNGcm9tRmFpbHVyZXModGJsQ2FjaGUsIHJlcSwgcmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRqdXN0ZWRSZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGJsQ2FjaGUub3B0aW1pc3RpY09wcy5wdXNoKGFkanVzdGVkUmVxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm11dGF0ZWRQYXJ0cyAmJiBzaWduYWxTdWJzY3JpYmVyc0xhemlseShyZXEubXV0YXRlZFBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsQXJyYXlJdGVtKHRibENhY2hlLm9wdGltaXN0aWNPcHMsIHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEubXV0YXRlZFBhcnRzICYmIHNpZ25hbFN1YnNjcmliZXJzTGF6aWx5KHJlcS5tdXRhdGVkUGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBxdWVyeTogZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ2FjaGFibGVDb250ZXh0KFBTRCwgZG93blRhYmxlKSB8fCAhaXNDYWNoYWJsZVJlcXVlc3QoXCJxdWVyeVwiLCByZXEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG93blRhYmxlLnF1ZXJ5KHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyZWV6ZVJlc3VsdHMgPSAoKF9hID0gUFNELnRyYW5zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGIuX29wdGlvbnMuY2FjaGUpID09PSAnaW1tdXRhYmxlJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBQU0QsIHJlcXVlcnkgPSBfYi5yZXF1ZXJ5LCBzaWduYWwgPSBfYi5zaWduYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jID0gZmluZENvbXBhdGlibGVRdWVyeShkYk5hbWUsIHRhYmxlTmFtZSwgJ3F1ZXJ5JywgcmVxKSwgY2FjaGVFbnRyeSA9IF9jWzBdLCBleGFjdE1hdGNoID0gX2NbMV0sIHRibENhY2hlID0gX2NbMl0sIGNvbnRhaW5lciA9IF9jWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZUVudHJ5ICYmIGV4YWN0TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVFbnRyeS5vYnNTZXQgPSByZXEub2JzU2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBkb3duVGFibGUucXVlcnkocmVxKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlRW50cnkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVFbnRyeS5yZXMgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJlZXplUmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcmVzdWx0Lmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKHJlc3VsdFtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5yZXN1bHQgPSBkZWVwQ2xvbmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lciAmJiBjYWNoZUVudHJ5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbEFycmF5SXRlbShjb250YWluZXIsIGNhY2hlRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlRW50cnkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNTZXQ6IHJlcS5vYnNTZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlOiBwcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlcnM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdxdWVyeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXE6IHJlcSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcnR5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnB1c2goY2FjaGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIgPSBbY2FjaGVFbnRyeV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRibENhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGJsQ2FjaGUgPSBjYWNoZVtcImlkYjovL1wiLmNvbmNhdChkYk5hbWUsIFwiL1wiKS5jb25jYXQodGFibGVOYW1lKV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqczogbmV3IE1hcCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpbWlzdGljT3BzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5zaWduYWxlZFBhcnRzOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YmxDYWNoZS5xdWVyaWVzLnF1ZXJ5W3JlcS5xdWVyeS5pbmRleC5uYW1lIHx8ICcnXSA9IGNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVUb0NhY2hlRW50cnkoY2FjaGVFbnRyeSwgY29udGFpbmVyLCByZXF1ZXJ5LCBzaWduYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZUVudHJ5LnByb21pc2UudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGFwcGx5T3B0aW1pc3RpY09wcyhyZXMucmVzdWx0LCByZXEsIHRibENhY2hlID09PSBudWxsIHx8IHRibENhY2hlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YmxDYWNoZS5vcHRpbWlzdGljT3BzLCBkb3duVGFibGUsIGNhY2hlRW50cnksIGZyZWV6ZVJlc3VsdHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlTVc7XG4gICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb3JlTVc7XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHZpcGlmeSh0YXJnZXQsIHZpcERiKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkodGFyZ2V0LCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICdkYicpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXBEYjtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBEZXhpZSQxID0gIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERleGllKG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9taWRkbGV3YXJlcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy52ZXJubyA9IDA7XG4gICAgICAgICAgICB2YXIgZGVwcyA9IERleGllLmRlcGVuZGVuY2llcztcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zID0gX19hc3NpZ24oe1xuICAgICAgICAgICAgICAgIGFkZG9uczogRGV4aWUuYWRkb25zLCBhdXRvT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbmRleGVkREI6IGRlcHMuaW5kZXhlZERCLCBJREJLZXlSYW5nZTogZGVwcy5JREJLZXlSYW5nZSwgY2FjaGU6ICdjbG9uZWQnIH0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5fZGVwcyA9IHtcbiAgICAgICAgICAgICAgICBpbmRleGVkREI6IG9wdGlvbnMuaW5kZXhlZERCLFxuICAgICAgICAgICAgICAgIElEQktleVJhbmdlOiBvcHRpb25zLklEQktleVJhbmdlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGFkZG9ucyA9IG9wdGlvbnMuYWRkb25zO1xuICAgICAgICAgICAgdGhpcy5fZGJTY2hlbWEgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX3ZlcnNpb25zID0gW107XG4gICAgICAgICAgICB0aGlzLl9zdG9yZU5hbWVzID0gW107XG4gICAgICAgICAgICB0aGlzLl9hbGxUYWJsZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuaWRiZGIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbm92aXAgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgIGRiT3BlbkVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIGlzQmVpbmdPcGVuZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG9uUmVhZHlCZWluZ0ZpcmVkOiBudWxsLFxuICAgICAgICAgICAgICAgIG9wZW5Db21wbGV0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGJSZWFkeVJlc29sdmU6IG5vcCxcbiAgICAgICAgICAgICAgICBkYlJlYWR5UHJvbWlzZTogbnVsbCxcbiAgICAgICAgICAgICAgICBjYW5jZWxPcGVuOiBub3AsXG4gICAgICAgICAgICAgICAgb3BlbkNhbmNlbGxlcjogbnVsbCxcbiAgICAgICAgICAgICAgICBhdXRvU2NoZW1hOiB0cnVlLFxuICAgICAgICAgICAgICAgIFBSMTM5OF9tYXhMb29wOiAzLFxuICAgICAgICAgICAgICAgIGF1dG9PcGVuOiBvcHRpb25zLmF1dG9PcGVuLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHN0YXRlLmRiUmVhZHlQcm9taXNlID0gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmRiUmVhZHlSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdGUub3BlbkNhbmNlbGxlciA9IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKF8sIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmNhbmNlbE9wZW4gPSByZWplY3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5vbiA9IEV2ZW50cyh0aGlzLCBcInBvcHVsYXRlXCIsIFwiYmxvY2tlZFwiLCBcInZlcnNpb25jaGFuZ2VcIiwgXCJjbG9zZVwiLCB7IHJlYWR5OiBbcHJvbWlzYWJsZUNoYWluLCBub3BdIH0pO1xuICAgICAgICAgICAgdGhpcy5vbi5yZWFkeS5zdWJzY3JpYmUgPSBvdmVycmlkZSh0aGlzLm9uLnJlYWR5LnN1YnNjcmliZSwgZnVuY3Rpb24gKHN1YnNjcmliZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3Vic2NyaWJlciwgYlN0aWNreSkge1xuICAgICAgICAgICAgICAgICAgICBEZXhpZS52aXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gX3RoaXMuX3N0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLm9wZW5Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUuZGJPcGVuRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERleGllUHJvbWlzZS5yZXNvbHZlKCkudGhlbihzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYlN0aWNreSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUub25SZWFkeUJlaW5nRmlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZC5wdXNoKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiU3RpY2t5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRiXzEgPSBfdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJTdGlja3kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZShmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiXzEub24ucmVhZHkudW5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYl8xLm9uLnJlYWR5LnVuc3Vic2NyaWJlKHVuc3Vic2NyaWJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuQ29sbGVjdGlvbiA9IGNyZWF0ZUNvbGxlY3Rpb25Db25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuVGFibGUgPSBjcmVhdGVUYWJsZUNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5UcmFuc2FjdGlvbiA9IGNyZWF0ZVRyYW5zYWN0aW9uQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgICAgICB0aGlzLlZlcnNpb24gPSBjcmVhdGVWZXJzaW9uQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgICAgICB0aGlzLldoZXJlQ2xhdXNlID0gY3JlYXRlV2hlcmVDbGF1c2VDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub24oXCJ2ZXJzaW9uY2hhbmdlXCIsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgIGlmIChldi5uZXdWZXJzaW9uID4gMClcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQW5vdGhlciBjb25uZWN0aW9uIHdhbnRzIHRvIHVwZ3JhZGUgZGF0YWJhc2UgJ1wiLmNvbmNhdChfdGhpcy5uYW1lLCBcIicuIENsb3NpbmcgZGIgbm93IHRvIHJlc3VtZSB0aGUgdXBncmFkZS5cIikpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQW5vdGhlciBjb25uZWN0aW9uIHdhbnRzIHRvIGRlbGV0ZSBkYXRhYmFzZSAnXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiJy4gQ2xvc2luZyBkYiBub3cgdG8gcmVzdW1lIHRoZSBkZWxldGUgcmVxdWVzdC5cIikpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlKHsgZGlzYWJsZUF1dG9PcGVuOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5vbihcImJsb2NrZWRcIiwgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFldi5uZXdWZXJzaW9uIHx8IGV2Lm5ld1ZlcnNpb24gPCBldi5vbGRWZXJzaW9uKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJEZXhpZS5kZWxldGUoJ1wiLmNvbmNhdChfdGhpcy5uYW1lLCBcIicpIHdhcyBibG9ja2VkXCIpKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVwZ3JhZGUgJ1wiLmNvbmNhdChfdGhpcy5uYW1lLCBcIicgYmxvY2tlZCBieSBvdGhlciBjb25uZWN0aW9uIGhvbGRpbmcgdmVyc2lvbiBcIikuY29uY2F0KGV2Lm9sZFZlcnNpb24gLyAxMCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9tYXhLZXkgPSBnZXRNYXhLZXkob3B0aW9ucy5JREJLZXlSYW5nZSk7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uIChtb2RlLCBzdG9yZU5hbWVzLCBkYnNjaGVtYSwgcGFyZW50VHJhbnNhY3Rpb24pIHsgcmV0dXJuIG5ldyBfdGhpcy5UcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYnNjaGVtYSwgX3RoaXMuX29wdGlvbnMuY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5LCBwYXJlbnRUcmFuc2FjdGlvbik7IH07XG4gICAgICAgICAgICB0aGlzLl9maXJlT25CbG9ja2VkID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub24oXCJibG9ja2VkXCIpLmZpcmUoZXYpO1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMubmFtZSA9PT0gX3RoaXMubmFtZSAmJiBjICE9PSBfdGhpcyAmJiAhYy5fc3RhdGUudmNGaXJlZDsgfSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5vbihcInZlcnNpb25jaGFuZ2VcIikuZmlyZShldik7IH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudXNlKGNhY2hlRXhpc3RpbmdWYWx1ZXNNaWRkbGV3YXJlKTtcbiAgICAgICAgICAgIHRoaXMudXNlKGNhY2hlTWlkZGxld2FyZSk7XG4gICAgICAgICAgICB0aGlzLnVzZShvYnNlcnZhYmlsaXR5TWlkZGxld2FyZSk7XG4gICAgICAgICAgICB0aGlzLnVzZSh2aXJ0dWFsSW5kZXhNaWRkbGV3YXJlKTtcbiAgICAgICAgICAgIHRoaXMudXNlKGhvb2tzTWlkZGxld2FyZSk7XG4gICAgICAgICAgICB2YXIgdmlwREIgPSBuZXcgUHJveHkodGhpcywge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKF8sIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSAnX3ZpcCcpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICd0YWJsZScpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhYmxlTmFtZSkgeyByZXR1cm4gdmlwaWZ5KF90aGlzLnRhYmxlKHRhYmxlTmFtZSksIHZpcERCKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ2ID0gUmVmbGVjdC5nZXQoXywgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocnYgaW5zdGFuY2VvZiBUYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXBpZnkocnYsIHZpcERCKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICd0YWJsZXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ2Lm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdmlwaWZ5KHQsIHZpcERCKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSAnX2NyZWF0ZVRyYW5zYWN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR4ID0gcnYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlwaWZ5KHR4LCB2aXBEQik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnZpcCA9IHZpcERCO1xuICAgICAgICAgICAgYWRkb25zLmZvckVhY2goZnVuY3Rpb24gKGFkZG9uKSB7IHJldHVybiBhZGRvbihfdGhpcyk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIERleGllLnByb3RvdHlwZS52ZXJzaW9uID0gZnVuY3Rpb24gKHZlcnNpb25OdW1iZXIpIHtcbiAgICAgICAgICAgIGlmIChpc05hTih2ZXJzaW9uTnVtYmVyKSB8fCB2ZXJzaW9uTnVtYmVyIDwgMC4xKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlR5cGUoXCJHaXZlbiB2ZXJzaW9uIGlzIG5vdCBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICAgICAgICAgIHZlcnNpb25OdW1iZXIgPSBNYXRoLnJvdW5kKHZlcnNpb25OdW1iZXIgKiAxMCkgLyAxMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkYmRiIHx8IHRoaXMuX3N0YXRlLmlzQmVpbmdPcGVuZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiQ2Fubm90IGFkZCB2ZXJzaW9uIHdoZW4gZGF0YWJhc2UgaXMgb3BlblwiKTtcbiAgICAgICAgICAgIHRoaXMudmVybm8gPSBNYXRoLm1heCh0aGlzLnZlcm5vLCB2ZXJzaW9uTnVtYmVyKTtcbiAgICAgICAgICAgIHZhciB2ZXJzaW9ucyA9IHRoaXMuX3ZlcnNpb25zO1xuICAgICAgICAgICAgdmFyIHZlcnNpb25JbnN0YW5jZSA9IHZlcnNpb25zLmZpbHRlcihmdW5jdGlvbiAodikgeyByZXR1cm4gdi5fY2ZnLnZlcnNpb24gPT09IHZlcnNpb25OdW1iZXI7IH0pWzBdO1xuICAgICAgICAgICAgaWYgKHZlcnNpb25JbnN0YW5jZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvbkluc3RhbmNlO1xuICAgICAgICAgICAgdmVyc2lvbkluc3RhbmNlID0gbmV3IHRoaXMuVmVyc2lvbih2ZXJzaW9uTnVtYmVyKTtcbiAgICAgICAgICAgIHZlcnNpb25zLnB1c2godmVyc2lvbkluc3RhbmNlKTtcbiAgICAgICAgICAgIHZlcnNpb25zLnNvcnQobG93ZXJWZXJzaW9uRmlyc3QpO1xuICAgICAgICAgICAgdmVyc2lvbkluc3RhbmNlLnN0b3Jlcyh7fSk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZS5hdXRvU2NoZW1hID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdmVyc2lvbkluc3RhbmNlO1xuICAgICAgICB9O1xuICAgICAgICBEZXhpZS5wcm90b3R5cGUuX3doZW5SZWFkeSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5pZGJkYiAmJiAodGhpcy5fc3RhdGUub3BlbkNvbXBsZXRlIHx8IFBTRC5sZXRUaHJvdWdoIHx8IHRoaXMuX3ZpcCkpID8gZm4oKSA6IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fc3RhdGUub3BlbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoX3RoaXMuX3N0YXRlLmRiT3BlbkVycm9yKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX3N0YXRlLmlzQmVpbmdPcGVuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fc3RhdGUuYXV0b09wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vcGVuKCkuY2F0Y2gobm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuX3N0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pLnRoZW4oZm4pO1xuICAgICAgICB9O1xuICAgICAgICBEZXhpZS5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBfYS5zdGFjaywgY3JlYXRlID0gX2EuY3JlYXRlLCBsZXZlbCA9IF9hLmxldmVsLCBuYW1lID0gX2EubmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lKVxuICAgICAgICAgICAgICAgIHRoaXMudW51c2UoeyBzdGFjazogc3RhY2ssIG5hbWU6IG5hbWUgfSk7XG4gICAgICAgICAgICB2YXIgbWlkZGxld2FyZXMgPSB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10gfHwgKHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXSA9IFtdKTtcbiAgICAgICAgICAgIG1pZGRsZXdhcmVzLnB1c2goeyBzdGFjazogc3RhY2ssIGNyZWF0ZTogY3JlYXRlLCBsZXZlbDogbGV2ZWwgPT0gbnVsbCA/IDEwIDogbGV2ZWwsIG5hbWU6IG5hbWUgfSk7XG4gICAgICAgICAgICBtaWRkbGV3YXJlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmxldmVsIC0gYi5sZXZlbDsgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgRGV4aWUucHJvdG90eXBlLnVudXNlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBfYS5zdGFjaywgbmFtZSA9IF9hLm5hbWUsIGNyZWF0ZSA9IF9hLmNyZWF0ZTtcbiAgICAgICAgICAgIGlmIChzdGFjayAmJiB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10gPSB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10uZmlsdGVyKGZ1bmN0aW9uIChtdykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlID8gbXcuY3JlYXRlICE9PSBjcmVhdGUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA/IG13Lm5hbWUgIT09IG5hbWUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIERleGllLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB1c2VQU0QoZ2xvYmFsUFNELFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gZGV4aWVPcGVuKF90aGlzKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIERleGllLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgICAgIHZhciBpZHggPSBjb25uZWN0aW9ucy5pbmRleE9mKHRoaXMpO1xuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKVxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRiZGIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlkYmRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgICAgICB0aGlzLmlkYmRiID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RhdGUuaXNCZWluZ09wZW5lZCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmRiUmVhZHlQcm9taXNlID0gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5kYlJlYWR5UmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdGUub3BlbkNhbmNlbGxlciA9IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKF8sIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jYW5jZWxPcGVuID0gcmVqZWN0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZXhpZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7IGRpc2FibGVBdXRvT3BlbjogdHJ1ZSB9IDogX2EsIGRpc2FibGVBdXRvT3BlbiA9IF9iLmRpc2FibGVBdXRvT3BlbjtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICAgICAgaWYgKGRpc2FibGVBdXRvT3Blbikge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmNhbmNlbE9wZW4obmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlKCk7XG4gICAgICAgICAgICAgICAgc3RhdGUuYXV0b09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5kYk9wZW5FcnJvciA9IG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmF1dG9PcGVuID0gdGhpcy5fb3B0aW9ucy5hdXRvT3BlbiB8fFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc0JlaW5nT3BlbmVkO1xuICAgICAgICAgICAgICAgIHN0YXRlLm9wZW5Db21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0YXRlLmRiT3BlbkVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGV4aWUucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChjbG9zZU9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoY2xvc2VPcHRpb25zID09PSB2b2lkIDApIHsgY2xvc2VPcHRpb25zID0geyBkaXNhYmxlQXV0b09wZW46IHRydWUgfTsgfVxuICAgICAgICAgICAgdmFyIGhhc0ludmFsaWRBcmd1bWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnb2JqZWN0JztcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBkb0RlbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoY2xvc2VPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IF90aGlzLl9kZXBzLmluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShfdGhpcy5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX29uRGF0YWJhc2VEZWxldGVkKF90aGlzLl9kZXBzLCBfdGhpcy5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmJsb2NrZWQgPSBfdGhpcy5fZmlyZU9uQmxvY2tlZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChoYXNJbnZhbGlkQXJndW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJJbnZhbGlkIGNsb3NlT3B0aW9ucyBhcmd1bWVudCB0byBkYi5kZWxldGUoKVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaXNCZWluZ09wZW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5kYlJlYWR5UHJvbWlzZS50aGVuKGRvRGVsZXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRvRGVsZXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIERleGllLnByb3RvdHlwZS5iYWNrZW5kREIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pZGJkYjtcbiAgICAgICAgfTtcbiAgICAgICAgRGV4aWUucHJvdG90eXBlLmlzT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkYmRiICE9PSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBEZXhpZS5wcm90b3R5cGUuaGFzQmVlbkNsb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYk9wZW5FcnJvciA9IHRoaXMuX3N0YXRlLmRiT3BlbkVycm9yO1xuICAgICAgICAgICAgcmV0dXJuIGRiT3BlbkVycm9yICYmIChkYk9wZW5FcnJvci5uYW1lID09PSAnRGF0YWJhc2VDbG9zZWQnKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGV4aWUucHJvdG90eXBlLmhhc0ZhaWxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5kYk9wZW5FcnJvciAhPT0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgRGV4aWUucHJvdG90eXBlLmR5bmFtaWNhbGx5T3BlbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmF1dG9TY2hlbWE7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZXhpZS5wcm90b3R5cGUsIFwidGFibGVzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXModGhpcy5fYWxsVGFibGVzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIF90aGlzLl9hbGxUYWJsZXNbbmFtZV07IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBEZXhpZS5wcm90b3R5cGUudHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IGV4dHJhY3RUcmFuc2FjdGlvbkFyZ3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGV4aWUucHJvdG90eXBlLl90cmFuc2FjdGlvbiA9IGZ1bmN0aW9uIChtb2RlLCB0YWJsZXMsIHNjb3BlRnVuYykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBwYXJlbnRUcmFuc2FjdGlvbiA9IFBTRC50cmFucztcbiAgICAgICAgICAgIGlmICghcGFyZW50VHJhbnNhY3Rpb24gfHwgcGFyZW50VHJhbnNhY3Rpb24uZGIgIT09IHRoaXMgfHwgbW9kZS5pbmRleE9mKCchJykgIT09IC0xKVxuICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBvbmx5SWZDb21wYXRpYmxlID0gbW9kZS5pbmRleE9mKCc/JykgIT09IC0xO1xuICAgICAgICAgICAgbW9kZSA9IG1vZGUucmVwbGFjZSgnIScsICcnKS5yZXBsYWNlKCc/JywgJycpO1xuICAgICAgICAgICAgdmFyIGlkYk1vZGUsIHN0b3JlTmFtZXM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0b3JlTmFtZXMgPSB0YWJsZXMubWFwKGZ1bmN0aW9uICh0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmVOYW1lID0gdGFibGUgaW5zdGFuY2VvZiBfdGhpcy5UYWJsZSA/IHRhYmxlLm5hbWUgOiB0YWJsZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZU5hbWUgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgdGFibGUgYXJndW1lbnQgdG8gRGV4aWUudHJhbnNhY3Rpb24oKS4gT25seSBUYWJsZSBvciBTdHJpbmcgYXJlIGFsbG93ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZU5hbWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgPT0gXCJyXCIgfHwgbW9kZSA9PT0gUkVBRE9OTFkpXG4gICAgICAgICAgICAgICAgICAgIGlkYk1vZGUgPSBSRUFET05MWTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtb2RlID09IFwicndcIiB8fCBtb2RlID09IFJFQURXUklURSlcbiAgICAgICAgICAgICAgICAgICAgaWRiTW9kZSA9IFJFQURXUklURTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkludmFsaWQgdHJhbnNhY3Rpb24gbW9kZTogXCIgKyBtb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uLm1vZGUgPT09IFJFQURPTkxZICYmIGlkYk1vZGUgPT09IFJFQURXUklURSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ubHlJZkNvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU3ViVHJhbnNhY3Rpb24oXCJDYW5ub3QgZW50ZXIgYSBzdWItdHJhbnNhY3Rpb24gd2l0aCBSRUFEV1JJVEUgbW9kZSB3aGVuIHBhcmVudCB0cmFuc2FjdGlvbiBpcyBSRUFET05MWVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RvcmVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uICYmIHBhcmVudFRyYW5zYWN0aW9uLnN0b3JlTmFtZXMuaW5kZXhPZihzdG9yZU5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob25seUlmQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlN1YlRyYW5zYWN0aW9uKFwiVGFibGUgXCIgKyBzdG9yZU5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIG5vdCBpbmNsdWRlZCBpbiBwYXJlbnQgdHJhbnNhY3Rpb24uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbmx5SWZDb21wYXRpYmxlICYmIHBhcmVudFRyYW5zYWN0aW9uICYmICFwYXJlbnRUcmFuc2FjdGlvbi5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudFRyYW5zYWN0aW9uID9cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24uX3Byb21pc2UobnVsbCwgZnVuY3Rpb24gKF8sIHJlamVjdCkgeyByZWplY3QoZSk7IH0pIDpcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0aW9uKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVudGVyVHJhbnNhY3Rpb24gPSBlbnRlclRyYW5zYWN0aW9uU2NvcGUuYmluZChudWxsLCB0aGlzLCBpZGJNb2RlLCBzdG9yZU5hbWVzLCBwYXJlbnRUcmFuc2FjdGlvbiwgc2NvcGVGdW5jKTtcbiAgICAgICAgICAgIHJldHVybiAocGFyZW50VHJhbnNhY3Rpb24gP1xuICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uLl9wcm9taXNlKGlkYk1vZGUsIGVudGVyVHJhbnNhY3Rpb24sIFwibG9ja1wiKSA6XG4gICAgICAgICAgICAgICAgUFNELnRyYW5zID9cbiAgICAgICAgICAgICAgICAgICAgdXNlUFNEKFBTRC50cmFuc2xlc3MsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl93aGVuUmVhZHkoZW50ZXJUcmFuc2FjdGlvbik7IH0pIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2hlblJlYWR5KGVudGVyVHJhbnNhY3Rpb24pKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGV4aWUucHJvdG90eXBlLnRhYmxlID0gZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd24odGhpcy5fYWxsVGFibGVzLCB0YWJsZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZFRhYmxlKFwiVGFibGUgXCIuY29uY2F0KHRhYmxlTmFtZSwgXCIgZG9lcyBub3QgZXhpc3RcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FsbFRhYmxlc1t0YWJsZU5hbWVdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRGV4aWU7XG4gICAgfSgpKTtcblxuICAgIHZhciBzeW1ib2xPYnNlcnZhYmxlID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIm9ic2VydmFibGVcIiBpbiBTeW1ib2xcbiAgICAgICAgPyBTeW1ib2wub2JzZXJ2YWJsZVxuICAgICAgICA6IFwiQEBvYnNlcnZhYmxlXCI7XG4gICAgdmFyIE9ic2VydmFibGUgPSAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gT2JzZXJ2YWJsZShzdWJzY3JpYmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICAgICAgfVxuICAgICAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoeCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaWJlKCF4IHx8IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB7IG5leHQ6IHgsIGVycm9yOiBlcnJvciwgY29tcGxldGU6IGNvbXBsZXRlIH0gOiB4KTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JzZXJ2YWJsZS5wcm90b3R5cGVbc3ltYm9sT2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGU7XG4gICAgfSgpKTtcblxuICAgIHZhciBkb21EZXBzO1xuICAgIHRyeSB7XG4gICAgICAgIGRvbURlcHMgPSB7XG4gICAgICAgICAgICBpbmRleGVkREI6IF9nbG9iYWwuaW5kZXhlZERCIHx8IF9nbG9iYWwubW96SW5kZXhlZERCIHx8IF9nbG9iYWwud2Via2l0SW5kZXhlZERCIHx8IF9nbG9iYWwubXNJbmRleGVkREIsXG4gICAgICAgICAgICBJREJLZXlSYW5nZTogX2dsb2JhbC5JREJLZXlSYW5nZSB8fCBfZ2xvYmFsLndlYmtpdElEQktleVJhbmdlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGRvbURlcHMgPSB7IGluZGV4ZWREQjogbnVsbCwgSURCS2V5UmFuZ2U6IG51bGwgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXZlUXVlcnkocXVlcmllcikge1xuICAgICAgICB2YXIgaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHZhciBzY29wZUZ1bmNJc0FzeW5jID0gaXNBc3luY0Z1bmN0aW9uKHF1ZXJpZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gZXhlY3V0ZShjdHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2FzUm9vdEV4ZWMgPSBiZWdpbk1pY3JvVGlja1Njb3BlKCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlRnVuY0lzQXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ2ID0gbmV3U2NvcGUocXVlcmllciwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlRnVuY0lzQXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ2ID0gcnYuZmluYWxseShkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgd2FzUm9vdEV4ZWMgJiYgZW5kTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2xvc2VkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgYWJvcnRDb250cm9sbGVyO1xuICAgICAgICAgICAgdmFyIGFjY3VtTXV0cyA9IHt9O1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRPYnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICAgICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb3NlZDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ZWRMaXN0ZW5pbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxFdmVudHMuc3RvcmFnZW11dGF0ZWQudW5zdWJzY3JpYmUobXV0YXRpb25MaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvYnNlcnZlci5zdGFydCAmJiBvYnNlcnZlci5zdGFydChzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ZWRMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBkb1F1ZXJ5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhlY0luR2xvYmFsQ29udGV4dChfZG9RdWVyeSk7IH07XG4gICAgICAgICAgICBmdW5jdGlvbiBzaG91bGROb3RpZnkoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ic1NldHNPdmVybGFwKGN1cnJlbnRPYnMsIGFjY3VtTXV0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbXV0YXRpb25MaXN0ZW5lciA9IGZ1bmN0aW9uIChwYXJ0cykge1xuICAgICAgICAgICAgICAgIGV4dGVuZE9ic2VydmFiaWxpdHlTZXQoYWNjdW1NdXRzLCBwYXJ0cyk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZE5vdGlmeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvUXVlcnkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIF9kb1F1ZXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgIWRvbURlcHMuaW5kZXhlZERCKVxuICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWNjdW1NdXRzID0ge307XG4gICAgICAgICAgICAgICAgdmFyIHN1YnNjciA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIpXG4gICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0ge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3I6IHN1YnNjcixcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXJ5OiBkb1F1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBxdWVyaWVyOiBxdWVyaWVyLFxuICAgICAgICAgICAgICAgICAgICB0cmFuczogbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IGV4ZWN1dGUoY3R4KTtcbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUocmV0KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZWQgfHwgY3R4LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWNjdW1NdXRzID0ge307XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPYnMgPSBzdWJzY3I7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb2JqZWN0SXNFbXB0eShjdXJyZW50T2JzKSAmJiAhc3RhcnRlZExpc3RlbmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRzKERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FLCBtdXRhdGlvbkxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWRMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGV4ZWNJbkdsb2JhbENvbnRleHQoZnVuY3Rpb24gKCkgeyByZXR1cm4gIWNsb3NlZCAmJiBvYnNlcnZlci5uZXh0ICYmIG9ic2VydmVyLm5leHQocmVzdWx0KTsgfSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBoYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIVsnRGF0YWJhc2VDbG9zZWRFcnJvcicsICdBYm9ydEVycm9yJ10uaW5jbHVkZXMoZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNsb3NlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjSW5HbG9iYWxDb250ZXh0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IgJiYgb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZG9RdWVyeSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgICAgICB9KTtcbiAgICAgICAgb2JzZXJ2YWJsZS5oYXNWYWx1ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc1ZhbHVlOyB9O1xuICAgICAgICBvYnNlcnZhYmxlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY3VycmVudFZhbHVlOyB9O1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICB9XG5cbiAgICB2YXIgRGV4aWUgPSBEZXhpZSQxO1xuICAgIHByb3BzKERleGllLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZnVsbE5hbWVFeGNlcHRpb25zKSwge1xuICAgICAgICBkZWxldGU6IGZ1bmN0aW9uIChkYXRhYmFzZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBkYiA9IG5ldyBEZXhpZShkYXRhYmFzZU5hbWUsIHsgYWRkb25zOiBbXSB9KTtcbiAgICAgICAgICAgIHJldHVybiBkYi5kZWxldGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXhpc3RzOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZShuYW1lLCB7IGFkZG9uczogW10gfSkub3BlbigpLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pLmNhdGNoKCdOb1N1Y2hEYXRhYmFzZUVycm9yJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0pO1xuICAgICAgICB9LFxuICAgICAgICBnZXREYXRhYmFzZU5hbWVzOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldERhdGFiYXNlTmFtZXMoRGV4aWUuZGVwZW5kZW5jaWVzKS50aGVuKGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVmaW5lQ2xhc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIENsYXNzKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBleHRlbmQodGhpcywgY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ2xhc3M7XG4gICAgICAgIH0sIGlnbm9yZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoc2NvcGVGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUFNELnRyYW5zID9cbiAgICAgICAgICAgICAgICB1c2VQU0QoUFNELnRyYW5zbGVzcywgc2NvcGVGdW5jKSA6XG4gICAgICAgICAgICAgICAgc2NvcGVGdW5jKCk7XG4gICAgICAgIH0sIHZpcDogdmlwLCBhc3luYzogZnVuY3Rpb24gKGdlbmVyYXRvckZuKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBydiA9IGF3YWl0SXRlcmF0b3IoZ2VuZXJhdG9yRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcnYgfHwgdHlwZW9mIHJ2LnRoZW4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUocnYpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgc3Bhd246IGZ1bmN0aW9uIChnZW5lcmF0b3JGbiwgYXJncywgdGhpeikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgcnYgPSBhd2FpdEl0ZXJhdG9yKGdlbmVyYXRvckZuLmFwcGx5KHRoaXosIGFyZ3MgfHwgW10pKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJ2IHx8IHR5cGVvZiBydi50aGVuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUocnYpO1xuICAgICAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY3VycmVudFRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFBTRC50cmFucyB8fCBudWxsOyB9XG4gICAgICAgIH0sIHdhaXRGb3I6IGZ1bmN0aW9uIChwcm9taXNlT3JGdW5jdGlvbiwgb3B0aW9uYWxUaW1lb3V0KSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IERleGllUHJvbWlzZS5yZXNvbHZlKHR5cGVvZiBwcm9taXNlT3JGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgRGV4aWUuaWdub3JlVHJhbnNhY3Rpb24ocHJvbWlzZU9yRnVuY3Rpb24pIDpcbiAgICAgICAgICAgICAgICBwcm9taXNlT3JGdW5jdGlvbilcbiAgICAgICAgICAgICAgICAudGltZW91dChvcHRpb25hbFRpbWVvdXQgfHwgNjAwMDApO1xuICAgICAgICAgICAgcmV0dXJuIFBTRC50cmFucyA/XG4gICAgICAgICAgICAgICAgUFNELnRyYW5zLndhaXRGb3IocHJvbWlzZSkgOlxuICAgICAgICAgICAgICAgIHByb21pc2U7XG4gICAgICAgIH0sXG4gICAgICAgIFByb21pc2U6IERleGllUHJvbWlzZSxcbiAgICAgICAgZGVidWc6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVidWc7IH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHNldERlYnVnKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVyaXZlOiBkZXJpdmUsIGV4dGVuZDogZXh0ZW5kLCBwcm9wczogcHJvcHMsIG92ZXJyaWRlOiBvdmVycmlkZSxcbiAgICAgICAgRXZlbnRzOiBFdmVudHMsIG9uOiBnbG9iYWxFdmVudHMsIGxpdmVRdWVyeTogbGl2ZVF1ZXJ5LCBleHRlbmRPYnNlcnZhYmlsaXR5U2V0OiBleHRlbmRPYnNlcnZhYmlsaXR5U2V0LFxuICAgICAgICBnZXRCeUtleVBhdGg6IGdldEJ5S2V5UGF0aCwgc2V0QnlLZXlQYXRoOiBzZXRCeUtleVBhdGgsIGRlbEJ5S2V5UGF0aDogZGVsQnlLZXlQYXRoLCBzaGFsbG93Q2xvbmU6IHNoYWxsb3dDbG9uZSwgZGVlcENsb25lOiBkZWVwQ2xvbmUsIGdldE9iamVjdERpZmY6IGdldE9iamVjdERpZmYsIGNtcDogY21wLCBhc2FwOiBhc2FwJDEsXG4gICAgICAgIG1pbktleTogbWluS2V5LFxuICAgICAgICBhZGRvbnM6IFtdLFxuICAgICAgICBjb25uZWN0aW9uczogY29ubmVjdGlvbnMsXG4gICAgICAgIGVycm5hbWVzOiBlcnJuYW1lcyxcbiAgICAgICAgZGVwZW5kZW5jaWVzOiBkb21EZXBzLCBjYWNoZTogY2FjaGUsXG4gICAgICAgIHNlbVZlcjogREVYSUVfVkVSU0lPTiwgdmVyc2lvbjogREVYSUVfVkVSU0lPTi5zcGxpdCgnLicpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBwYXJzZUludChuKTsgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKHAsIGMsIGkpIHsgcmV0dXJuIHAgKyAoYyAvIE1hdGgucG93KDEwLCBpICogMikpOyB9KSB9KSk7XG4gICAgRGV4aWUubWF4S2V5ID0gZ2V0TWF4S2V5KERleGllLmRlcGVuZGVuY2llcy5JREJLZXlSYW5nZSk7XG5cbiAgICBpZiAodHlwZW9mIGRpc3BhdGNoRXZlbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBhZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBnbG9iYWxFdmVudHMoREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsIGZ1bmN0aW9uICh1cGRhdGVkUGFydHMpIHtcbiAgICAgICAgICAgIGlmICghcHJvcGFnYXRpbmdMb2NhbGx5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50XzE7XG4gICAgICAgICAgICAgICAgZXZlbnRfMSA9IG5ldyBDdXN0b21FdmVudChTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUsIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB1cGRhdGVkUGFydHNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwcm9wYWdhdGluZ0xvY2FsbHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQoZXZlbnRfMSk7XG4gICAgICAgICAgICAgICAgcHJvcGFnYXRpbmdMb2NhbGx5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgZGV0YWlsID0gX2EuZGV0YWlsO1xuICAgICAgICAgICAgaWYgKCFwcm9wYWdhdGluZ0xvY2FsbHkpIHtcbiAgICAgICAgICAgICAgICBwcm9wYWdhdGVMb2NhbGx5KGRldGFpbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9wYWdhdGVMb2NhbGx5KHVwZGF0ZVBhcnRzKSB7XG4gICAgICAgIHZhciB3YXNNZSA9IHByb3BhZ2F0aW5nTG9jYWxseTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb3BhZ2F0aW5nTG9jYWxseSA9IHRydWU7XG4gICAgICAgICAgICBnbG9iYWxFdmVudHMuc3RvcmFnZW11dGF0ZWQuZmlyZSh1cGRhdGVQYXJ0cyk7XG4gICAgICAgICAgICBzaWduYWxTdWJzY3JpYmVyc05vdyh1cGRhdGVQYXJ0cywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBwcm9wYWdhdGluZ0xvY2FsbHkgPSB3YXNNZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcHJvcGFnYXRpbmdMb2NhbGx5ID0gZmFsc2U7XG5cbiAgICB2YXIgYmM7XG4gICAgdmFyIGNyZWF0ZUJDID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIGlmICh0eXBlb2YgQnJvYWRjYXN0Q2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY3JlYXRlQkMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBiYyA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSk7XG4gICAgICAgICAgICBiYy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIGV2LmRhdGEgJiYgcHJvcGFnYXRlTG9jYWxseShldi5kYXRhKTsgfTtcbiAgICAgICAgfTtcbiAgICAgICAgY3JlYXRlQkMoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBiYy51bnJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYmMudW5yZWYoKTtcbiAgICAgICAgfVxuICAgICAgICBnbG9iYWxFdmVudHMoREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsIGZ1bmN0aW9uIChjaGFuZ2VkUGFydHMpIHtcbiAgICAgICAgICAgIGlmICghcHJvcGFnYXRpbmdMb2NhbGx5KSB7XG4gICAgICAgICAgICAgICAgYmMucG9zdE1lc3NhZ2UoY2hhbmdlZFBhcnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKCFEZXhpZSQxLmRpc2FibGVCZkNhY2hlICYmIGV2ZW50LnBlcnNpc3RlZCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnRGV4aWU6IGhhbmRsaW5nIHBlcnNpc3RlZCBwYWdlaGlkZScpO1xuICAgICAgICAgICAgICAgIGJjID09PSBudWxsIHx8IGJjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiYy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgY29ubmVjdGlvbnNfMSA9IGNvbm5lY3Rpb25zOyBfaSA8IGNvbm5lY3Rpb25zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYiA9IGNvbm5lY3Rpb25zXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICBkYi5jbG9zZSh7IGRpc2FibGVBdXRvT3BlbjogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcigncGFnZXNob3cnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghRGV4aWUkMS5kaXNhYmxlQmZDYWNoZSAmJiBldmVudC5wZXJzaXN0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVidWcpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ0RleGllOiBoYW5kbGluZyBwZXJzaXN0ZWQgcGFnZXNob3cnKTtcbiAgICAgICAgICAgICAgICBjcmVhdGVCQygpO1xuICAgICAgICAgICAgICAgIHByb3BhZ2F0ZUxvY2FsbHkoeyBhbGw6IG5ldyBSYW5nZVNldCgtSW5maW5pdHksIFtbXV0pIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wTW9kaWZpY2F0aW9uKHsgYWRkOiB2YWx1ZSB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wTW9kaWZpY2F0aW9uKHsgcmVtb3ZlOiB2YWx1ZSB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlUHJlZml4KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wTW9kaWZpY2F0aW9uKHsgcmVwbGFjZVByZWZpeDogW2EsIGJdIH0pO1xuICAgIH1cblxuICAgIERleGllUHJvbWlzZS5yZWplY3Rpb25NYXBwZXIgPSBtYXBFcnJvcjtcbiAgICBzZXREZWJ1ZyhkZWJ1Zyk7XG5cbiAgICB2YXIgbmFtZWRFeHBvcnRzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICAgIERleGllOiBEZXhpZSQxLFxuICAgICAgICBsaXZlUXVlcnk6IGxpdmVRdWVyeSxcbiAgICAgICAgRW50aXR5OiBFbnRpdHksXG4gICAgICAgIGNtcDogY21wLFxuICAgICAgICBQcm9wTW9kU3ltYm9sOiBQcm9wTW9kU3ltYm9sLFxuICAgICAgICBQcm9wTW9kaWZpY2F0aW9uOiBQcm9wTW9kaWZpY2F0aW9uLFxuICAgICAgICByZXBsYWNlUHJlZml4OiByZXBsYWNlUHJlZml4LFxuICAgICAgICBhZGQ6IGFkZCxcbiAgICAgICAgcmVtb3ZlOiByZW1vdmUsXG4gICAgICAgICdkZWZhdWx0JzogRGV4aWUkMSxcbiAgICAgICAgUmFuZ2VTZXQ6IFJhbmdlU2V0LFxuICAgICAgICBtZXJnZVJhbmdlczogbWVyZ2VSYW5nZXMsXG4gICAgICAgIHJhbmdlc092ZXJsYXA6IHJhbmdlc092ZXJsYXBcbiAgICB9KTtcblxuICAgIF9fYXNzaWduKERleGllJDEsIG5hbWVkRXhwb3J0cywgeyBkZWZhdWx0OiBEZXhpZSQxIH0pO1xuXG4gICAgcmV0dXJuIERleGllJDE7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRleGllLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/dexie/dist/dexie.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/dexie/import-wrapper.mjs":
/*!***********************************************!*\
  !*** ./node_modules/dexie/import-wrapper.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Dexie: () => (/* binding */ Dexie),\n/* harmony export */   Entity: () => (/* binding */ Entity),\n/* harmony export */   PropModSymbol: () => (/* binding */ PropModSymbol),\n/* harmony export */   PropModification: () => (/* binding */ PropModification),\n/* harmony export */   RangeSet: () => (/* binding */ RangeSet),\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   cmp: () => (/* binding */ cmp),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   liveQuery: () => (/* binding */ liveQuery),\n/* harmony export */   mergeRanges: () => (/* binding */ mergeRanges),\n/* harmony export */   rangesOverlap: () => (/* binding */ rangesOverlap),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   replacePrefix: () => (/* binding */ replacePrefix)\n/* harmony export */ });\n/* harmony import */ var _dist_dexie_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/dexie.js */ \"(ssr)/./node_modules/dexie/dist/dexie.js\");\n// Making the module version consumable via require - to prohibit\n// multiple occurrancies of the same module in the same app\n// (dual package hazard, https://nodejs.org/api/packages.html#dual-package-hazard)\n\nconst DexieSymbol = Symbol.for(\"Dexie\");\nconst Dexie = globalThis[DexieSymbol] || (globalThis[DexieSymbol] = _dist_dexie_js__WEBPACK_IMPORTED_MODULE_0__);\nif (_dist_dexie_js__WEBPACK_IMPORTED_MODULE_0__.semVer !== Dexie.semVer) {\n    throw new Error(`Two different versions of Dexie loaded in the same app: ${_dist_dexie_js__WEBPACK_IMPORTED_MODULE_0__.semVer} and ${Dexie.semVer}`);\n}\nconst { liveQuery, mergeRanges, rangesOverlap, RangeSet, cmp, Entity,\n    PropModSymbol, PropModification, replacePrefix, add, remove } = Dexie;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Dexie);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZGV4aWUvaW1wb3J0LXdyYXBwZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ3FDO0FBQ3JDO0FBQ0Esb0VBQW9FLDJDQUFNO0FBQzFFLElBQUksa0RBQWE7QUFDakIsK0VBQStFLGtEQUFhLEVBQUUsTUFBTSxhQUFhO0FBQ2pIO0FBQ0EsUUFBUTtBQUNSLGtFQUFrRTtBQUVBO0FBQ2xFLGlFQUFlLEtBQUssRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dvb3Bvcy8uL25vZGVfbW9kdWxlcy9kZXhpZS9pbXBvcnQtd3JhcHBlci5tanM/YTNmZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBNYWtpbmcgdGhlIG1vZHVsZSB2ZXJzaW9uIGNvbnN1bWFibGUgdmlhIHJlcXVpcmUgLSB0byBwcm9oaWJpdFxuLy8gbXVsdGlwbGUgb2NjdXJyYW5jaWVzIG9mIHRoZSBzYW1lIG1vZHVsZSBpbiB0aGUgc2FtZSBhcHBcbi8vIChkdWFsIHBhY2thZ2UgaGF6YXJkLCBodHRwczovL25vZGVqcy5vcmcvYXBpL3BhY2thZ2VzLmh0bWwjZHVhbC1wYWNrYWdlLWhhemFyZClcbmltcG9ydCBfRGV4aWUgZnJvbSBcIi4vZGlzdC9kZXhpZS5qc1wiO1xuY29uc3QgRGV4aWVTeW1ib2wgPSBTeW1ib2wuZm9yKFwiRGV4aWVcIik7XG5jb25zdCBEZXhpZSA9IGdsb2JhbFRoaXNbRGV4aWVTeW1ib2xdIHx8IChnbG9iYWxUaGlzW0RleGllU3ltYm9sXSA9IF9EZXhpZSk7XG5pZiAoX0RleGllLnNlbVZlciAhPT0gRGV4aWUuc2VtVmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUd28gZGlmZmVyZW50IHZlcnNpb25zIG9mIERleGllIGxvYWRlZCBpbiB0aGUgc2FtZSBhcHA6ICR7X0RleGllLnNlbVZlcn0gYW5kICR7RGV4aWUuc2VtVmVyfWApO1xufVxuY29uc3QgeyBsaXZlUXVlcnksIG1lcmdlUmFuZ2VzLCByYW5nZXNPdmVybGFwLCBSYW5nZVNldCwgY21wLCBFbnRpdHksXG4gICAgUHJvcE1vZFN5bWJvbCwgUHJvcE1vZGlmaWNhdGlvbiwgcmVwbGFjZVByZWZpeCwgYWRkLCByZW1vdmUgfSA9IERleGllO1xuZXhwb3J0IHsgbGl2ZVF1ZXJ5LCBtZXJnZVJhbmdlcywgcmFuZ2VzT3ZlcmxhcCwgUmFuZ2VTZXQsIGNtcCwgRGV4aWUsIEVudGl0eSxcbiAgICBQcm9wTW9kU3ltYm9sLCBQcm9wTW9kaWZpY2F0aW9uLCByZXBsYWNlUHJlZml4LCBhZGQsIHJlbW92ZSB9O1xuZXhwb3J0IGRlZmF1bHQgRGV4aWU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/dexie/import-wrapper.mjs\n");

/***/ })

};
;